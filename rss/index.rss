<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Aimingoo's Blog</title><description>何不乐乐而有哉</description><link>http://aimingoo.github.io/</link><generator>Ghost 0.11</generator><lastBuildDate>Tue, 20 Jun 2017 03:57:30 GMT</lastBuildDate><atom:link href="http://aimingoo.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>三本免费电子书齐齐完工了</title><description>&lt;p&gt;首先感谢图灵出版社，能许可我将之前的《大道至易》拿回来重制并发布免费电子书。这也是此次选择图灵出版社、图灵社区来首发这套电子书的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大道至易：实践者的思想&lt;/li&gt;
&lt;li&gt;我的架构思想：基础模型、理论与原则&lt;/li&gt;
&lt;li&gt;程序原本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这套书同时发行了多种格式的电子版，包括ePub、eBook、PDF、mobi等。如果你使用桌面电脑，我推荐你阅读PDF格式的电子版。PDF格式的电子版采用了标准纸质书的排版方法，包括页眉、页脚、奇偶页设置，以及目录等等，因此建议阅读时使用“双页”版式并设置“首页不同”（在Macbook的预览中是默认的）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本电子书也针对Kindle进行过优化，全部插图采用了.svg矢量格式，确保在Kindle中阅读效果最佳。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;下载：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;目前推荐在图灵社区下载和讨论（当然也欢迎你在我的博客中留言，要登录你的Github账号先）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ituring.com.cn/book?tab=ebook&amp;amp;sort=new"&gt;图灵电子书&lt;/a&gt;首页查看；&lt;/li&gt;
&lt;li&gt;或直接&lt;a href="http://www.ituring.com.cn/book/2429"&gt;《程序原本》&lt;/a&gt;、&lt;a href="http://www.ituring.com.cn/book/2428"&gt;《大道至易：实践者的思想》&lt;/a&gt;，以及&lt;a href="http://www.ituring.com.cn/book/2430"&gt;《我的架构思想》&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;</description><link>http://aimingoo.github.io/1-1732/</link><guid isPermaLink="false">528fdfaa-f05a-492d-a914-b8296a57e7bd</guid><category>电子书</category><category>出版</category><category>软件工程</category><category>大道至易</category><category>架构</category><category>语言</category><dc:creator>aimingoo</dc:creator><pubDate>Tue, 20 Jun 2017 03:54:33 GMT</pubDate><content:encoded>&lt;p&gt;首先感谢图灵出版社，能许可我将之前的《大道至易》拿回来重制并发布免费电子书。这也是此次选择图灵出版社、图灵社区来首发这套电子书的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt=""&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大道至易：实践者的思想&lt;/li&gt;
&lt;li&gt;我的架构思想：基础模型、理论与原则&lt;/li&gt;
&lt;li&gt;程序原本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这套书同时发行了多种格式的电子版，包括ePub、eBook、PDF、mobi等。如果你使用桌面电脑，我推荐你阅读PDF格式的电子版。PDF格式的电子版采用了标准纸质书的排版方法，包括页眉、页脚、奇偶页设置，以及目录等等，因此建议阅读时使用“双页”版式并设置“首页不同”（在Macbook的预览中是默认的）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本电子书也针对Kindle进行过优化，全部插图采用了.svg矢量格式，确保在Kindle中阅读效果最佳。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;下载：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;目前推荐在图灵社区下载和讨论（当然也欢迎你在我的博客中留言，要登录你的Github账号先）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ituring.com.cn/book?tab=ebook&amp;amp;sort=new"&gt;图灵电子书&lt;/a&gt;首页查看；&lt;/li&gt;
&lt;li&gt;或直接&lt;a href="http://www.ituring.com.cn/book/2429"&gt;《程序原本》&lt;/a&gt;、&lt;a href="http://www.ituring.com.cn/book/2428"&gt;《大道至易：实践者的思想》&lt;/a&gt;，以及&lt;a href="http://www.ituring.com.cn/book/2430"&gt;《我的架构思想》&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>发布《大道至简》电子版（第三版）</title><description>&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/Tao-Simplest-Cover.png" alt=""&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;第六版：2017.05.03，电子版（第三版）&lt;/strong&gt;&lt;/p&gt;
  
  &lt;ul&gt;
  &lt;li&gt;&lt;p&gt;在发布《大道至易（第二版）》时为本书重制了电子版。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;内容在本书电子版（第二版）的基础上没有更新。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;使用markdown重排了全部格式，发布了.epub和.azw3版本，并重制了pdf版本。&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;关于本电子版&lt;/h2&gt;

&lt;p&gt;该电子版是采用上一版为底本的，并且没有作文字上的增修。主要是为了发布质量更好的版本而制作的。&lt;/p&gt;

&lt;p&gt;从第一版开始，本书的电子版一直都是没有封面的（考虑到效果，在本版本的.PDF上制作了一个简单的封面效果）。&lt;/p&gt;

&lt;h2 id=""&gt;下载&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 高质量的PDF版本 &lt;a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.zip"&gt;【下载】&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;推荐在桌面系统、PAD或大屏幕移动设备上阅读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 适用于Kindle的版本 &lt;a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.azw3"&gt;【下载】&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下载后用USB上传到Kindle即可。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你使用Amazon的“发送到设备”服务，那么这本书是不显示封面的。并且可能你需要将书的扩展名从.azw3改为.mobi。&lt;/p&gt;
  
  &lt;p&gt;上述的修改不影响阅读效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. 使用了SVG图的.epub版本 &lt;a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.epub"&gt;【下载】&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;推荐在Macbook、&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1731/</link><guid isPermaLink="false">ffa393a9-8644-4750-b302-0f0a9bf8c6e6</guid><category>大道至简</category><category>电子书</category><category>出版</category><category>软件工程</category><dc:creator>aimingoo</dc:creator><pubDate>Thu, 15 Jun 2017 20:03:08 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/Tao-Simplest-Cover.png" alt=""&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;第六版：2017.05.03，电子版（第三版）&lt;/strong&gt;&lt;/p&gt;
  
  &lt;ul&gt;
  &lt;li&gt;&lt;p&gt;在发布《大道至易（第二版）》时为本书重制了电子版。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;内容在本书电子版（第二版）的基础上没有更新。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;使用markdown重排了全部格式，发布了.epub和.azw3版本，并重制了pdf版本。&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;关于本电子版&lt;/h2&gt;

&lt;p&gt;该电子版是采用上一版为底本的，并且没有作文字上的增修。主要是为了发布质量更好的版本而制作的。&lt;/p&gt;

&lt;p&gt;从第一版开始，本书的电子版一直都是没有封面的（考虑到效果，在本版本的.PDF上制作了一个简单的封面效果）。&lt;/p&gt;

&lt;h2 id=""&gt;下载&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 高质量的PDF版本 &lt;a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.zip"&gt;【下载】&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;推荐在桌面系统、PAD或大屏幕移动设备上阅读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 适用于Kindle的版本 &lt;a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.azw3"&gt;【下载】&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下载后用USB上传到Kindle即可。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你使用Amazon的“发送到设备”服务，那么这本书是不显示封面的。并且可能你需要将书的扩展名从.azw3改为.mobi。&lt;/p&gt;
  
  &lt;p&gt;上述的修改不影响阅读效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3. 使用了SVG图的.epub版本 &lt;a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.epub"&gt;【下载】&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;推荐在Macbook、iPhone或iPad中的iBooks软件上阅读。在其它支持“内置SVG图的.epub电子书”的阅读器上也有较好的阅读效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 一般质量图片的.epub版本 &lt;a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest-i.epub"&gt;【下载】&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般的掌上阅读软件都可以支持。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 低版本Kindle使用的阅读格式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即低版本.mobi文件，阅读体验较差。请移驾我的Github（&lt;a href="https://github.com/aimingoo/my-ebooks"&gt;在这里&lt;/a&gt;）获取下载。&lt;/p&gt;

&lt;h2 id=""&gt;历史中的版本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最早发布这本书的电子版是在12年前，在这里：&lt;a href="http://aimingoo.github.io/1-197"&gt;公开《大道至简——软件工程实践者的思想》电子版&lt;/a&gt; &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2012年发布了它的电子版第二版，在这里：&lt;a href="http://aimingoo.github.io/1-261"&gt;大动作！！！公开《大道至简：软件工程实践者的思想》电子版（第二版）&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本书（含纸质版）主要版次共有六版。其中各版本细节，请翻阅电子书末尾的“版本历史”。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>Kindle的四种封面</title><description>&lt;p&gt;Kindle电子书的封面到底是多大呢？&lt;/p&gt;

&lt;p&gt;这是个几乎无解的问题，无论如何，你找不到一个通用、有效的答案。但总的来说，视作用的不同，Kindle的封面为成四种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官方营销封面&lt;/li&gt;
&lt;li&gt;收藏夹封面&lt;/li&gt;
&lt;li&gt;首页列表封面&lt;/li&gt;
&lt;li&gt;电子书封面&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=""&gt;一、官方营销封面&lt;/h2&gt;

&lt;p&gt;这个封面设计见于官方文档（&lt;a href="http://http://kindlegen.s3.amazonaws.com/AmazonKindlePublishingGuidelines.pdf"&gt;Amazon Kindle Publishing Guidelines&lt;/a&gt;）。营销封面最好是2700×1688px，300ppi，图片大小不得超过5MB。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在稍早一些的文档中，这个大小被推荐为2560×1600，其比例是16:10。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;营销封面是用于亚马逊官方营销推广的，通常它是一本书“封面+书脊+封底”的完整样式。它不在书籍中直接使用，而是要求通过官方发布系统上传给亚马逊网站的。&lt;/p&gt;

&lt;p&gt;营销封面如果没有达到指定大小，那么在上传的时候会有一个提示；如果图片最小边小于500px，那么在网站上根本就不显示了。&lt;/p&gt;

&lt;h2 id=""&gt;二、收藏夹封面&lt;/h2&gt;

&lt;p&gt;这个封面是指从Kindle设备的首页进入“我的图书馆”或“收藏夹”时所看到的图书封面。&lt;/p&gt;

&lt;p&gt;如果你直接从电脑放拷贝电子书到Kindle设备中，那么是不会显示这个封面的。它的大小并没有任何约定的规则，&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1729/</link><guid isPermaLink="false">6355a22b-27ba-47c6-90c2-c510bd56ee9c</guid><category>Kindle</category><category>电子书</category><dc:creator>aimingoo</dc:creator><pubDate>Mon, 12 Jun 2017 18:56:49 GMT</pubDate><content:encoded>&lt;p&gt;Kindle电子书的封面到底是多大呢？&lt;/p&gt;

&lt;p&gt;这是个几乎无解的问题，无论如何，你找不到一个通用、有效的答案。但总的来说，视作用的不同，Kindle的封面为成四种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官方营销封面&lt;/li&gt;
&lt;li&gt;收藏夹封面&lt;/li&gt;
&lt;li&gt;首页列表封面&lt;/li&gt;
&lt;li&gt;电子书封面&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=""&gt;一、官方营销封面&lt;/h2&gt;

&lt;p&gt;这个封面设计见于官方文档（&lt;a href="http://http://kindlegen.s3.amazonaws.com/AmazonKindlePublishingGuidelines.pdf"&gt;Amazon Kindle Publishing Guidelines&lt;/a&gt;）。营销封面最好是2700×1688px，300ppi，图片大小不得超过5MB。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在稍早一些的文档中，这个大小被推荐为2560×1600，其比例是16:10。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;营销封面是用于亚马逊官方营销推广的，通常它是一本书“封面+书脊+封底”的完整样式。它不在书籍中直接使用，而是要求通过官方发布系统上传给亚马逊网站的。&lt;/p&gt;

&lt;p&gt;营销封面如果没有达到指定大小，那么在上传的时候会有一个提示；如果图片最小边小于500px，那么在网站上根本就不显示了。&lt;/p&gt;

&lt;h2 id=""&gt;二、收藏夹封面&lt;/h2&gt;

&lt;p&gt;这个封面是指从Kindle设备的首页进入“我的图书馆”或“收藏夹”时所看到的图书封面。&lt;/p&gt;

&lt;p&gt;如果你直接从电脑放拷贝电子书到Kindle设备中，那么是不会显示这个封面的。它的大小并没有任何约定的规则，有文档称它总是被缩小到330px高度显示，并且宽高比为1:1.6。&lt;/p&gt;

&lt;p&gt;事实上这个大小并不是个确数。这是因为这张封面图“按理说”应该是由亚马逊的线上系统向下推送到你的设备的，因此它会根据你的设备的大小而改变下推封面图片的宽高。从经验上说，这个值可能包括的大小有：305x458, 291x467, 305x461, 305x430 (a shorter, wider cover), 257x467 (a tall, narrow cover)等等。关于这一点，Calibre在它的源码中也有备注（&lt;a href="https://github.com/kovidgoyal/calibre/commit/38bf9adba33a7a15b3aee5e6c99e13727a4afc46"&gt;kindle/driver.py&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# x330 on the PaperWhite
# x262 on the Touch. Doesn't choke on x330, though.
# x470 on the Voyage, checked that it works on PW, dont have Touch anymore
THUMBNAIL_HEIGHT = 470  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，如果你设计一张收藏夹封面缩略图，那么建议的大小可以是294x470px，或者上述列出的大小中最接近你的设备的值。&lt;/p&gt;

&lt;p&gt;无论如何，假设你有这样一张收藏夹封面图，那么你可以用“发送到Kindle（参见后文）”这样的功能来上传它（而不是直接从电脑里复制文件到设备中），这样才能使它有效。&lt;/p&gt;

&lt;h2 id=""&gt;三、首页列表封面&lt;/h2&gt;

&lt;p&gt;首页列表封面是当你按下“导航”栏中的“首页（Home）”按钮时，返回到首页——这时你的文档会出现在首页推荐（可能是前三个）——时出现的封面图。当然，这需要当前在“网格视图”模式下，因为列表模式是不显示封面的。&lt;/p&gt;

&lt;p&gt;这个封面的特殊之处在于它其实与下面所说的“电子书封面”（第四种）是同一个，但是显示方式会不同。就目前来说，当可能显示成完整大小和1/2大小两种模式——在首页列表中。&lt;/p&gt;

&lt;p&gt;因此你得考虑在这个模式下它让人比较舒适的大小——毕竟这是最常见的、第一视觉的。然而，同样不幸的是，它也没有官方文档支持。你在“电子书封面”（第四种）中设置了多大，它就在首页等比缩放然后显示出来，完全无视宽高比、清晰度等等任何东西。&lt;/p&gt;

&lt;p&gt;而且，它还会在右上角占掉一个位置来显示“当前阅读进度”。通常，它可能还会遮挡一点你的书名。&lt;/p&gt;

&lt;p&gt;总之是很崩溃的。&lt;/p&gt;

&lt;h2 id=""&gt;四、电子书封面（内容封面）&lt;/h2&gt;

&lt;p&gt;这才是一本书“正式的”封面。所谓正式的，是因为它被写入到你的电子书(.mobi或.azw3等)文件内部，是不变的。&lt;/p&gt;

&lt;p&gt;通常情况下，它是一本相应纸质书的封面。所以它事实上的大小，也不是亚马逊所能决定的。也因为同样的缘故，“如何很好地显示它”就变成了问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有文章推荐说这里的封面宽高比推荐是1:1.725。我尝试过，但这种封面过高，显得特别瘦窄。而且跟实体书比例差距过大，很难制作出一张比例协调的封面用图。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如上一小节所说，它会在“首页列表封面”上显示，然而可能因为它的比例显示得不那么好看。另外一种“更正确地”找到它的方法，是打开这本书之后，进入目录，在最前面处找到“封面”并点击进入。&lt;/p&gt;

&lt;p&gt;这样看到的封面才是“电子书封面”真正的样子。当然，也可能很不幸，因为它可能根本不是为你的设备而设计的，于是很可能底边是空白的，或左右两侧是空白的。&lt;/p&gt;

&lt;p&gt;总而言之，你无法决定这张封面如何在设备上显示。&lt;/p&gt;

&lt;h2 id=""&gt;五、总结&lt;/h2&gt;

&lt;p&gt;没有什么好方法确保第四种模式在“所有设备”上都能获得很好的阅读体验。建议你制作的封面能让它在第三种模式（首页列表封面）正确而友好的显示即可。&lt;/p&gt;

&lt;p&gt;这种情况下，我一般建议封面是采用1200x860模式，它比较接近A4开本的封面，即使你在真实印刷中使用也不需要对版面布局明显修改。&lt;/p&gt;

&lt;p&gt;如果你使用新的.azw3（KF8）格式，那么目前没有办法得到收藏夹封面。“发送”功能只能将新文档.azw3放在“Docs”分类中，因此会是一个没有封面的显示“个人文档”（也称为PDOC）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这篇文章：&lt;a href="http://aimingoo.github.io/1-1730"&gt;《如何将电子书发送到Kindle》&lt;/a&gt;，会有关于这个问题的更详细解释。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你有兴趣，可以进一步阅读这篇：&lt;a href="http://www.inknet.com.tw/help/teach/page/2"&gt;作品版面尺寸的設定&lt;/a&gt;，以及这篇&lt;a href="https://www.epubble.com/kindle-book-cover-size"&gt;Kindle book cover size&lt;/a&gt;。&lt;/p&gt;</content:encoded></item><item><title>如何将电子书发送到Kindle</title><description>&lt;p&gt;前面我们讲到过“如果要在收藏夹模式下看到封面，需要将电子书‘发送’到设备”。&lt;/p&gt;

&lt;p&gt;但这个“发送电子书”的功能其实有很多限制，下面我们来讲讲到底该如何做。&lt;/p&gt;

&lt;h2 id="1"&gt;1. 先说一个例外&lt;/h2&gt;

&lt;p&gt;首先，这事实上有一个例外。在&lt;a href="http://blog.sina.com.cn/s/blog_5374fceb0102v58q.html"&gt;seutfy的文章&lt;/a&gt;中讲到，有以下几个条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;113(ASIN)值是真实的，与亚马逊上的值相同；  &lt;/li&gt;
&lt;li&gt;504(ASIN)值与113相同，也是真实的；  &lt;/li&gt;
&lt;li&gt;501(CDE type)值为EBOK。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;满足以上三个条件，此电子书会在联网的情况下自动从亚马逊服务器上下载封面。为什么呢？因为这意味着这是一本在亚马逊官方发布过的电子书，因此可以在它的服务器上搜索到。这也是有些电子书你能直接复制到Kindle设备中，并且显示它的封面的原因——他们“原本”是从官方下载的。&lt;/p&gt;

&lt;h2 id="2kindle"&gt;2. 找到你的Kindle所绑定的邮箱&lt;/h2&gt;

&lt;p&gt;所以，继续回到正题。如果这是一本“自制的”——或者非官方网站下载来的电子书，那么你还是得用“将电子书发送到Kindle”的方法。这也是有开源的脚本代码的，&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1730/</link><guid isPermaLink="false">e69047cf-8e61-4488-8dfc-2399d339590f</guid><category>Kindle</category><category>电子书</category><dc:creator>aimingoo</dc:creator><pubDate>Mon, 12 Jun 2017 18:55:24 GMT</pubDate><content:encoded>&lt;p&gt;前面我们讲到过“如果要在收藏夹模式下看到封面，需要将电子书‘发送’到设备”。&lt;/p&gt;

&lt;p&gt;但这个“发送电子书”的功能其实有很多限制，下面我们来讲讲到底该如何做。&lt;/p&gt;

&lt;h2 id="1"&gt;1. 先说一个例外&lt;/h2&gt;

&lt;p&gt;首先，这事实上有一个例外。在&lt;a href="http://blog.sina.com.cn/s/blog_5374fceb0102v58q.html"&gt;seutfy的文章&lt;/a&gt;中讲到，有以下几个条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;113(ASIN)值是真实的，与亚马逊上的值相同；  &lt;/li&gt;
&lt;li&gt;504(ASIN)值与113相同，也是真实的；  &lt;/li&gt;
&lt;li&gt;501(CDE type)值为EBOK。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;满足以上三个条件，此电子书会在联网的情况下自动从亚马逊服务器上下载封面。为什么呢？因为这意味着这是一本在亚马逊官方发布过的电子书，因此可以在它的服务器上搜索到。这也是有些电子书你能直接复制到Kindle设备中，并且显示它的封面的原因——他们“原本”是从官方下载的。&lt;/p&gt;

&lt;h2 id="2kindle"&gt;2. 找到你的Kindle所绑定的邮箱&lt;/h2&gt;

&lt;p&gt;所以，继续回到正题。如果这是一本“自制的”——或者非官方网站下载来的电子书，那么你还是得用“将电子书发送到Kindle”的方法。这也是有开源的脚本代码的，例如&lt;a href="https://github.com/serzh/tokindle"&gt;tokindle&lt;/a&gt;，或者
&lt;a href="https://github.com/nicholaswilde/upload2Kindle"&gt;upload2Kindle&lt;/a&gt;。原理上也完全一样：就是向与你的Kindle设备绑定的一个邮箱发电子书附件。&lt;/p&gt;

&lt;p&gt;你得首先知道这个绑定的邮箱。这事实上有两个（注意，这两个并不一样），其一是你的amazon登录账号，另一个则是每个设备（例如你有多个kindle）都独有的一个邮箱。&lt;/p&gt;

&lt;p&gt;我强烈建议你读一下这篇文章&lt;a href="http://www.hangge.com/blog/cache/detail_1626.html"&gt;《将电子书发送到Kindle上的几种方法》&lt;/a&gt;所讲，并且建议你先立即开始尝试一下其中的方法2，即“&lt;strong&gt;官方软件Send to kindle&lt;/strong&gt;”，下载地址在&lt;a href="https://www.amazon.com/gp/sendtokindle/pc"&gt;这里&lt;/a&gt;，或&lt;a href="https://www.amazon.com/gp/sendtokindle/mac"&gt;Mac版本&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这个官方的“&lt;strong&gt;Send to Kindle&lt;/strong&gt;”软件的好处是简单、安全可信：你填入你的amazon账号就可用了。并且，它会列出你可以发送到的Kindle设备列表。但是，它只支持向设备有限格式的电子书（DOC,DOCX,PDF,HTML,TXT and RTF），别的格式（例如你自制的.azw3）都不支持。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kindle的.mobi格式没有在上述列表中，但是“&lt;strong&gt;Send to Kindle&lt;/strong&gt;”是支持的。另外，你可以直接将.azw3更名为.mobi，也是可以用该软件发送的。但是，无论如何这都是跳不出后面讲到的关于封面的限制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是因为其它软件的原理是一样的，所以我们知道，关键在于找到amazon账号下面的那个“可以发送到的Kindle设备列表（Deliver to list）”。如果你从网站上登录你的amazon账号，那么可以在“Manage Your Content and Devices”中找到它。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;图：官方网站入口
  &lt;img src="http://aimingoo.github.io/content/images/2017/06/-----2017-06-12-23.56.59.png" alt=""&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更快捷的方法是在上面的“&lt;strong&gt;Send to Kindle&lt;/strong&gt;”软件中，在它的界面的最下边有“Manage your Kindle”，点击进入就可以了（这就是我建议你先尝试它的主要原因了）。&lt;/p&gt;

&lt;p&gt;现在你应该在官方网站的“Manage Your Content and Devices”界面中，点击其中的“Your Devices”页，并在你的设备列表的左侧找到“…”按钮(Actions)，点击它会看到一个弹出框，上面就写着这个设备所绑定的email了，通常它是：xxxxx@kindle.com。&lt;/p&gt;

&lt;h2 id="3"&gt;3. 将发送邮箱添加到许可列表&lt;/h2&gt;

&lt;p&gt;接下来我们再切换到“Settings”页，找到“Approved Personal Document E-mail List”选项，你会看到你的amazon登录邮箱已经默认地添加在这里——这就是“&lt;strong&gt;Send to Kindle&lt;/strong&gt;”这个软件能工作的原因了。如果你打算用别的邮箱来发电子书，那么你可以将邮箱地址添加到这里，否则是不能用的——如果你没有添加，那么用其它邮箱发电子书的时候，会被拒绝并在你的amazon登录邮箱中收到一个提醒邮件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里提到这个细节的原因，是Calibre这个软件会推荐你使用gmx或hotmail邮箱。那么这时，就需要将这些邮箱地址添加到这个列表中去了。&lt;/p&gt;
  
  &lt;p&gt;另外，gmx缺省不开放SMTP邮箱服务。因此如果你真在Calibre尝试这个邮箱，那么要先去开通它（我已经被坑过了）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="4calibre"&gt;4. 使用Calibre或其它发送工具&lt;/h2&gt;

&lt;p&gt;接下来，当你知道：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你的设备绑定的邮箱，例如xxxxx@kindle.com；且&lt;/li&gt;
&lt;li&gt;你已经将打算发邮件的邮箱（例如你的登录账号或xxx@gmx.com等）添加到上述列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么你就可以使用Calibre或其它的什么工具来发送你的电子书到你的设备了。由于最终其实经过Kindle官方的邮件服务（因为最终绑定的是xxxxx@kindle.com）来处理，所以下发到你的Kindle设备时，就可以有一张“收藏夹封面”图了。&lt;/p&gt;

&lt;p&gt;其它细节，仍推荐阅读：&lt;a href="http://www.hangge.com/blog/cache/detail_1626.html"&gt;《将电子书发送到Kindle上的几种方法》&lt;/a&gt;，或者这一篇&lt;a href="https://kindlefere.com/post/11.html"&gt;《Calibre 使用教程之邮件一键推送电子书》&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id="5"&gt;5. 这个功能是有限制的&lt;/h2&gt;

&lt;p&gt;本质上来说，这样通过“发送”来得到的并不是“电子书”，而是电子文档。所以你在官方网站的“Manage Your Content and Devices”界面中的“Your Content”页面下，只能通过“Docs”这个分类来找到它——而不是缺省的Books分类。这也是惟一能操作这些文档的方法，因为你不能在设备上直接删除它们。&lt;/p&gt;

&lt;p&gt;在早期，Calibre可以制作一个.azw3格式的电子书并通过发送功能上传到设备（而且可以显示在Books分类中，并显示封面）。&lt;strong&gt;但现在这样的方法已经失效了。&lt;/strong&gt;amazon严格控制了使用邮件分发的方法来上传电子书的类型（上面列举过的），并且它会返回给你的邮箱一封关于失败原因的通知邮件。&lt;/p&gt;

&lt;p&gt;不过Calibre仍然是可以将一个使用官方KindleGen制作的.azw3文件发送到设备的。如上所述的，它在“Docs”分类中，并且没有封面——因为amazon认为它不是电子书。&lt;/p&gt;

&lt;h2 id="6azw3"&gt;6. 能使.azw3拥有封面的终极大招&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;已失效。低版件固件可尝试。Comment @2017.06.13&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，我知道你和我一样是有着对阅读有着近乎洁癖的要求：我完全不能忍受一本没有封面，或没有目录的书！&lt;/p&gt;

&lt;p&gt;好吧，如果这样，关于收藏夹封面的问题还是有解的：你可以使用&lt;a href="https://github.com/quiris11/ExtractCoverThumbs"&gt;ExtractCoverThumbs&lt;/a&gt;这个开源工具。作者发布了它的GUI和Console for Mac的版本（下载在上面地址的releases中）。如果你使用Windows，那么你可以自己下载一份源码（也可以编译成Window GUI的版本）来使用。&lt;/p&gt;

&lt;p&gt;ExtractCoverThumbs这个工具的作用是直接在你的Kindle的&lt;code&gt;/Volumes/Kindle/system/thumbnails/&lt;/code&gt;目录中生成封面的缩略图文件——因此绕开了从Kindle官方的下载过程。它可以操作很多类型的电子书或文档，并且可以帮助你从网上自动下载封面。不过，注意有一项限制：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你的Kindle固件版本在5.8.5之后，并且仅只针对“用Send功能发送，并同步到Kindle上的‘Docs’”，那么这个工具是不能帮你换封面的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其它所有情况下，它工作得很好。所以，如果是一个.azw3文件，那么你从电脑中复制到Kindle中去，并且用ExtractCoverThumbs处理一下，就OK了。&lt;/p&gt;</content:encoded></item><item><title>在电子书中使用SVG</title><description>&lt;blockquote&gt;
  &lt;p&gt;在之前的文章中，我们讨论了《&lt;a href="http://aimingoo.github.io/1-1726"&gt;Kindle电子书中该用多大的图片&lt;/a&gt;》，以及《&lt;a href="http://aimingoo.github.io/1-1727"&gt;详解ImageMagick中SVG的支持&lt;/a&gt;》，本文可以看作它们的后续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在高版本的电子书格式中是可以支持使用.svg作为图片的，并且看起来与.png/.jpg的使用并没有什么不同。但是，如何制作合适大小的.svg却是一个相当烦恼的问题。&lt;/p&gt;

&lt;p&gt;因为电子书在.svg文件上采用了与.png/.jpg不一样的排版规则。&lt;/p&gt;

&lt;h2 id="svg"&gt;一些.svg相关的基础知识&lt;/h2&gt;

&lt;p&gt;与.pdf一样，事实上.svg文件中也是没有DPI信息的，因为它们都是以矢量格式为基础的。而且它们也都相同的使用Points（磅值/点）来记录图片大小，或称之为页面信息。&lt;/p&gt;

&lt;p&gt;一般来说，.svg不支持多页。尽管多页格式已经发布（&lt;a href="https://www.w3.org/TR/2004/WD-SVG12-20041027/multipage.html"&gt;SVG 1.2&lt;/a&gt;），但多数系统并不支持它。&lt;/p&gt;

&lt;p&gt;所谓『.svg文件有多大的精度，或多少DPI』其实是个伪命题。因为这其实是不同的处理软件的一个假设/约定——这一点与.pdf是一样的。但不同的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;.pdf约定默认的分辨率是72DPI；而&lt;/li&gt;
&lt;li&gt;.svg通常约定的是90DPI。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而即使是同一个软件的不同版本，&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1728/</link><guid isPermaLink="false">d18ac6ba-a8ce-4b89-8f4e-57b5655612c7</guid><category>电子书</category><category>OpenSource Project</category><category>svg</category><category>ImageMagick</category><category>Kindle</category><dc:creator>aimingoo</dc:creator><pubDate>Wed, 07 Jun 2017 19:02:44 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;在之前的文章中，我们讨论了《&lt;a href="http://aimingoo.github.io/1-1726"&gt;Kindle电子书中该用多大的图片&lt;/a&gt;》，以及《&lt;a href="http://aimingoo.github.io/1-1727"&gt;详解ImageMagick中SVG的支持&lt;/a&gt;》，本文可以看作它们的后续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在高版本的电子书格式中是可以支持使用.svg作为图片的，并且看起来与.png/.jpg的使用并没有什么不同。但是，如何制作合适大小的.svg却是一个相当烦恼的问题。&lt;/p&gt;

&lt;p&gt;因为电子书在.svg文件上采用了与.png/.jpg不一样的排版规则。&lt;/p&gt;

&lt;h2 id="svg"&gt;一些.svg相关的基础知识&lt;/h2&gt;

&lt;p&gt;与.pdf一样，事实上.svg文件中也是没有DPI信息的，因为它们都是以矢量格式为基础的。而且它们也都相同的使用Points（磅值/点）来记录图片大小，或称之为页面信息。&lt;/p&gt;

&lt;p&gt;一般来说，.svg不支持多页。尽管多页格式已经发布（&lt;a href="https://www.w3.org/TR/2004/WD-SVG12-20041027/multipage.html"&gt;SVG 1.2&lt;/a&gt;），但多数系统并不支持它。&lt;/p&gt;

&lt;p&gt;所谓『.svg文件有多大的精度，或多少DPI』其实是个伪命题。因为这其实是不同的处理软件的一个假设/约定——这一点与.pdf是一样的。但不同的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;.pdf约定默认的分辨率是72DPI；而&lt;/li&gt;
&lt;li&gt;.svg通常约定的是90DPI。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而即使是同一个软件的不同版本，也可能修改这个约定。例如Inkscape 从v0.92版本开始就默认使用96DPI的约定——而之前它是90DPI（&lt;a href="http://wiki.inkscape.org/wiki/index.php/Release_notes/0.92#Important_changes"&gt;参见这里&lt;/a&gt;，以及&lt;a href="http://wiki.inkscape.org/wiki/index.php/Units_In_Inkscape"&gt;这里&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;相对好一些的消息是：能够实现SVG处理的引擎并不太多——所以上述的一些不确定的限制条件也就相对来说容易穷举。这些引擎主要包括Cario、Inkscape、Apache Batik和一些浏览器上的Canvas。当然，此前讲过的ImageMagick内置的MSVG也算一个，不过它实在弱到没朋友，不提也罢。很多工具其实是以上述引擎为内核或库的，其中最常用的是Cario，包括rsvg在内的许多库/包都只是Cario上的一个封装。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注1：Cario库也支持PDF，所以Inkscape、Poppler等都使用它来输出PDF和PostScript文档（生成的.pdf文件元信息中Creator也是Cario）。但是Inkscape的SVG渲染引擎是自有的，相关信息可以参考&lt;a href="https://en.wikipedia.org/wiki/Cairo_(graphics)"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文中提到的一些工具可以用如下方式安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;## rsvg, rsvg-convert, and cario ...
&amp;gt; brew install libsvg librsvg libsvg-cairo cairo

## pdf2svg, mactex(pdfcrop), Inkscape, more...
&amp;gt; brew install pdf2svg
&amp;gt; brew cask install xquartz mactex inkscape

# ImageMagick(identify,convert,mogrify...), and pdfinfo or cpdf
&amp;gt; brew install ghostscript imagemagick cpdf poppler

## cairosvg for python
&amp;gt; pip3 install cairosvg

## svginfo
&amp;gt; git clone http://github.com/aimingoo/svginfo
&amp;gt; install svginfo/svginfo /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="pdfsvg"&gt;从PDF到SVG&lt;/h2&gt;

&lt;p&gt;你可能已经习惯使用种种矢量图形工具并用来制作.svg，反正我不是。我通常是用PowerPoint或Keynote来制作它们（尤其是表格）并存储为PDF，然后由.pdf转为.svg。&lt;/p&gt;

&lt;p&gt;这个过程看起来麻烦，但确实靠谱。&lt;/p&gt;

&lt;p&gt;总的来说，从PDF到SVG的工具主要有两个（&lt;a href="https://en.wikipedia.org/wiki/Wikipedia:Graphics_Lab/Resources/PDF_conversion_to_SVG#How_to_convert_a_PDF_to_SVG"&gt;Wiki上也是这么说的&lt;/a&gt;）。其中最方便、快捷和安全的应该是cityinthesky的pdf2svg，他使用Poppler+Cario；另一个是inkscape，除了在字体处理上表现不稳定之外，它还需要XQuartz的支持（这就比较庞大了）。&lt;/p&gt;

&lt;p&gt;pdf2svg可以直接使用brew安装，它的开源项目&lt;a href="http://www.cityinthesky.co.uk/opensource/pdf2svg"&gt;在这里&lt;/a&gt;，或&lt;a href="https://github.com/indraniel/pdf2svg"&gt;这里&lt;/a&gt;。采用相同技术实现的还有&lt;a href="https://github.com/indraniel/pdf2svg"&gt;Perl&lt;/a&gt;和&lt;a href="https://github.com/jakobwesthoff/pdf2svg"&gt;Vala&lt;/a&gt;的版本——因为使用的都是相同的库，因此效果应该没差。其它可选的方案包括&lt;a href="https://github.com/ContentMine/pdf2svg"&gt;Java&lt;/a&gt;、&lt;a href="https://github.com/ststeiger/Pdf2Svg"&gt;C#&lt;/a&gt;版的等等，但采用的是各自语言下的引擎，我没有一一试过。&lt;/p&gt;

&lt;p&gt;使用pdf2svg的参数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; pdf2svg --help
Usage: pdf2svg &amp;lt;in file.pdf&amp;gt; &amp;lt;out file.svg&amp;gt; [&amp;lt;page no&amp;gt;]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;&amp;lt;page no&amp;gt;&lt;/code&gt;可以使用字符串&lt;code&gt;all&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意pdf2svg并不能指定输出的.svg的大小、DPI等等。其实你使用inkscape来转换也一样没有这类参数——在转换目标格式为.svg时，inkscape仅会多出&lt;code&gt;--export-text-to-path&lt;/code&gt;、&lt;code&gt;--export-id&lt;/code&gt;两个参数可用。此外，inkscape只能处理单页的PDF：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; inkscape -z --export-plain-svg=&amp;lt;out file.svg&amp;gt; &amp;lt;in file.pdf&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，pdf2svg与inkscape转换出来的.svg文件的页面大小其实是一样，但是它们使用的单位并不相同。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;## inkscape
&amp;gt; svginfo by-inkscape.svg
width: 152.5  
height: 77.5  
viewBox: 0 0 152.5 77.5

## pdf2svg, and more...
&amp;gt; svginfo by-cario.svg
width: 122pt  
height: 62pt  
viewBox: 0 0 122 62  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意inkscape转出时使用了缺省单位，这通常是指px；而cario转出时使用的是pt。对于上例来说，原始的pdf文件信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; pdfinfo my.pdf | grep 'Page size'
Page size:      122 x 62 pts  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，两种引擎事实上都是直接以该页面大小的pt值作为.svg的宽高，只不过inkscape转换成了相应的px值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注1：需要强调的是，上述版本的inkscape的采用的是90DPI的.svg设定，而PDF默认为72DPI。所以从&lt;code&gt;.PDF的Pts&lt;/code&gt;到&lt;code&gt;.SVG的px&lt;/code&gt;的转换系数是&lt;code&gt;90/72&lt;/code&gt;，即&lt;code&gt;width = 122pt * 90/72 = 152.5px&lt;/code&gt;。&lt;/p&gt;
  
  &lt;p&gt;注2：就我的测试来说，Inkscape在处理&lt;code&gt;PDF -&amp;gt; png&lt;/code&gt;的转换时不能正确的识别中文字体，其它类型下的转换我并没有一一试过。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="svginfoimagemagick"&gt;svginfo: 不要相信ImageMagick的显示&lt;/h2&gt;

&lt;p&gt;如果你使用&lt;code&gt;identify -verbose your.svg&lt;/code&gt;来查看svg的信息的话，那么由于ImageMagick可能工作在不同的SVG模式下，所以输出的信息也就不同。——这就是我的上一篇文章为什么叫《详解ImageMagick中SVG的支持》的原因。&lt;/p&gt;

&lt;p&gt;我测试了一下上文中提到的4种模式，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## test information of 'identify -verbose your.svg'
===&amp;gt; MODE: internal, use MSVG
  Geometry: 485x306+0+0
  Units: Undefined
===&amp;gt; MODE: build-in, use RSVG/librsvg
  Geometry: 517x327+0+0
  Resolution: 37.8x37.8
  Print size: 13.6772x8.65079
  Units: PixelsPerCentimeter
===&amp;gt; MODE: delegate(internal), use inkscape
  Geometry: 517x327+0+0
  Resolution: 37.8x37.8
  Print size: 13.6772x8.65079
  Units: PixelsPerCentimeter
===&amp;gt; MODE: delegate, use rsvg-convert
  Geometry: 517x327+0+0
  Units: Undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这四种模式中，MSVG是唯一一个不转换成图片（因为内置xml解析和svg支持）的方式，也是它与别的模式看起来有差异的原因。此外，由于缺省使用了&lt;code&gt;PixelsPerCentimeter&lt;/code&gt;单位，所以Resolution显示是&lt;code&gt;37.8x37.8&lt;/code&gt;，换算成英寸则是96DPI。&lt;/p&gt;

&lt;p&gt;那么这个&lt;code&gt;your.svg&lt;/code&gt;的大小到底是多少呢？很不幸，它真实的数据是&lt;code&gt;388x245 pts&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因为svg缺省是工作在90dpi模式下的，所以MSVG用90dpi来换算.svg的大小，就得到了&lt;code&gt;388 * 90/72 = 485px&lt;/code&gt;的宽，而其它模式都是先转换成图片，并指定了参数96DPI，这时宽度就成了&lt;code&gt;388 * 96/72 = 517px&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以无论如何（除非你能确切指定使用某一种SVG引擎），对于.svg来说，ImageMagick显示的大小是作不得准的。更好的办法是直接显示.svg中的元信息，例如使用&lt;code&gt;svginfo&lt;/code&gt;这个工具（&lt;a href="https://github.com/aimingoo/svginfo"&gt;下载在这里&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; svginfo your.svg
width: 388pt  
height: 245pt  
viewBox: 0 0 388 245  
zoomAndPan: magnify  
preserveAspectRatio: none  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在.svg的元信息中保存的width/height值可能有很多种单位（&lt;a href="http://www.sarasoueidan.com/blog/svg-coordinate-systems/#svg-viewport"&gt;参见这里&lt;/a&gt;，或&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Positions"&gt;中文译本&lt;/a&gt;，缺省是px，但与具体设备有关）。&lt;/p&gt;

&lt;h2 id="svg"&gt;电子书并其实不能『很正确』地显示.svg文件&lt;/h2&gt;

&lt;p&gt;现在我们得到了.svg，并且我们确切地知道它的大小与.pdf的Page Size的Pts值存在&lt;code&gt;90:72&lt;/code&gt;的关系（因为默认精度不同）。所以我们只需要控制.pdf的大小，就可以得到合适的.svg文件了。——不考虑.svg的工具的话，在.pdf的工具套件中还有cpdf，还有gs等等可用，很丰富。&lt;/p&gt;

&lt;p&gt;但是，真正的一张520pts(或者是520px)大小的.svg，会如何显示在电子书上呢？&lt;/p&gt;

&lt;p&gt;答案是：不一定。&lt;/p&gt;

&lt;p&gt;如果你在电子书中用&lt;code&gt;&amp;lt;img src="xxx.png"&amp;gt;&lt;/code&gt;来插入一张图片而没有指定它的宽高，那么几乎所有的排版引擎都能理解这个行为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将xxx.png图片信息中的宽高信息作为显示宽高；&lt;/li&gt;
&lt;li&gt;如果这个宽高大于设备的可见区域，则缩小到合适的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;——所以，在电子书中使用图片时只需要考虑图片的精度，其它方面几乎是完美的、自适应的。&lt;/p&gt;

&lt;p&gt;然而如果你用同样的方法来插入一个.svg文件，那么由于pt这个单位的存在，所以设备如何显示就成了『谜之问题』了。首先我们要知道，&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果一个.svg是使用px作为单位（也包括没有单位而缺省的），那么将采用与图片一致的规则。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是一条重要的原则，也成为检测其它.svg单位的关键钥匙。&lt;/p&gt;

&lt;p&gt;例如以前面的your.svg为例——它使用了pt作为单位，是388pt。由于.svg是缺省以90DPI为来计算pt值的，所以MSVG还原成px时，显示的是485px的宽。但是到了实际物理设备时，却不一定是以90DPI——这个假想值——来处理的了。例如在Macbook上的iBooks中显示时，iBooks的SVG渲染引擎采用了96DPI的预设值，所以就将显示成&lt;code&gt;388 * 96/72 = 517px&lt;/code&gt;；又例如我是要在Kindle Paperwhite3上来显示它，那么由于Kindle使用它的PPI（300DPI）来作为预设值，所以显示出来就应该是惊人的&lt;code&gt;1616px&lt;/code&gt;。——好吧，你知道Kindle显示不下了，而.svg是矢量缩放的，所以最终只是按可见区域的全宽来显示它。&lt;/p&gt;

&lt;p&gt;电子书的这个处理方案正确不呢？答案是『正确』。因为这其实就是pt作为单位的原始用意。它看起来不是那么『很正确』的原因在于：这样一来，我们就不知道到底该做多大的.svg才能在不同的物理设备上适用了。&lt;/p&gt;

&lt;p&gt;那么，最终只剩下了两条规则适用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在文件中明确使用px作为单位来指定大小的.svg；或者，&lt;/li&gt;
&lt;li&gt;在使用&lt;code&gt;&amp;lt;img ...&amp;gt;&lt;/code&gt;标签插入.svg时，指定它的宽高信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="pxsvg"&gt;使用px作为单位来指定大小的.svg&lt;/h2&gt;

&lt;p&gt;使用Inkscape转出的.svg是作用缺省单位px的。但是这个转换是采用.pdf的Points换算过来的，为此你必须将.pdf放大一些，才能在Inkscape中得到你预期的的px值大小。这个换算关系如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 步骤1：将.PDF的大小换算成300DPI下比例(放大300/90倍)
#    - 因为pdf转成svg时还要再放大90/72倍，所以这里不需要直接用300/72作系数
&amp;gt; cpdf -scale-page "3.33333 3.33333" -scale-to-fit-scale 3.33333 -o new_300DPI.pdf my.pdf

# 步骤2：将新文件转换成.svg
&amp;gt; inkscape -z --export-plain-svg=my.svg new_300DPI.pdf

# 查看原始的my.pdf的信息
&amp;gt; pdfinfo my.pdf | grep 'Page size'
Page size:      122 x 62 pts

# 查看中间文件.pdf的大小
&amp;gt; pdfinfo new_300DPI.pdf | grep 'Page size'
Page size:      406.666 x 206.666 pts

# 查看新的.svg的信息
&amp;gt; svginfo my.svg
width: 508.33282  
height: 258.33307  
viewBox: 0 0 508.33282 258.33307  
zoomAndPan: magnify  
preserveAspectRatio: none  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证方法：制作一张&lt;code&gt;508 x 258&lt;/code&gt;的图片，与my.svg一起插入到电子书中，它们显示起来将是相同大小。&lt;/p&gt;

&lt;h2 id="svg"&gt;正确插入.svg的宽高信息&lt;/h2&gt;

&lt;p&gt;我们也可以选择如下的途径（在这个过程中不需要对调整中间文件与.svg的大小）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
  &lt;li&gt;从.ppt/.key转换到.pdf，再&lt;/li&gt;
  &lt;li&gt;从.pdf转换到.svg，最后&lt;/li&gt;
  &lt;li&gt;在电子书中插入.svg的宽度信息。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们假设以.html作为生成电子书的中间格式（如果你真做过电子书的话，你应该知道我为什么这么假设），那么事实上我们就只需要扫描所有的.svg，通过svginfo来查看信息，经过计算并将正确的宽高信息写到.html就好了。&lt;/p&gt;

&lt;p&gt;我们需要知道相应的.svg与最初预设的宽高上限（注意考虑到实际使用，我只预设了x方向上限，并不处理y方向）。我们之前说过：合理的预设是&lt;code&gt;520px&lt;/code&gt;。所以，例如480px宽的.svg，那么我们就将&lt;code&gt;&amp;lt;img …&amp;gt;&lt;/code&gt;中的width值回写成&lt;code&gt;92.3%&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我想，你可能已经发现问题了：这个92.3%应该是指的图片相对于当前设备宽的比例啊，而不是图片自己的宽度值。——是的，我的确是这样考虑的，至于为什么，你得仔细去思考了。&lt;/p&gt;

&lt;p&gt;其它（建议综合我最近的几篇文章来理解下述过程）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们原始设计的宽是520px，在300DPI情况下的物理宽是1.73333inch；&lt;/li&gt;
&lt;li&gt;当把上述文档输出成PDF时，物理宽（Print Size）不变；而精度变成了PDF默认的72，所以在转换成Points值时变成了124.8pt，即&lt;code&gt;1.73333inch * 72pt/inch&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;我们再从.pdf转到.svg时是pt by pt的，所以相应的.svg值是124.8pt；
&lt;ul&gt;&lt;li&gt;如果使用Inkscape，则转换出的.svg是&lt;code&gt;width = 156&lt;/code&gt;，使用了缺省单位px；&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;identify msvg:your.svg&lt;/code&gt;取值最快，但要注意它总是以px为单位显示宽高信息；
&lt;ul&gt;&lt;li&gt;在不支持MSVG的ImageMagick的低版本中，建议用svginfo取值并转换单位&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相关操作如下（下载&lt;a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.pdf"&gt;standard_image_templet_520.pdf&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 步骤1：使用hires参数和高的resolution值可以使crop操作更精确
#    - 输出的.pdf的精度与该参数值是无关的
&amp;gt; pdfcrop --hires --resolution 1200 standard_image_templet_520.pdf croped.pdf

# 步骤2：转换pdf到svg
&amp;gt; pdf2svg croped.pdf standard_image_templet_520.svg 1

# 使用pdfinfo查看信息
&amp;gt; pdfinfo croped.pdf | grep 'Page size'
Page size:      124.8 x 73.26 pts

# 使用svginfo查看信息
&amp;gt; svginfo standard_image_templet_520.svg
width: 124.8pt  
height: 73.26pt  
viewBox: 0 0 124.8 73.26  
zoomAndPan: magnify  
preserveAspectRatio: none

# 使用identify查看信息(强制使用MSVG引擎)
&amp;gt; identify msvg:standard_image_templet_520.svg | xargs -n1
msvg:standard_image_templet_520.svg=&amp;gt;standard_image_templet_520.svg  
MSVG  
156x92  
156x92+0+0  
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=""&gt;黑科技：最后一点补充&lt;/h2&gt;

&lt;p&gt;如果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你确实想让.svg用px作为单位，以避免修改电子书中的width/height信息；并且，&lt;/li&gt;
&lt;li&gt;你确实又憎恨Inkscape的巨大安装包和超慢速度，以及它只能处理单页的问题；并且，&lt;/li&gt;
&lt;li&gt;你不太担心pdf2svg转换后的.svg文件较大的问题；并且，&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也许你只是纯粹的点处理爱好者（px fans?），那么好吧，我们讲一种最简单（目前看来也挺安全，但……我不做任何保证）的黑科技。下面仍然以&lt;code&gt;standard_image_templet_520.pdf&lt;/code&gt;这个文件为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 步骤1：在300DPI下crop，以提高crop的计算精度
#    - 输出的croped.pdf的精度与该参数值是无关的
&amp;gt; pdfcrop --hires --resolution 300 standard_image_templet_520.pdf croped.pdf

# 步骤1：将.PDF的大小假想成px单位，直接换算成300DPI下的大小
#    - 也就说无脑放大300/72倍就行啦
&amp;gt; cpdf -scale-page "4.166667 4.166667" -scale-to-fit-scale 4.166667 -o scaled.pdf croped.pdf

# 步骤3：使用pdf2svg转换
#    - pdf2svg得到的.svg是使用pt为单位的, 无脑改成px就行啦
#    - pdf2svg可处理多页(会成批生成文件，所以不要用stdout；这里只做单页的示例)
#    - 使用sed时只替换了&amp;lt;svg ...&amp;gt;标签中的width/height，其它的不作处理
&amp;gt; pdf2svg scaled.pdf /dev/stdout 1 |\
    sed -E '1,/^&amp;lt;svg/s/(width|height)="([0-9.]*)pt"/\1="\2px"/g' &amp;gt;\
    standard_image_templet_520.svg

# 查看最终的svg的大小
&amp;gt; svginfo standard_image_templet_520.svg
width: 520.000042px  
height: 305.000024px  
viewBox: 0 0 520.000042 305.000024  
zoomAndPan: magnify  
preserveAspectRatio: none

# 使用ImageMagick的MSVG模式查看
&amp;gt; identify msvg:standard_image_templet_520.svg | xargs -n2
msvg:standard_image_templet_520.svg=&amp;gt;standard_image_templet_520.svg MSVG  
520x305 520x305+0+0  
16-bit sRGB  
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么能这么做呢？&lt;/p&gt;

&lt;p&gt;首先，我们知道.svg文件中其实并没有精度信息，所有的元素都是基于页面的大小来做换算的。而且，我们在这里用pdf2svg转换出的.svg还有两个特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;字体已经被转换成矢量信息，因此.svg中不包含字体及字体大小信息；&lt;/li&gt;
&lt;li&gt;只有&lt;code&gt;&amp;lt;svg …/&amp;gt;&lt;/code&gt;元素包含了页面宽高信息，其它元素是基于该信息的矢量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以我们可以安全地将pt值直接替换成px。而这个方法，对于Inkscape生成的.svg就不适用，对比一下上面的两个特性你就明白了。反过来说，正是由于Cario引擎（pdf2svg使用的svg引擎）并不完整支持以px为单位的svg，所以使用该引擎——以及使用该引擎实现的工具来转换上述（修改后的）.svg到.png或其它格式的时候也是会出问题；而相对应的，Inkscape却能正确处理——它的引擎支持以px为单位的.svg。&lt;/p&gt;

&lt;p&gt;最后，多啰嗦一句。由于pdf2svg转换时将字体转换成了矢量信息，这使得通过这种.svg转换成图片或其它格式时不会因为缺少字体而失真（相对应的，Inkscape就存在字体问题）。但是缺点也是有的，就是.svg文件会比较大一些，可能相应的处理速度也会略慢。&lt;/p&gt;</content:encoded></item><item><title>详解ImageMagick中SVG的支持</title><description>&lt;p&gt;事实上ImageMagick是可以很好地支持svg的——当然，它只是将svg转成图片格式而不能反过来，毕竟它只是个图片处理工具。不论是在使用convert，identify还是mogrify等等时，只要操作的对象是一个.svg文件，那么ImageMagick就会启动这一机制。例如，当你使用identify查看一个.svg信息的时候，事实上你是在查看它转换后得到的一张.png图片：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -verbose your.svg
Image: /var/folders/w9/fy0l4xgj3w73j4d71748v9nw0000gn/T/magick-481524PstlAlieWiB  
  Base filename: your.svg
  Format: PNG (Portable Network Graphics)
  Mime type: image/png
  Class: DirectClass
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImageMagick主要有三种支持SVG的方式，包括内置（Internal）、内建（Build-in）和委托（Delegate）。&lt;/p&gt;

&lt;p&gt;在高版本的ImageMagick中MSVG总是内置的；而稍早些的版本中，&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1727/</link><guid isPermaLink="false">a849bf10-dbd6-4709-a2c2-dec2bc6c193c</guid><category>svg</category><category>ImageMagick</category><category>图形处理</category><category>OpenSource Project</category><category>电子书</category><dc:creator>aimingoo</dc:creator><pubDate>Mon, 05 Jun 2017 11:54:13 GMT</pubDate><content:encoded>&lt;p&gt;事实上ImageMagick是可以很好地支持svg的——当然，它只是将svg转成图片格式而不能反过来，毕竟它只是个图片处理工具。不论是在使用convert，identify还是mogrify等等时，只要操作的对象是一个.svg文件，那么ImageMagick就会启动这一机制。例如，当你使用identify查看一个.svg信息的时候，事实上你是在查看它转换后得到的一张.png图片：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -verbose your.svg
Image: /var/folders/w9/fy0l4xgj3w73j4d71748v9nw0000gn/T/magick-481524PstlAlieWiB  
  Base filename: your.svg
  Format: PNG (Portable Network Graphics)
  Mime type: image/png
  Class: DirectClass
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ImageMagick主要有三种支持SVG的方式，包括内置（Internal）、内建（Build-in）和委托（Delegate）。&lt;/p&gt;

&lt;p&gt;在高版本的ImageMagick中MSVG总是内置的；而稍早些的版本中，ImageMagick是混合了『内建』和『委托』两种方式来提供SVG的支持的。&lt;strong&gt;需要强调的是&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;请尽量不要直接使用内置的MSVG。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="msvg"&gt;内置的MSVG&lt;/h2&gt;

&lt;p&gt;ImageMagick的高版本内置了一个SVG渲染器。它有两种称谓，在代码中叫做&lt;code&gt;IMAGEMAGICK_SVG&lt;/code&gt;，例如在编译中提供相应的开关参数；而在用户级别的配置或接口中，它称为MSVG（这里的M是Magick的首字母）。它完整的名称是&lt;code&gt;ImageMagick's own SVG internal renderer&lt;/code&gt;，所以&lt;code&gt;自有SVG（Own SVG）&lt;/code&gt;、&lt;code&gt;内部渲染器（internal renderer）&lt;/code&gt;以及&lt;code&gt;MSVG&lt;/code&gt;其实指的都是同一个东西：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; convert -list format | grep SVG
     MSVG  SVG       rw+   ImageMagick's own SVG internal renderer
      SVG  SVG       rw+   Scalable Vector Graphics (XML 2.9.4)
     SVGZ  SVG       rw+   Compressed Scalable Vector Graphics (XML 2.9.4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里的『XML 2.9.4』其实也是MSVG引擎的一部分，它实际上指的是&lt;code&gt;libxml2&lt;/code&gt;这个库的版本，因为MSVG是基于xml解析并自行渲染的svg引擎。&lt;/p&gt;

&lt;p&gt;由于MSVG存在很多限制，所以ImageMagick『千万百计』地隐藏了它的存在——哈哈，其实没有这么夸张，它们是承认这个东西的存在并且提供官方支持的（&lt;a href="http://www.imagemagick.org/Usage/draw/#svg"&gt;在这里&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;在ImageMagick &lt;strong&gt;6.6.7-10&lt;/strong&gt;之后的版本中，MSVG总是缺省内置支持(&lt;code&gt;WITH_IMAGEMAGICK_SVG&lt;/code&gt;参数缺省打开)，即使是在&lt;code&gt;WITHOUT_X11&lt;/code&gt;状态下，编译过程也只是给出WARN级别的警告。&lt;/p&gt;

&lt;p&gt;而在此前（ 但晚于v6.3.3-5之后的）版本中，如果&lt;code&gt;WITHOUT_X11&lt;/code&gt;，那么编译时将不会内置支持SVG。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考：&lt;a href="https://www.freshports.org/graphics/ImageMagick/"&gt;https://www.freshports.org/graphics/ImageMagick/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;任何情况下，如果你只是想启用MSVG（以避开其它引擎的影响），那么你可以在input文件名上加上"msvg:"前缀（v6.3.4以后）。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -verbose 'msvg:your.svg'
Image: your.svg  
  Base filename: b2t_8-2.svg
  Format: MVG (Magick Vector Graphics)
  Class: DirectClass
  Geometry: 485x306+0+0
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以使用&lt;code&gt;-draw&lt;/code&gt;参数来开启一个MSVG的画板并操作它。例如（将这块画板作为源，转换成PNG格式输出）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# http://www.imagemagick.org/Usage/draw/#svg
&amp;gt; convert -size 10x6 xc:skyblue  -fill black \
          -draw 'color 6,3 point' -scale 100x60 draw_color_point.png
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=""&gt;内建模式及其开启&lt;/h2&gt;

&lt;p&gt;如果ImageMagick在安装时包含librsvg模块，那么就会启用内建模式（所以Build-in SVG也往往直接称为RSVG）。一旦包含这个模块，那么它的优先级比内置的MSVG要高。&lt;/p&gt;

&lt;p&gt;如果你是使用brew来安装的ImageMagick，那么你可以用：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; brew info imagemagick
...
Optional: fontconfig ✔, little-cms ✘, little-cms2 ✔, libwmf ✘, librsvg ✔ ...  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来查看当前环境是否能支持rsvg。如上，&lt;code&gt;librsvg&lt;/code&gt;已经安装了，那么就可以通过安装参数来开启它（或使用&lt;code&gt;brew reinstall&lt;/code&gt;重新安装）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 你可能需要先安装librsvg模块
#    - brew install librsvg
&amp;gt; brew install imagemagick --with-librsvg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不是使用brew，那么你可以使用如下命令来查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; convert -list configure | grep -Eoe '--with-rsvg(=[^\-]+)?'
--with-rsvg=no
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有rsvg的支持，那么你需要自己编译ImageMagick，相关的操作&lt;a href="http://www.imagemagick.org/script/advanced-unix-installation.php"&gt;在这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果你成功安装了rsvg支持，那么可以看到如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# build-in的delegate中包含了rsvg
&amp;gt; identify -version | grep --color rsvg
Delegates (built-in): bzlib cairo fontconfig freetype jng jpeg ltdl lzma png rsvg tiff xml zlib

# 或format中使用了rsvg来支持svg
&amp;gt; identify -list format | grep -i svg
convert -list format | grep -i svg  
     MSVG  SVG       rw+   ImageMagick's own SVG internal renderer
      SVG  SVG       rw+   Scalable Vector Graphics (RSVG 2.40.17)
     SVGZ  SVG       rw+   Compressed Scalable Vector Graphics (RSVG 2.40.17)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注1：一些资料中称需要使用&lt;code&gt;--use-rsvg&lt;/code&gt;参数在编译中开启rsvg支持，这可能是一个被放弃的、早期的构建参数。&lt;/p&gt;
  
  &lt;p&gt;注2：在brew中用的参数是&lt;code&gt;--with-librsvg&lt;/code&gt;，而实际上编译时使用的是&lt;code&gt;--with-rsvg&lt;/code&gt;参数。这个转换操作是在brew安装用的formula文件中完成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;委托模式的开启&lt;/h2&gt;

&lt;p&gt;通常情况下，ImageMagick会在内置的MSVG和内建模式（RSVG）之间选择一个；如果二者都没有，那么它会选择第三种，也就是委托模式。&lt;/p&gt;

&lt;p&gt;你总是可以通过如下命令查看ImageMagick委托（外部程序）来进行的图形转换，包括SVG：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; convert -list delegate | grep 'svg'
...
svg =&amp;gt;          "rsvg-convert' -o '%o' '%i"  
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：严格来说，前面说的内建模式事实上也是一种委托。只不过它是在编译时build-in的，所以在&lt;code&gt;--help&lt;/code&gt;参数显示的信息中就能直接看到，并且会影响&lt;code&gt;-format&lt;/code&gt;显示的格式支持；而在&lt;code&gt;-list delegate&lt;/code&gt; 所列举的委托关系中，却并不会出现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于只有MSVG和rsvg都不生效时才会开启委托模式，但高版本中ImageMagick中总是内置MSVG，所以是很难触发委托模式的。因此，如果你做这个尝试，那么你需要一个不内置MSVG的低版本ImageMagick，并且在编译中关闭&lt;code&gt;--with-rsvg&lt;/code&gt;选项。OK，这样你就可以看到ImageMagick调用了上述委托中的&lt;code&gt;rsvg-convert&lt;/code&gt;来进行转换。&lt;/p&gt;

&lt;p&gt;当然，也有例外，因为其实还是有一个后门来做这件事的，这就是所谓的内部委托。&lt;/p&gt;

&lt;h3 id=""&gt;内部委托&lt;/h3&gt;

&lt;p&gt;准确地说法：MSVG这个内部渲染器提供了一个『内部委托（special internal delegates）』。这种内部委托与上面的&lt;code&gt;rsvg-convert&lt;/code&gt;采用的是类似机制，但是通过&lt;code&gt;-list delegate&lt;/code&gt;命令是无法查看到的——你得打开配置文件自己来找：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 查看你的ImageMagick将读取哪些配置文件
&amp;gt; convert -debug all -list delegate 2&amp;gt;&amp;amp;1 | grep 'delegates.xml'
Searching for configure file: ...  
...
Path: /usr/local/Cellar/imagemagick/7.0.5-9/etc/ImageMagick-7/delegates.xml  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意前面有一个搜索优先顺序的列表（你可能用得上），不过这里我们只需要关心最后这个&lt;code&gt;Path&lt;/code&gt;就好了。打开这个文件，查找&lt;code&gt;svg:decode&lt;/code&gt;，将&lt;code&gt;stealth="True"&lt;/code&gt;删除掉。现在你就可以看到它了：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; convert -list delegate | grep -Ee 'svg(:decode)? ='
        svg =&amp;gt;          "rsvg-convert' -o '%o' '%i"
 svg:decode =&amp;gt;          "inkscape' '%s' --export-png='%s' --export-dpi='%s' --export-background='%s' --export-background-opacity='%s' &amp;gt; '%s' 2&amp;gt;&amp;amp;1"
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：内部委托与一般的（外部程序的）委托模式处理逻辑是一样的，只是在高版本的ImageMagick用&lt;code&gt;svg:decode&lt;/code&gt;替代了&lt;code&gt;svg&lt;/code&gt;这个入口而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是的，你应该已经注意到了，这个内部的委托指向了inkscape。你可以安装inkscape来支持这个委托。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; brew cask install xquartz inkscape
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=""&gt;接管内部委托&lt;/h3&gt;

&lt;p&gt;你也可以自己写个脚本来将操作转发到你的处理程序（类似于代理）。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;#!/bin/bash
DPI="${3##*=}"  
rsvg-convert --format=png --output="${2##*=}" --dpi-x="${DPI%%,*}" --dpi-y="${DPI##*,}" --background-color="${4##*=}" "$1"  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将这个脚本另存到搜索路径中，并命名为&lt;code&gt;inkscape&lt;/code&gt;，加上可执行权限。OK，你就看到&lt;code&gt;svg:decode&lt;/code&gt;的相关调用转发到你的脚本中，并交给rsvg-convert处理了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：如果内部委托调用出错（程序退出代码大于0），那么ImageMagick将再次调用MSVG来完成处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然，我们也可以把这个接管的脚本程序写得通用一点。比如将delegates.xml中的&lt;code&gt;svg:decode&lt;/code&gt;项修改到一个统一的模式（以后就可以不用改了，不过sv要注意其中的&lt;code&gt;YOUR_SCRIPT_NAME&lt;/code&gt;应该修改得与后面的脚本名一致）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;delegate decode="svg:decode" command="&amp;amp;quot;YOUR_SCRIPT_NAME&amp;amp;quot; &amp;amp;quot;%s&amp;amp;quot; &amp;amp;quot;%s&amp;amp;quot; &amp;amp;quot;%s&amp;amp;quot; &amp;amp;quot;%s&amp;amp;quot; &amp;amp;quot;%s&amp;amp;quot; &amp;amp;gt; &amp;amp;quot;%s&amp;amp;quot; 2&amp;amp;gt;&amp;amp;amp;1"/&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装自己的工具（下面以cairosvg这个工具为例，首先安装它）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# @see: http://cairosvg.org/
&amp;gt; pip3 install cairosvg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后写调用脚本（&lt;code&gt;YOUR_SCRIPT_NAME&lt;/code&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;#!/bin/bash

# in arguments:
#    inFile outFile dpi bgColor bgOpacity
DPIX="${3%%,*}"  # format - xRes,yRes  
BGCOLOR="$4" # format - string, #xxxxxx, or rgb(r%,g%,b%)  
cairosvg -f png -o "$2" -d "$DPIX" "$1"  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后将这个脚本另存、更名、更改可执行权限。&lt;/p&gt;

&lt;p&gt;在你使用identify、convert等等工具处理svg时，都将调用上述脚本。所以，现在你可以随意用新的转换工具来替换MSVG了。&lt;/p&gt;

&lt;p&gt;我的开源项目&lt;a href="https://github.com/aimingoo/svg-provider"&gt;svg-provider&lt;/a&gt;是一个较完整的实现，其主要是在参数的处理上面进行了优化，并且可以适配更多的转换工具。&lt;/p&gt;</content:encoded></item><item><title>Kindle电子书中该用多大的图片</title><description>&lt;blockquote&gt;
  &lt;p&gt;注1：本文所涉及的工具，可以采用如下方法安装：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 含identify,convert,mogrify,pdfinfo,pdftoppm等
&amp;gt; brew install ghostscript imagemagick cpdf poppler
# 含pdfcrop等
&amp;gt; brew cask install xquartz mactex inkscape
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。&lt;/p&gt;

&lt;p&gt;在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。&lt;/p&gt;

&lt;p&gt;你最好的选择是：使用一个阅读器不会对它进行缩放的、&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1726/</link><guid isPermaLink="false">5655d162-8a13-48e2-8125-387c794db87a</guid><category>电子书</category><category>Kindle</category><dc:creator>aimingoo</dc:creator><pubDate>Sat, 03 Jun 2017 10:54:54 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;注1：本文所涉及的工具，可以采用如下方法安装：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 含identify,convert,mogrify,pdfinfo,pdftoppm等
&amp;gt; brew install ghostscript imagemagick cpdf poppler
# 含pdfcrop等
&amp;gt; brew cask install xquartz mactex inkscape
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。&lt;/p&gt;

&lt;p&gt;在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。&lt;/p&gt;

&lt;p&gt;你最好的选择是：使用一个阅读器不会对它进行缩放的、确定大小的图片。&lt;/p&gt;

&lt;p&gt;那么这样一张图片应该是多大呢？&lt;/p&gt;

&lt;h2 id=""&gt;阅读器有多大，图片就有多大&lt;/h2&gt;

&lt;p&gt;答案如标题所说。只要你确切知道阅读器（的可阅读区）的大小，那么制作相同大小的图片就好了。不过对于Kindle——当然也可能包括别的电子书阅读器来说，这个大小要打个折扣。这是因为Kindle设定图片最大宽高度不得超过大约80%的可阅读区。一旦超过这个大小——该值其实是一个不确定的魔法数值，这在后面会更讲到——那么阅读器就会主动缩小这个图片。&lt;/p&gt;

&lt;p&gt;Kindle发行过的一些阅读器的规格主要包括（相关数据&lt;a href="http://socialcompare.com/en/comparison/amazon-kindle-product-line-comparison"&gt;在这里&lt;/a&gt;，最新近的一些&lt;a href="http://www.toptenreviews.com/mobile/ebook-readers/best-kindle-comparisons/"&gt;在这里&lt;/a&gt;）：&lt;/p&gt;

&lt;style type="text/css"&gt;  
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-yw4l{vertical-align:top}
&lt;/style&gt;  

&lt;table class="tg"&gt;  
  &lt;tr&gt;
    &lt;th class="tg-yw4l"&gt;分辨率&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;类型&lt;/th&gt;
    &lt;th class="tg-yw4l"&gt;Pixel Per Inch&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;1024x600&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;ISP LCD&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;169/171 PPI&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;1280x800&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;ISP LCD&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;149/189/216/252 PPI&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;1920x1200&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;ISP LCD&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;254/323 PPI&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;2560x1600&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;ISP LCD&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;339 PPI&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;800x600&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;E Ink&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;167 PPI&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;1024x758&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;E Ink&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;212 PPI&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;1200x824&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;E Ink&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;150 PPI&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td class="tg-yw4l"&gt;1448x1072&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;E Ink&lt;/td&gt;
    &lt;td class="tg-yw4l"&gt;300 PPI&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;不仅如此，Kindle还发行过一系列平板的版本（当然使用的是LCD屏而不是电子墨水屏），这些屏幕的规格就更复杂了，例如官方公布的一些规格（&lt;a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/specifications/01-device-and-feature-specifications"&gt;在这里&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;综合上面的数据，从实用性的角度来说，我们应该制作宽度小于600*80%左右大小的图片。这条规则在大多数设备上都是适用的——关于这个问题其实是有过广泛的讨论的（例如&lt;a href="https://www.epubble.com/kindle-maximum-image-size/"&gt;在这里&lt;/a&gt;，以及amazon开发者信息&lt;a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/app-development/01--screen-layout-and-resolution"&gt;在这里&lt;/a&gt;）。但这个值不但与设备有关，甚至还与不同的Kindle版本有关，以至于有人发布出测试用的电子书，用来确定在不同设备上的适配图片大小（&lt;a href="https://www.epubble.com/wp-content/download/KindleMaximumImageSize.prc"&gt;Kindle Maximum Image Size (PRC)&lt;/a&gt; ）。&lt;/p&gt;

&lt;p&gt;好吧，总之我们是只看结论的对不。那么，这个结论如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议你将图片的大小控制在&lt;code&gt;520*622px&lt;/code&gt;以内。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说，图片宽度在520px以内（&lt;code&gt;640*0.8125&lt;/code&gt; or &lt;code&gt;600*.87&lt;/code&gt;）。&lt;/p&gt;

&lt;h2 id=""&gt;如何做这样大小的图片&lt;/h2&gt;

&lt;p&gt;下面我们来讲『如何做』。&lt;/p&gt;

&lt;h3 id=""&gt;什么是『这样大小』&lt;/h3&gt;

&lt;p&gt;首先确定一下『这样大小』到底是怎样大。&lt;/p&gt;

&lt;p&gt;因为我们所谓520px的图片，其实要从像素点换算成印刷用的厘米(cm)、英寸(in)或磅值(pt)，这些看起来麻烦的东西，通常是平面设计师的基本功。&lt;/p&gt;

&lt;p&gt;在显示器上的所谓520px，实际含义是『在一个72ppi的设备上显示520pixel』（注3）。这里的PPI是『像素/英寸(Pixel Per Inch)』，这通常用在显示输出类的设备上；更经常的，你可能看到的是用Dots来表示Pixel，就是DPI了（注4）。一般情况下，这两种说法并不需要区分，都称作分辨率(Resolution ratio)、质量/精度/密度(quality/density)——具体到不同场合则是打印分辨率、显示分辨率、图片精度等等，&lt;a href="http://www.uigreat.com/article/131"&gt;参见这里&lt;/a&gt;）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注3: 对于PPI，Windows系统默认为96， Mac OS系统默认PPI 为72。在使用Macbook Pro的Retina屏时，它的默认值是110。&lt;/p&gt;
  
  &lt;p&gt;注4: 注意，我们说宽520px时实际上是在讲一张图片的"Pixel Dimensions（点阵面积）"中x方向的大小，而72dpi/ppi却是指获得（例如扫描设备）或输出（例如显示设备）这个点阵图时的精度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们前面列出Kindel的设备参数时，设备的PPI是很复杂的，从149到339有非常多种；而它们显示具体图像的分辨率，也有800x600 .. 2560x1600等非常多种模式。不考虑其具体映射和实现的细节的话，你可以认为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们使用300DPI的图片，在多数设备上总是可行的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么：一张&lt;code&gt;520x320px&lt;/code&gt;大小的&lt;code&gt;300dpi&lt;/code&gt;的图片，到底是怎样大小呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;高度320px是上面所说到的622px的一半略多。这是因为我们在电子书上通常不会把一张图做到全屏大小，而使用以半屏高为上限的图片有利于书籍的自动排版。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=""&gt;面积计算&lt;/h3&gt;

&lt;p&gt;想知道这个大小，那么只需要在图形制作软件中新建一张图片，设置像素大小（即是Pixel Dimensions）为520x320px，然后设置分辨率为300DPI，就一切OK了——通常这种情况下我们不需要去手工计算。然而如果你在PowerPoint或Keynote里去做类似的事情，就会发现：.ppt中设置页面是使用厘米(cm)，而.key中却是使用磅（pt）。我们的难题之一，便是要做这个转换（以宽520px为例）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;520/300*2.54 = 4.4026（厘米）
&lt;ul&gt;&lt;li&gt;1英寸 = 2.54厘米&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;或者为了避免你总是手工计算，那么查看上面创建的图片的信息也可以（设图片名为test.png）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：identify是ImageMagick中的一个工具，在使用&lt;code&gt;brew install imagemagick&lt;/code&gt;安装后会同时得到这个命令行工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 118.11x118.11
  Print size: 4.40268 x 2.70934
  Units: PixelsPerCentimeter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意identify对图片来说缺省单位是厘米（Centimeter），而不是习惯上PPI/DPI中所说的英寸（Inch），所以Resolution显示是118.11（DPCM，Dots Per Centimeter）。如果你想要显示为DPI，那么应该这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -units PixelsPerInch -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 300x300
  Print size: 1.73333 x 1.06667
  Units: PixelsPerInch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="pptkeynote"&gt;在ppt或keynote上实作&lt;/h2&gt;

&lt;p&gt;我们具体使用ppt/key的时候，其实会比上面的520x320px要略大一点，然后使用参考线来辅助作图。这是为了在ppt/key中具体画图时边界上留一点余量，便于操作。具体来说，我推荐的是使用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在.ppt中设置页面大小为&lt;code&gt;4.8x3.5&lt;/code&gt;cm，或&lt;/li&gt;
&lt;li&gt;在.key中设置页面大小为&lt;code&gt;136x99&lt;/code&gt;pt&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来在PPT中设置两三条辅助线（以PPT为例，你可以下载这个模板&lt;a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.ppt"&gt;PPT格式&lt;/a&gt;或&lt;a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.key"&gt;Keynote格式&lt;/a&gt;）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;右、左侧2.14cm各一条&lt;/li&gt;
&lt;li&gt;右侧2.26cm一条&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/06/standard_image_templet_520.png" alt="standard_image_templet_520"&gt;&lt;/p&gt;

&lt;p&gt;我们通常作图时让内容保持在正中间的&lt;code&gt;2.14*2&lt;/code&gt;的范围内即可，当右侧使用到极限时会是&lt;code&gt;2.14+2.26cm&lt;/code&gt;，亦即是全宽520px。同时，如果是4磅大小的文字，单行可以容纳30~31个（如图）。我建议采用4磅文字，其下限是3.5磅。&lt;/p&gt;

&lt;p&gt;最后，当你在上面的页面上完成图、表之后，如果你使用PPT，那么可以直接在图形上鼠标右键，选『另存为图片』，然后选PDF（注4）；如果你使用Keynote，请在文件菜单中选『导出』，仍然也是选PDF。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;强烈说明：注意这里要用PDF！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来，你在Macbook中的『预览（Preview）』工具中打开上述PDF文件，再选导出到PNG，并设置分辨率为300 dpi。即可。&lt;/p&gt;

&lt;p&gt;我们验证一下这样得到的一个.png的信息（注5）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 118.11x118.11  ## 如果使用-units PixelsPerInch，则这里为300DPI
  Print size: 4.51274x1.61714
  Units: PixelsPerCentimeter
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注4: 我们后面将使用在PPT中选中图形导出的这个PDF（命名为ppt533.pdf），以及转换后的图片（ppt533.png）。稍后我们会讲述Keynote中的处理方法。此外，如果你在PPT绘制了很多东西，那么建议你先建个组(Group)再导出它们。&lt;/p&gt;
  
  &lt;p&gt;注5: 你会注意到这个宽度不是预期的520px。这是因为PPT选中图形导出时会默认添加边框，所以如果你只使用模板中间的安全部分，那么上述方法总是安全的；否则你需要使用crop工具去切掉周边的空白区。关于这个部分的内容，我们在下面还会讲到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="pdfpng"&gt;理解PDF与PNG文件大小之间的关系&lt;/h3&gt;

&lt;p&gt;为了讨论这个问题，我们再检查一下上面生成的PDF文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -verbose ./ppt533.pdf | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 128x46+0+0
  Resolution: 72x72
  Print size: 1.77778x0.638889
  Units: Undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会注意到PDF文件中&lt;code&gt;Units&lt;/code&gt;值是没有的。这是PDF格式特殊的地方，事实上在它的文件格式中并没有包含Resolution、Print size和Units的信息——上面由identify得到的信息是计算出来的，而不是文件中的元数据信息。更具体地说，PDF是约定了默认使用72x72DPI的分辨率（所以Identify也直接在默认时使用了Inch作为单位，与图片的默认值不同），而且它是使用Points（磅值/点）来表明大小。那么显而易见的，上述的Print Size是简单地通过&lt;code&gt;128/72&lt;/code&gt;就可以得来了——PDF默认采用72x72的DPI原因，也正在于磅值与英寸的换算关系就是&lt;code&gt;72:1&lt;/code&gt;（关于这一点，请参见&lt;a href="http://www.cnblogs.com/stronghorse/p/4913346.html"&gt;老马的文章&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;所以现在你可以得到两个与大小相关的信息，一个是宽高信息(Pts)，也称为页面大小(Page Size)，另一个是可推算出来的打印面积(inch)。而在从PDF转换到PNG图片的过程中，通常就以这个转换后的打印面积来作为图片物理大小。&lt;/p&gt;

&lt;p&gt;接下来我们来逆推一下一张300DPI的PNG图片该是怎样的。如果这张图片是如上的1.77778宽度，并且由于DPI设定是300，那么显然图片在x方向的点阵大小（pixels）应该就是&lt;code&gt;300*1.77778=533px&lt;/code&gt;。具体来看上面这张通过『预览』工具导出的&lt;code&gt;ppt533.png&lt;/code&gt;，它的信息就是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -units PixelsPerInch -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 300x300
  Print size: 1.77667x0.636667
  Units: PixelsPerInch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说：在转换过程中，通常是保证&lt;code&gt;Print size&lt;/code&gt;大小不变。&lt;/p&gt;

&lt;h3 id="ghostscriptdpi"&gt;在GhostScript中对DPI的一点不同理解&lt;/h3&gt;

&lt;p&gt;如果你不想直接使用『预览』工具来导出，那么你可以为它建立一个automator任务或服务——这样就可以在命令行上使用了。或者，你也可以尝试使用GhostScript（也就是gs）这个命令行工具。&lt;/p&gt;

&lt;p&gt;但是如果你使用GhostScript来将PDF转换成PNG，那么缺省情况下它是将Points直接对应地转换为Pixels的——也就是将PDF中的一个打印点，转换为图片中的一个像素点。因此假使你不使用设置分辨率的&lt;code&gt;-r&lt;/code&gt;参数，那么你就将直接转换得到一个&lt;code&gt;128x46 pixels, 72DPI&lt;/code&gt;的图片。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# (下面这个结果显然不是你想要的)
&amp;gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -sOutputFile=128px.png ppt533.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更进一步，如果使用&lt;code&gt;-r 300&lt;/code&gt;来指定300DPI输出，那么图片要有533 px的宽度（这个我们上面已经计算过了），而原始的PDF只有128 pts的宽度。所以这时，你将会得到一个低质量的、从128放大到533的图片。&lt;/p&gt;

&lt;p&gt;如果你需要用gs来转换pdf到png，那么你应该先放大这个pdf到合适的宽高大小，然后再输出。下面是其中一种可能的方案：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 先放大300/72=4.1667倍
#    - 也可以使用另一个开源工具pdfScale
#    - 目的是使pts与我们要得到的图片pixels点数对应，以确保图片质量足够
&amp;gt; cpdf -scale-page "4.1667 4.1667" -scale-to-fit-scale 4.1667 -o 300dpi.pdf ppt533.pdf
# 再转换得到300DPI的图片
&amp;gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -r300 -sOutputFile=300dpi.png 300dpi.pdf
# 再reszie图片
#    - 转换成png时Page Size大小将保持不变，因此需要按72/300为比例换回去
&amp;gt; convert 300dpi.png -resize 24% ppt533.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们再来看看这张图片：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; identify -units PixelsPerInch -verbose ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x192+0+0
  Resolution: 300x300
  Print size: 1.77667x0.64
  Units: PixelsPerInch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然这个过程是能得到符合我们要求的图片，但的确过于复杂。我们后面将介绍一些其它不使用GhostScript的方法。&lt;/p&gt;

&lt;h2 id="pdf"&gt;使用导出PDF文件的方法来得到图片的一些问题&lt;/h2&gt;

&lt;h3 id="1pdf"&gt;1) 成批导出与转换PDF文件&lt;/h3&gt;

&lt;p&gt;如果总是在PowerPoint中将图形对象选中然后右键导出成PDF，那么在成批处理时就会比较繁琐；另外，在Keynote中根本就没有这个操作。所以事实上我们一般还是会将整个的PPT/Keynote文件另存、导出为.PDF文件。这样的文件称为多页PDF——很显然地，因为我们见到的大多数PDF文件都是多页的，并且它们的页面大小是一致的。&lt;/p&gt;

&lt;p&gt;然而事实上我们要处理的每张PNG图片都可能大小不同，因为在PPT/Keynote中实际作图的有效区并不一样大。你可以选择将PDF从多页转换成一批单页，或者寻找能直接处理多页PDF的工具。——不幸的是，一些情况下后面这类工具并不太容易得到。&lt;/p&gt;

&lt;p&gt;所以如果你真的需要先转换成单页PDF，那么我建议你使用pdfseparate这个工具，它包含在poppler这个工具包中。用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 第二个参数是文件名模板，必须包含'%d'来作页码的占位符
#    - 目标文件的目录必须先创建(例如本例中的extract)
&amp;gt; mkdir ./extract
&amp;gt; pdfseparate your.pdf './extract/page%d.pdf'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="2"&gt;2) 要切掉空白&lt;/h3&gt;

&lt;p&gt;在转换到图片之前，我们还得先留意一下这个.pdf外围的空白区。&lt;/p&gt;

&lt;p&gt;在上例中，如果你在Keynote中导出.pdf，或者在PowerPoint中导出页面（而不是选中图形导出），那么你将导出的是整个页。我们上面说过，为了制作方便，我们的整个页其实要略大一些，而只有参考线中间部分的图形是在电子书中有效的。&lt;/p&gt;

&lt;p&gt;那么我们其实需要的是自动切掉图形外围的空白区(trim/crop)——在不同的软件中，可能是这两种功能之一。你可以选择处理最终生成的.png图片，这可以仍然使用上述ImageMagick套件中的convert（你安装之后在命令行中就有了），也可以早先做一步，对.pdf进行trim/crop操作。&lt;/p&gt;

&lt;p&gt;这可以使用一个非常著名（而且名实相符）的软件，叫pdfcrop。它是perl脚本，可以你可以直接从官方下载（&lt;a href="https://sourceforge.net/projects/pdfcrop/files/"&gt;例如这里&lt;/a&gt;），或者安装一个TeX套件包内含（使用&lt;code&gt;brew cask install mactex&lt;/code&gt;）。使用起来也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# Usage: pdfcrop &amp;lt;input[.pdf]&amp;gt; [output file]
&amp;gt; pdfcrop xxx-300dpi.pdf croped.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果省略output参数，则它以input文件名自动生成&lt;code&gt;-crop.pdf&lt;/code&gt;后缀的文件。&lt;/p&gt;

&lt;p&gt;另一个相对来说也很可靠的工具叫pdfCropMargins，它可选的参数也更多。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# pdfCropMargins可选使用Ghostscript或pdftoppm作为将pdf渲染为图片的工具
#  - 参数-gsr表明使用Ghostscript（缺省是pdftoppm）, 参数-gsp表明gs可执行文件的路径
#  - 参数-p/-p4来指定relative original margin模式的边距
#   * 可以用-a/-a4指定边距的absolute offset值
#   * 参数-ap/-ap4是在剪切前计算最终页面大小时使用的(p是指preCrop)
#   * 参数-m/-mp是用在uniform模式下指定边距，并隐式地打开该模式(或显式使用-u参数)
&amp;gt; pdf-crop-margins -p 0 -gsr -gsp /usr/local/bin/gs -o croped.pdf your.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pdfCropMargins与pdfcrop都有resolution参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在pdfcrop中是&lt;code&gt;--resolution&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在pdfCropMargins中则是&lt;code&gt;-x/-y&lt;/code&gt;，或&lt;code&gt;--xRes/--yRes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个参数是用在将PDF渲染成图片时提高图片精度的。因为这两个工具实际上都是先将PDF渲染成图片，然后根据图片来查找margins的，所以提高这一精度就意味着查找margins更准确。但这个参数并不会影响转换后的PDF的质量。&lt;/p&gt;

&lt;p&gt;其它：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在pdfcrop中建议打开&lt;code&gt;--hires&lt;/code&gt;以提高crop的质量，这种情况下margin计算更精确
&lt;ul&gt;&lt;li&gt;在pdfCropMargins中的参数&lt;code&gt;-ap/-ap4&lt;/code&gt;正好相反，较不精确但速度更快&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用较低的resolution值速度更快，这与内部将pdf转为图片时的速度效率有关
&lt;ul&gt;&lt;li&gt;pdfcrop缺省的resolution值为72dpi，而pdfCropMargins缺省为150dpi&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在pdfCropMargins中缺省使用的pdftoppm会比gs引擎要慢一点&lt;/li&gt;
&lt;li&gt;在pdfcrop中指定TeX引擎为&lt;code&gt;--xetex&lt;/code&gt;时，crop运算的效果常常会出错&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="3pdfpng"&gt;3) PDF转换到PNG图片时的工具选择&lt;/h3&gt;

&lt;p&gt;无论PDF是否经过crop，你最终都只是想得到图片，所以这最后一步尤其重要。&lt;/p&gt;

&lt;p&gt;切记要给转换软件指定300dpi的输出精度——如上所述，我们是按这个精度来设计的图片大小。除了『预览』这个软件之外，能指定转换精度的软件看起来不少，但大多数并不合用（注意gs是可用的，但并不方便，这在之前我们已经专门讲过了）。例如下面这几个：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 使用inkscape
#   - 只能处理单页pdf，可能会因字体不匹配而出现字体异常；效果好于gs，且能将dpi置为300
&amp;gt; inkscape --without-gui --export-dpi=300 --export-png='300dpi.png' croped-p1.pdf

# 使用ImageMagick中的convert
#   - convert的density用于指定源pdf为300dpi, 而输出的png其实总是72dpi
#   - 只能处理单页pdf，但视觉效果好于gs(也好于gs的DEVICE=pnggray)
&amp;gt; convert -density 300 croped-p1.pdf -background white -flatten 'error-dpi.png'

# 使用pdf2png
#    - Github: https://github.com/kaorukobo/pdf2png-mac
#    - 能逐页处理，但输出png的精度受xcode中的组件影响(缺省是144dpi)
#    - 参数--dpi是用于指定源pdf的dpi值的
&amp;gt; pdf2png --dpi 300 --page 1 --output '144dpi.png' croped.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上所有这类软件都是将源PDF理解为72dpi，所以针对源来指定的Resolution值其实是用于建立一个缩放工厂（scaleFactor），以便得到等同于指定DPI大小的图像。而不同的软件的区别仅在于是否能在输出PNG时，有效的指定png图片的dpi——例如pdf2png是基于xcode的NSMakeRect()，而该组件默认精度在retina screens上就是144dpi。&lt;/p&gt;

&lt;p&gt;所以请仔细review这个过程，其实完全等同于『在GhostScript中对DPI的一点不同理解』小节中所讲述的：1. 先放大PDF；2. 渲染成PNG到指定精度；3. 缩小PNG到指定大小。&lt;/p&gt;

&lt;h3 id="4"&gt;4) 一步到位&lt;/h3&gt;

&lt;p&gt;如果你希望一步到位地解决上述问题，那么我目前只有一个工具推荐：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：nconvert是&lt;strong&gt;xnview&lt;/strong&gt;提供的一个非商用免费工具，&lt;a href="http://www.xnview.com/en/nconvert/"&gt;下载在这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 用ncovert将croped.pdf转换到png
&amp;gt; nconvert -xall -dpi 300 -out png -o pic croped.pdf 1&amp;gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
Conversion of croped.pdf into pic-1.png OK  
Conversion of croped.pdf into pic-2.png OK  
...

# 或者不对original.pdf做crop操作，而是直接在nconvert中转换并autocrop图像
#    - autocrop参数格式为"tol r g b"，其中tol是容错值，rgb为crop掉的颜色
&amp;gt; nconvert -xall -dpi 300 -out png -o pic -autocrop 0 255 255 255 original.pdf 1&amp;gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，本文中的模板所导出的PDF(&lt;a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.pdf"&gt;在这里&lt;/a&gt;)转换成png所采用的方法就是如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 在PowerPoint/Keynote中将ppt导出成.pdf，然后
#    - nconvert是从0页开始对pdf计数的
&amp;gt; nconvert -page 0 -dpi 300 -out png -autocrop 0 255 255 255 standard_image_templet_520.pdf 1&amp;gt;/dev/null
Conversion of standard_image_templet_520.pdf into standard_image_templet_520.png OK

# 查看png文件的信息(现在就真的是520px宽+300DPI了)
&amp;gt; identify -units PixelsPerInch -verbose standard_image_templet_520.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 520x306+0+0
  Resolution: 300x300
  Print size: 1.73333x1.02
  Units: PixelsPerInch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后需要补充一点：就效果来说，基于图像autocrop与pdfcrop并没有太大的差别——反正我是分不出来。另外，你也可能想尝试使用imagemagick中的trim操作来替代autocrop：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 使用nconvert但不autocrop
&amp;gt; nconvert -xall -dpi 300 -out png -o pic original.pdf 1&amp;gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
...

# 使用imagemagick中的mogrify工具, -fuzz 0%与autocrop中的tol参数类似
&amp;gt; find . -name 'pic-*.png' | xargs -n1 mogrify -fuzz 0% -trim +repage
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>手记6：改造Gitment</title><description>&lt;blockquote&gt;
  &lt;p&gt;本文所述的修改请参考我Fork的Gitment项目：&lt;a href="https://github.com/aimingoo/gitment"&gt;Giment at aimingoo's project space&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来我们要大力修改Gitment，打造一个『好用那么一点点儿』的博客评论。&lt;/p&gt;

&lt;h2 id="11gitment"&gt;11. 改造Gitment&lt;/h2&gt;

&lt;p&gt;折腾到现在，我们有了一个在Github pages上的博客，以及一个用来写本地博客的Ghost，以及一些相关的工具，例如&lt;code&gt;makesite.sh&lt;/code&gt;（&lt;a href="https://github.com/aimingoo/ghost-utils"&gt;在这里&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;最后，我们还有了一个第三方提供的支持PHP+HTTPs的空间，这个空间只用来放Gitment的服务端，并且这个服务器事实上也只做一下API的CORS转发而已。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：你可能已经留意到我并没有告诉大家『到底哪个免费主页空间支持PHP+HTTPS』啊。是的，我刻意隐藏了这个信息，以免文章公开后导致滥用。我最终使用的这个主页空间……老实说，是相当相当不错的了，能给的人家都给了。所以真不忍心被那些挂马的搞死。所以能藏着就藏着吧，如果你想要申请它的话，你直接在我的网站的源码中去找找就好了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以接下来，我开始改造Gitment，再一次强调，Gitment真正是个相当NB的项目。我fork了一个版本出来，修改版的在这里：&lt;a href="https://github.com/aimingoo/gitment"&gt;Giment updates&lt;/a&gt;&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1725/</link><guid isPermaLink="false">eaab0e82-64c5-4cbb-a31d-64ae617b936b</guid><category>博客</category><category>Gitment</category><category>Javascript</category><category>OpenSource Project</category><category>Github</category><category>前端开发</category><dc:creator>aimingoo</dc:creator><pubDate>Wed, 31 May 2017 16:46:14 GMT</pubDate><content:encoded>&lt;blockquote&gt;
  &lt;p&gt;本文所述的修改请参考我Fork的Gitment项目：&lt;a href="https://github.com/aimingoo/gitment"&gt;Giment at aimingoo's project space&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来我们要大力修改Gitment，打造一个『好用那么一点点儿』的博客评论。&lt;/p&gt;

&lt;h2 id="11gitment"&gt;11. 改造Gitment&lt;/h2&gt;

&lt;p&gt;折腾到现在，我们有了一个在Github pages上的博客，以及一个用来写本地博客的Ghost，以及一些相关的工具，例如&lt;code&gt;makesite.sh&lt;/code&gt;（&lt;a href="https://github.com/aimingoo/ghost-utils"&gt;在这里&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;最后，我们还有了一个第三方提供的支持PHP+HTTPs的空间，这个空间只用来放Gitment的服务端，并且这个服务器事实上也只做一下API的CORS转发而已。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：你可能已经留意到我并没有告诉大家『到底哪个免费主页空间支持PHP+HTTPS』啊。是的，我刻意隐藏了这个信息，以免文章公开后导致滥用。我最终使用的这个主页空间……老实说，是相当相当不错的了，能给的人家都给了。所以真不忍心被那些挂马的搞死。所以能藏着就藏着吧，如果你想要申请它的话，你直接在我的网站的源码中去找找就好了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以接下来，我开始改造Gitment，再一次强调，Gitment真正是个相当NB的项目。我fork了一个版本出来，修改版的在这里：&lt;a href="https://github.com/aimingoo/gitment"&gt;Giment updates by aimingoo&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="111httphttpsgithubpages"&gt;11.1 更有效地支持HTTP/HTTPS的Github Pages&lt;/h3&gt;

&lt;p&gt;我们前面说过Github pages也分别支持HTTP和HTTPS两种协议，如果你有幸得到一个HTTP的Github pages site——真的很有幸了，得是以前创建的仓库，新仓库已经没有这个选择了——那么，你仍然可以将intersect（&lt;a href="https://github.com/aimingoo/intersect"&gt;在这里&lt;/a&gt;）部署在一个仅支持HTTP的Web站点上。&lt;/p&gt;

&lt;p&gt;也就是说，只能选择Github pages和intersect同时支持HTTPS，或者反过来选择同时不支持。有趣的是，在Github pages使用HTTP的情况下，Github&lt;strong&gt;同时&lt;/strong&gt;也允许访问者通过HTTPS协议来访问你的主页。这样一来就带来了一个问题：在你的Github oAuth Application后台配置中，你只能设置一个callback地址。&lt;/p&gt;

&lt;p&gt;所以我在Gitment中加了一个名为&lt;code&gt;force_redirect_protocol&lt;/code&gt;的选择，它会在调用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href="https://github.com/login/oauth/authorize"&gt;https://github.com/login/oauth/authorize&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;时强制redirect_uri参数使用与Github oAuth Application后台配置一致的值，这样才能在HTTPS/HTTP网站上同时通过authorize验证，并且最后总是使用redirect_uri所设置的协议下的地址。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// Update (Getment Proj)/src/gitment.js

// Github setting of 'Authorization callback URL' in your OAuth application
const force_redirect_protocol = 'https'  
...

class Gitment {  
  ...
  get loginLink() {
    const oauthUri = 'https://github.com/login/oauth/authorize'
    const redirect_uri = this.oauth.redirect_uri || window.location.href.replace(/^https?/i, force_redirect_protocol);
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="112gitmentintersect"&gt;11.2 使Gitment支持intersect&lt;/h3&gt;

&lt;p&gt;intersect这个PHP项目（&lt;a href="https://github.com/aimingoo/intersect"&gt;在这里&lt;/a&gt;）并没有完全地实现API Geteway特性。比如说，当它转发一个POST请求时，如果你需要添加新的数据到Request，那么就需要根据POST data的不同类型（Content-Type）来决定如何修改：在JSON中添加一个字段，或在不同的encode data中添加一个数据等等；并且还要正确的修改Content-Length。&lt;/p&gt;

&lt;p&gt;所以考虑到简单，intersect只支持在GET请求中，或在使用form-urlencoded协议的POST请求中添加数据。例如我们要追加client_secret这个参数并传送到后端，那么就该选用POST协议。&lt;/p&gt;

&lt;p&gt;考虑到Gitment实现XHR请求时的特殊性（它专门实现了一个ajaxFactory），我在修改Gitment项目时更要求：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果使用POST方法，并强制要求使用form-urlencoded协议，那么应该在&lt;code&gt;http.post()&lt;/code&gt;方法中传入字符串格式的data，而不能传入对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;接下来的实现就比较简单了（修改utils.js中的Ajax接口）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// Update (Getment Proj)/src/utils.js, es6 syntax

function ajaxFactory(method) {  
  ...
  // 在accept头中加上form-urlencoded支持
  req.setRequestHeader('Accept', '..., application/x-www-form-urlencoded')

  // 在Response数据的解码中支持form-urlencoded
  req.addEventListener('load', () =&amp;gt; {
    ...
    if (/urlencoded/.test(contentType)) {
       data = req.responseText ? Query.parse(res) : {}
       ...

  // 强制Requestr的POST协议对string data使用form-urlencoded
  if (method !== 'GET' &amp;amp;&amp;amp; method !== 'DELETE') {
    if (isString(data)) {
      body = data
      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步（修改Gitment.js）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// Update (Getment Proj)/src/gitment.js, es6 syntax

class Gitment {  
  constructor(options = {}) {
    ...
    const { client_id, client_secret, proxy_gateway } = this.oauth

    ...
    var login = !proxy_gateway
      ? http.post('https://gh-oauth.imsun.net', {code, client_id, client_secret}, '')
      : http.post('/login/oauth/access_token', `code=${code}&amp;amp;client_id=${client_id}`, proxy_gateway);

    login.then(data =&amp;gt; {
      this.accessToken = data.access_token
      ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三步（Gitment创建时Options）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// 现在在Gitment创建时的Options中就可以使用proxy_gateway选项了
//    - 保持了与旧的client_secert的兼容，二选一配置即可
const gitment = new Gitment({  
  id: 'Your page ID', // optional
  owner: 'Your GitHub ID',
  repo: 'The repo to store comments',
  oauth: {
    client_id: 'Your client ID',
    proxy_gateway: 'https://your_intersect_gateway'
    // client_secret: 'Your client secret, either this or proxy_gateway',
  },
  // ...
  // For more available options, check out the documentation below
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="113"&gt;11.3 多语言支持&lt;/h3&gt;

&lt;p&gt;Gitment的作者没有提供多语言支持是觉得『不必要』，因为Github的用户要是这几个单词也不认得大概就只能回家卖烤红薯了。但我的问题在于，我打算做一个多人博客，所以博客的读者还真有不少与Github无关。&lt;/p&gt;

&lt;p&gt;所以，我得需要一个多语言支持。&lt;/p&gt;

&lt;p&gt;简单的做法，就是写一个这样的translator：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// save as (Getment Proj)/src/translator.js
export function english(Text) {  
    return Text;
}

export function chinese(Text) {  
    return ({
        'Issue Page': '所有评论',
        'Initialize Comments': '初始化本文的评论页',
        ...
    }[Text]||Text);
}

export default english;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用的都是ES6的语法。这几个简单的export说明当前模块导出了&lt;code&gt;english/chinese&lt;/code&gt;等等名字，是用来作为提供多语言支持的翻译函数——在不同语言的函数中添加对照表来支持更多的内容。&lt;/p&gt;

&lt;p&gt;使用的时候也挺简单的，在Gitment的&lt;code&gt;src/theme/default.js&lt;/code&gt;模块中将它装载进来：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// 注：如果使用英文(不翻译)，那么以下两种导入方法是等效的
//    import { english as $ } from '../translator'
//  import $ from '../translator'
import { chinese as $ } from '../translator'  
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在需要多语言的地方使用下面的代码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// 例如，原始代码
//    issueLink.innerText = 'Issue Page'
// 改成：
issueLink.innerText = $('Issue Page')  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一处处地找到，改完就Ok啦。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：Gitment使用了ES6的语法，所以有些地方是用ES6的模板字符串的，这些地方要使用类似${$('english text')} 这样的方法来转换。&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title>博客迁移手记之快速导航</title><description>&lt;p&gt;本来没想把《博客迁移手记》写得这么长这么多，所以写了这么久之后再来看，博客的标题感觉就很Low了。&lt;/p&gt;

&lt;p&gt;于是决定给这一组《博客迁移手记（1~n）》写个导航，也算整理一下思路。&lt;/p&gt;

&lt;h2 id=""&gt;快速导航&lt;/h2&gt;

&lt;p&gt;博客迁移手记（一）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用BlogToWordpress迁移你的博客&lt;/li&gt;
&lt;li&gt;使用本地博客Ghost的快速指南与导入工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（二）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从本地博客到Github Pages的最佳指南&lt;/li&gt;
&lt;li&gt;makesite.sh使用手册&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（三）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以kaldorei为例详解Ghost Theme的定制&lt;/li&gt;
&lt;li&gt;Ghost中文章置顶的实现方法&lt;/li&gt;
&lt;li&gt;如何最大程度地静态化Ghost博客&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（四）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gitment大坑：谈谈secret泄露的前因后果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（五）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何获得一个支持HTTPS的免费空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（六）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用intersect来做Gitment的API网关&lt;/li&gt;
&lt;li&gt;Gitment的一些Bug修复与补强&lt;/li&gt;
&lt;li&gt;Gitment的简单多语言支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=""&gt;其它：&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;p&gt;我最终改掉了这组博客文章的标题。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;这充分说明使用短标题是正确的。&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</description><link>http://aimingoo.github.io/1-1724/</link><guid isPermaLink="false">b9502886-b86f-4f2e-b8c1-ee5f4a67f92e</guid><category>博客</category><category>Gitment</category><category>OpenSource Project</category><dc:creator>aimingoo</dc:creator><pubDate>Tue, 30 May 2017 07:48:53 GMT</pubDate><content:encoded>&lt;p&gt;本来没想把《博客迁移手记》写得这么长这么多，所以写了这么久之后再来看，博客的标题感觉就很Low了。&lt;/p&gt;

&lt;p&gt;于是决定给这一组《博客迁移手记（1~n）》写个导航，也算整理一下思路。&lt;/p&gt;

&lt;h2 id=""&gt;快速导航&lt;/h2&gt;

&lt;p&gt;博客迁移手记（一）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用BlogToWordpress迁移你的博客&lt;/li&gt;
&lt;li&gt;使用本地博客Ghost的快速指南与导入工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（二）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从本地博客到Github Pages的最佳指南&lt;/li&gt;
&lt;li&gt;makesite.sh使用手册&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（三）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以kaldorei为例详解Ghost Theme的定制&lt;/li&gt;
&lt;li&gt;Ghost中文章置顶的实现方法&lt;/li&gt;
&lt;li&gt;如何最大程度地静态化Ghost博客&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（四）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gitment大坑：谈谈secret泄露的前因后果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（五）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何获得一个支持HTTPS的免费空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博客迁移手记（六）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用intersect来做Gitment的API网关&lt;/li&gt;
&lt;li&gt;Gitment的一些Bug修复与补强&lt;/li&gt;
&lt;li&gt;Gitment的简单多语言支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=""&gt;其它：&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;p&gt;我最终改掉了这组博客文章的标题。&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;这充分说明使用短标题是正确的。&lt;/p&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title>手记5：如何获得一个支持HTTPS的免费空间</title><description>&lt;p&gt;下面我们讲的内容其实与Gitment没什么关系。如果你已经有了支持https的空间那就跳过去，如果没有的话，建议还是看看好的伐。&lt;/p&gt;

&lt;h2 id="10https"&gt;10. 让免费主页空间支持HTTPS&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;好象我们把问题搞得复杂了：本来我是想做个静态主页的博客网站，现在我却需要找个支持PHP+SSL的动态主页空间？&lt;/p&gt;
  
  &lt;p&gt;好吧。没关系。反正我闲着在养病，不做点啥岂不是辜负了时光。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;免费主页空间其实挺好找的，尽管要找到一个有长期信誉的并不太容易。即使如此，当你得到这样一个免费空间之后，它多数也是不支持https的。&lt;/p&gt;

&lt;h3 id="101https"&gt;10.1 你的主页空间是不是支持HTTPS？&lt;/h3&gt;

&lt;p&gt;好吧，确实有很多免费空间『声称』它支持https了。这种情况下它通常会给你用通用工具生成一个自主颁发的ssl凭证——而这个凭证是不受主流浏览器信任的。也就是说，在访问这样的一个网站时，你的浏览器地址栏会是这样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;（我很好奇为什么12306到现在仍然是这样，难道他们也得不到一个有效的ssl凭证吗？）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/05/browser_12306_cn.png" alt="browser_12306_cn"&gt;&lt;/p&gt;

&lt;p&gt;免费主页空间缺省情况下给你颁发的就是这样一种自主签名的SSL（能通过验证，却不被浏览器环境信任），又或者你的空间根本还不支持ssl/https。这个需要你到主页空间的后台去找一个名为SSL的管理功能，通常它会列举三个信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Private Key，私钥，它通常与下面的CSR是成对的。
&lt;ul&gt;&lt;li&gt;CSR，证书验证请求（Cerificate Signing Request）。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Certificate，&lt;/li&gt;&lt;/ul&gt;</description><link>http://aimingoo.github.io/1-1723/</link><guid isPermaLink="false">fa7313be-e458-4280-8739-ab40307afcd0</guid><category>博客</category><category>SSL</category><category>HTTPS</category><category>免费空间</category><category>证书</category><dc:creator>aimingoo</dc:creator><pubDate>Tue, 30 May 2017 07:25:00 GMT</pubDate><content:encoded>&lt;p&gt;下面我们讲的内容其实与Gitment没什么关系。如果你已经有了支持https的空间那就跳过去，如果没有的话，建议还是看看好的伐。&lt;/p&gt;

&lt;h2 id="10https"&gt;10. 让免费主页空间支持HTTPS&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;好象我们把问题搞得复杂了：本来我是想做个静态主页的博客网站，现在我却需要找个支持PHP+SSL的动态主页空间？&lt;/p&gt;
  
  &lt;p&gt;好吧。没关系。反正我闲着在养病，不做点啥岂不是辜负了时光。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;免费主页空间其实挺好找的，尽管要找到一个有长期信誉的并不太容易。即使如此，当你得到这样一个免费空间之后，它多数也是不支持https的。&lt;/p&gt;

&lt;h3 id="101https"&gt;10.1 你的主页空间是不是支持HTTPS？&lt;/h3&gt;

&lt;p&gt;好吧，确实有很多免费空间『声称』它支持https了。这种情况下它通常会给你用通用工具生成一个自主颁发的ssl凭证——而这个凭证是不受主流浏览器信任的。也就是说，在访问这样的一个网站时，你的浏览器地址栏会是这样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;（我很好奇为什么12306到现在仍然是这样，难道他们也得不到一个有效的ssl凭证吗？）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/05/browser_12306_cn.png" alt="browser_12306_cn"&gt;&lt;/p&gt;

&lt;p&gt;免费主页空间缺省情况下给你颁发的就是这样一种自主签名的SSL（能通过验证，却不被浏览器环境信任），又或者你的空间根本还不支持ssl/https。这个需要你到主页空间的后台去找一个名为SSL的管理功能，通常它会列举三个信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Private Key，私钥，它通常与下面的CSR是成对的。
&lt;ul&gt;&lt;li&gt;CSR，证书验证请求（Cerificate Signing Request）。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Certificate，验证信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单的逻辑是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;假设你先有了一个私钥（Private Key），然后&lt;/li&gt;
&lt;li&gt;你用私钥对一些『要验证的信息』加密，生成了一个验证请求（CSR），最后&lt;/li&gt;
&lt;li&gt;你要找一个有公信力的机构来证明CSR是你的；如果验证通过他就给你发一份Certificate。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你最后从『公信力机构』拿到的这个Certificate就是SSL凭证。——找到你的免费空间后台管理中的Certificate填进去，OK，你的网站就支持&lt;code&gt;https&lt;/code&gt;了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当然这其中还有很多的细节，比如免费空间服务商怎么把你的Certificate装到Web服务器上面去等等等等。不过除非你是要搞台云主机自己来架服务器，这些就先不要了解了吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="102certificate"&gt;10.2 两种获得Certificate的方法&lt;/h3&gt;

&lt;p&gt;这三个信息有两种方式来获得。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种是你的免费空间提供商为你生成Private Key/CSR这一对信息，然后你将其中的CSR提交给『公信力机构』，后者给你发Certificate文本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以这种情况下你看到免费空间后台管理的SSL配置中会有一个『Generate Key/CSR』按钮，按一下就得到了前面信息了——如果只能填入而不能Generate，那么你也可以自己做，例如在MacOSX中的工具keytool或OpenSSL（&lt;a href="https://faq.xiaoz.me/archives/100.html"&gt;参考这里&lt;/a&gt;，或&lt;a href="https://onlinehelp.tableau.com/current/server/zh-cn/ssl_cert_create.htm"&gt;这里&lt;/a&gt;）。与之对应的，在『公信力机构』的证书申请流程中会有一个类似这样的提示：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-provide_your_csr.png" alt="ssl_step-provide_your_csr"&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;另一种是『公信力机构』一次性地为你把上述三步全做了——他不需要你提供CSR，而是为你生成一个Private Key，然后自己生成CSR、完成验证并最后把Private Key交还给你。例如阿里云为你提供的验证服务就是这样（它后台用的是Symantec的免费DV服务）。这种情况下，你就需要将其中的Private Key交给免费空间提供商了——所以你的免费空间后台管理的SSL配置中，通常在『Generate Key/CSR』按钮旁边，就还会有一个『Upload Key』的功能，这个Key，指的就是Private Key。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了。简单地汇总一下上面的信息：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找一个『公信力机构』，让他证明你的网站是你的；  &lt;/li&gt;
&lt;li&gt;如果他要CSR，你就给他；如果他不要CSR，那么他应该给你Private Key。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，如果你的主页空间不给你提供ssl功能（没有地方让你提交『公信力机构』验证过的Certificate），那么——换一家吧。&lt;/p&gt;

&lt;h3 id="103"&gt;10.3 怎么证明『你的网站是你的』&lt;/h3&gt;

&lt;p&gt;所谓的『公信力机构』要颁发SSL签证，其实是想说明『因为这个网站你是你的，所以我发了这个证明给你』。因此无论如何，这个机构也要有办法来证明『你的网站是你的』，而不仅仅是因为你提交了CSR申请。&lt;/p&gt;

&lt;p&gt;所以一旦你申请了，那么你就要为接下来的验证工作做准备，而这取决于不同的『公信力机构』采用的验证方法。下面举三种例子。&lt;/p&gt;

&lt;h4 id="1031symantec"&gt;10.3.1 阿里云或Symantec的签证&lt;/h4&gt;

&lt;p&gt;阿里云可以为你的网站提供1年的免费SSL签证，它的这项服务是通过Symantec签证机构来做的（所以腾讯云也是这样）。所以下面其实是在说Symantec的签证要求。&lt;/p&gt;

&lt;p&gt;阿里云是允许你通过修改DNS或在指定的主页位置放一个名为&lt;code&gt;fileauth.txt&lt;/code&gt;的文本文件（一个详细的过程可以&lt;a href="https://yfdxs.com/ali-ssl-amh.html"&gt;看过里&lt;/a&gt;，如果你能修改DNS的CNAME配置那么&lt;a href="https://www.xiaoz.me/archives/7442"&gt;看这里&lt;/a&gt;）。这样，你就必须要：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有这个网站（或主页）的ftp账号；并且，  &lt;/li&gt;
&lt;li&gt;可以创建名为&lt;code&gt;.well-known&lt;/code&gt;这样以点字符开始的目录名（基于Windows系统的主机不能创建这样的名称）；并且，  &lt;/li&gt;
&lt;li&gt;可以确保能通过&lt;code&gt;http://your-domain-name/.well-know/...&lt;/code&gt;这样的url路径下载到上述文本文件（注意：如果你的网站已经开通了https，那么它会优先访问https开头的地址）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;问题往往出在第3步。这是因为Symantec会优先去https开头的地址下载验证文件，而一般会提供ssl的主机/免费空间都会默认的给你装一个『自主签名的SSL证书』，这个证书事实上会被认为是无效的——因此Symantec就会验证不通过。&lt;/p&gt;

&lt;p&gt;这种情况下你可以曲线救国：先去找别的机构签一个短期一些（通常是3个月）的证书，让这个https地址生效了，然后再回头过验证Symantec的签证（话说，我就是这么干的）。&lt;/p&gt;

&lt;p&gt;不过，有些时候事情并不那么美妙，因为即使你的主页空间『信誓旦旦』地说他们开放了SSL，并且无论如何你都把文件传到了正确的地方，甚至你看起来也的确可以通过https/http来访问到上述的&lt;code&gt;fileauth.txt&lt;/code&gt;文件的URL地址，但是——你就是通不过Symantec（或者阿里云、腾讯云等等）的验证——它们找不到上面的这个文件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：我就是因为这个问题申请了又放弃了近二十个免费主页空间。相信我，如果你逐一去试，不会好到哪里去的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题出在哪儿呢？&lt;/p&gt;

&lt;p&gt;这是因为非常非常多的『免费主页』本质上都是要在你的主页上挂广告才能活下去的，他们挂广告的方法真的很纷纷多啊。其中一种常用的，就是串改你的url地址，它会把浏览器访问到的url改成带广告代码的，然后自己搞点弹窗啊什么的，最后才重定向到你真实的地址。——这个过程浏览器认得，而『公信力机构』的验证程序可认不得啊，后者在读取验证文件的时候并不支持为浏览器准备的重定向！&lt;/p&gt;

&lt;p&gt;所以，一旦你申请到一个主页空间，先用curl去访问一下，如果是下面这种返回：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; curl 'http://your-domain-name/'
&amp;lt;html&amp;gt;  
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;403 Forbidden&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;  
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，它的意思是说不支持curl这样的直接访问，一般来说就不能用了。不过如果你不死心，可以再试试伪装成浏览器：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; curl -H 'User-Agent:Mozilla/5.0' 'http://your-domain-name/'
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script type="text/javascript" ...  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么你就真的不用想了：上面的就是挂广告的代码了，你还想什么呢。&lt;/p&gt;

&lt;p&gt;所以你看，我申请了很多又很多个免费空间，都作废了。&lt;/p&gt;

&lt;h4 id="1032instantssl"&gt;10.3.2 试试别的验证方法，例如instantssl的&lt;/h4&gt;

&lt;p&gt;这家『公信力机构』也非常棒，他提供3个月免费的签证。我们上面说过，你可以尝试『曲线救国』，或者干脆就每三个月签一回，都行。&lt;/p&gt;

&lt;p&gt;重要的是，instantssl采用的是邮件验证，而不是验证ftp文件。&lt;/p&gt;

&lt;p&gt;instantssl是科摩多（comodo）提供的一项SSL证书发放服务，所以你用&lt;a href="http://www.comodo.cn/"&gt;comodo.cn&lt;/a&gt;或&lt;a href="http://www.instantssl.cn/"&gt;instantssl.cn&lt;/a&gt;访问都是可以的。他要求你提供自己准备的CSR，之后会提示你会把证书邮寄给你的网站的admin邮箱账号。&lt;/p&gt;

&lt;p&gt;所以，这就要求你的主页空间给你开通邮箱服务，并且你能自定义类似&lt;code&gt;admin@yourname.freespace.xyz&lt;/code&gt;这样的邮箱名——这个instantssl可以让你选，不过总的来说就那几种特定的。&lt;/p&gt;

&lt;p&gt;很好，如果你有这样的免费空间，或者你就是能得到这样的邮箱，那么试试instantssl的吧。我知道&lt;a href="http://infinityfree.net"&gt;infinityfree&lt;/a&gt;免费空间提供这样的邮箱服务，比如我其实申请了一个&lt;code&gt;.epizy.com&lt;/code&gt;的二级域名。但很不幸我没有通过instantssl的验证——它提示我相应名字的签证已经发过了。&lt;/p&gt;

&lt;p&gt;不知道为什么。反正，你也许可以试试。&lt;/p&gt;

&lt;h4 id="1033"&gt;10.3.3 还有一些别的不错的签证机构&lt;/h4&gt;

&lt;p&gt;有个非常非常著名的、推动https的签证组织，叫&lt;code&gt;Let’s Encrypt&lt;/code&gt;。这个签证非常好用，所以也常常有自己做虚拟主机的来用它（&lt;a href="https://www.freehao123.com/lets-encrypt/"&gt;https://www.freehao123.com/lets-encrypt/&lt;/a&gt;），很多介绍中也首推就是它（&lt;a href="https://www.freehao123.com/top-8-free-ssl-cert/"&gt;例如这里&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;然而它对web域名签证并不友好，所以就有人搞了网站来做这件事，最好用的就是这家了：&lt;a href="https://www.sslforfree.com/"&gt;https://www.sslforfree.com/&lt;/a&gt;，它发的也是3个月的免费签证。你可以先看看这个教学&lt;a href="https://changken.biz/969"&gt;SSLforFree 免费SSL凭证&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;SSLforFree的验证过程与阿里云/Symantec的类似，也是要求你传一个文件到ftp上（或者改DNS CNAME），不过他不验证https，所以多数『提供了无效的https的免费空间』来说也能很好的通过验证——除了我上面说的挂广告代码的那种情况。&lt;/p&gt;

&lt;p&gt;也许还有其它好的，有知道的不妨推荐给我。&lt;/p&gt;

&lt;h3 id="104"&gt;10.4 安装你得到的凭证&lt;/h3&gt;

&lt;p&gt;『公信力机构』最终给你的是名为Certificate的凭证。并且，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果是他帮你生成的CSR，那么他会给你Private Key；&lt;/li&gt;
&lt;li&gt;一般来说他会给你一个它作为签证机构的公钥，不过由于使用者（例如你的主页空间服务商）能直接从网站上搜到这个公钥，所以没有给你也是正常的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你需要在后台把Certificate凭证和Private Key给上传(Upload)或更新(Update)到你的管理后台——如果它有类似『SSL管理』这样的功能的话。例如：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;（第1步先上传你的证书）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-update_ssl.png" alt="ssl_step-update_ssl"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;（然后点下面的『管理SSL站点』）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-update_site-1.png" alt="ssl_step-update_site"&gt;&lt;/p&gt;</content:encoded></item><item><title>手记4：谈谈Gitment中泄露secret的前因后果与解决方法</title><description>&lt;p&gt;本来我接下来只是想在博客中加上一个支持评论的功能（使用Gitment），然而诸多的尝试之后，我却发现我需要创建一个支持https的web站点……&lt;/p&gt;

&lt;p&gt;这一切的目的，只是使得我们的Gitment有跨域访问的Api接口可用。&lt;/p&gt;

&lt;h2 id="8"&gt;8. 问题出在哪里&lt;/h2&gt;

&lt;p&gt;Gitment（&lt;a href="https://github.com/imsun/gitment"&gt;项目&lt;/a&gt;）是极棒的一个利用Github Issues来实现博客评论功能的项目，作者（&lt;a href="https://imsun.net/"&gt;https://imsun.net/&lt;/a&gt;）在介绍中特别提到，这种对Issues功能的使用方法是Github团队支持许可的。这也意味着只要你能接受以下两点可能存在的限制/隐患，你就可以长期地使用它：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github真的可能被屏蔽，尽管这种可能性已经越来越小&lt;/li&gt;
&lt;li&gt;要发表评论的话必须先注册Github的账号，不过浏览评论是不受限制的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是使用Gitment是有问题的。更准确地说，如果你直接在你的博客中部署Gitment这个项目，那么你将面临你的Github application client secret token丢失的风险。这个风险会带来两种可能，一种是你自己的Github账户下的application被假冒，另一种是在你的博客上发表评论的Github用户被冒名。&lt;/p&gt;

&lt;p&gt;这个风险看起来很大。而这对于Gitment来说又难于避免，因为它要求你在使用时往博客模板中插入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var gitment = new Gitment({  
  id: '页面 ID', // 可选。默认为 location.href&lt;/code&gt;&lt;/pre&gt;</description><link>http://aimingoo.github.io/1-1722/</link><guid isPermaLink="false">bfa19ad7-3e78-4560-a7ff-f79104c7dd8d</guid><category>博客</category><category>Javascript</category><category>Github</category><category>Gitment</category><category>OpenSource Project</category><dc:creator>aimingoo</dc:creator><pubDate>Sun, 28 May 2017 18:17:49 GMT</pubDate><content:encoded>&lt;p&gt;本来我接下来只是想在博客中加上一个支持评论的功能（使用Gitment），然而诸多的尝试之后，我却发现我需要创建一个支持https的web站点……&lt;/p&gt;

&lt;p&gt;这一切的目的，只是使得我们的Gitment有跨域访问的Api接口可用。&lt;/p&gt;

&lt;h2 id="8"&gt;8. 问题出在哪里&lt;/h2&gt;

&lt;p&gt;Gitment（&lt;a href="https://github.com/imsun/gitment"&gt;项目&lt;/a&gt;）是极棒的一个利用Github Issues来实现博客评论功能的项目，作者（&lt;a href="https://imsun.net/"&gt;https://imsun.net/&lt;/a&gt;）在介绍中特别提到，这种对Issues功能的使用方法是Github团队支持许可的。这也意味着只要你能接受以下两点可能存在的限制/隐患，你就可以长期地使用它：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github真的可能被屏蔽，尽管这种可能性已经越来越小&lt;/li&gt;
&lt;li&gt;要发表评论的话必须先注册Github的账号，不过浏览评论是不受限制的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是使用Gitment是有问题的。更准确地说，如果你直接在你的博客中部署Gitment这个项目，那么你将面临你的Github application client secret token丢失的风险。这个风险会带来两种可能，一种是你自己的Github账户下的application被假冒，另一种是在你的博客上发表评论的Github用户被冒名。&lt;/p&gt;

&lt;p&gt;这个风险看起来很大。而这对于Gitment来说又难于避免，因为它要求你在使用时往博客模板中插入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;var gitment = new Gitment({  
  id: '页面 ID', // 可选。默认为 location.href
  owner: '你的 GitHub ID',
  repo: '存储评论的 repo',
  oauth: {
    client_id: '你的 client ID',
    client_secret: '你的 client secret',
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个&lt;code&gt;client_secret&lt;/code&gt;来自于你在自己的Github个人配置&lt;code&gt;Settings -&amp;gt; Developer Settings -&amp;gt; OAuth applicatoins&lt;/code&gt;中创建一个application时所生成的secret，这个secret提供了所谓的单点登录认证，以确保其它的Github用户在经过同意后使用你的博客中的Gitment模块来发评化——这种用法类似于新浪、微信、QQ等等的小应用。&lt;/p&gt;

&lt;p&gt;通常你需要这个secret有访问者的repo级别的访问权限（因为添加评论其实上是向repo的issues中添加comments），而一旦有人劫持了访问者的access_token，那么它就可以仿冒访问者在任意的github仓库中添加comments、以及issues——看起来很可怕不是？而且事实上看起来这个权限还更大，可以操作访问者自己的仓库。&lt;/p&gt;

&lt;p&gt;Gitment的作者为什么要留下这么一个漏洞呢？Github又为什么会允许这样一个漏洞存在呢？&lt;/p&gt;

&lt;h3 id="81gitment"&gt;8.1 Gitment干了什么？&lt;/h3&gt;

&lt;p&gt;其实Gitment的作者是好心的。他在源代码中是这么写的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;this.state.user.isLoggingIn = true  
http.post('https://gh-oauth.imsun.net', {  
    code,
    client_id,
    client_secret
  }, '')
  .then(data =&amp;gt; {
    this.accessToken = data.access_token;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的意思，是拿你在Github后台生成的一对&lt;code&gt;client_id/client_secret&lt;/code&gt;验证信息，去&lt;code&gt;https://gh-oauth.imsun.net&lt;/code&gt;上面换取access_token，而这个access_token才是当前登录的Github用户在你的博客用发评论时使用的验证信息。这个access_token会记录在cookies中，并且每次调用Github api时作为Authorization头信息提交给Github验证身份。&lt;/p&gt;

&lt;p&gt;你把client_id和client_secret同时给了imsun.net，这是不对的；即使你信任imsun.net，然而把它公布在源代码中，也是不对的。——所以，事实上如果你在博客中部署了上述代码，你还会收到来自Github的一封邮件，提醒你不应该将token放在源代码中（是的，Github会扫描提交的源代码）。&lt;/p&gt;

&lt;p&gt;Gitment的作者并不是不知道这个问题，他只是好心的想帮你解决一个问题——这个我们下面会讲到——然而他带来了更严重的问题。&lt;/p&gt;

&lt;h3 id="82github"&gt;8.2 深入了解Github的单点登录和应用授权&lt;/h3&gt;

&lt;p&gt;如果你在Github站外使用它的单点登录（也就是提示你用Github账户登录以使用某种功能），那么在这个网页中——其实也可以不是前端的网页，而是后端应用——需要调用Github API，来将当前用户引导到下面的Github的登录和授权页面：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;GET https://github.com/login/oauth/authorize  
    ?scope=(权限范围, Gitment预设的是'public_repo')
    &amp;amp;client_id=(验证应用的client_id)
    &amp;amp;redirect_url=(验证成功后的返回url, Gitment预设的是当前页)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，（如果当前用户/访客没有登录过，那么）它看到的页面是下面这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;（界面1：跨站应用的单点登录界面）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/05/github_auth_step-1.png" alt="github_auth_step-1"&gt;&lt;/p&gt;

&lt;p&gt;如果访客还没有为这个应用授权过（或者他已经是Github的登录用户），那么他之后还会看到下面这个界面：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;（界面2：授权）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/2017/05/github_auth_step-2.png" alt="github_auth_step-2"&gt;&lt;/p&gt;

&lt;p&gt;这两步的目的就是让访客登录，并且让他确认你的应用（例如Gitment）能够使用他的账号中的哪些权限。一旦用户确认过这个授权，那么在他的Github账号后台&lt;code&gt;Settings -&amp;gt; Authorized OAuth Apps&lt;/code&gt;中就可以看到这个应用（也能Revoke掉它），并且下次就不用再确认授权了。&lt;/p&gt;

&lt;p&gt;注意到上述'will redirect to'的地址——它在使用API提交时的配置细节在Github API的说明中有（&lt;a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/#redirect-urls"&gt;在这里&lt;/a&gt;），简单地说它必须以Application在后台的配置作为前缀。在我们这里讨论的Gitment中，作者将它设置为当前正在访问的网页——例如某篇博客文章（Post）。&lt;/p&gt;

&lt;p&gt;接下来如果Github验证并授权了访问的账户，它就会通过HTTP调用来返回304并带上一个Location地址，这个地址就是上面的redirect_url，并且会在这个url后面多带一个&lt;code&gt;code&lt;/code&gt;参数。以我的站点上的某个具体的post来说，返回的时候这个Header是下面这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Location:https://aimingoo.github.io/1-1718.html?code=40299d8475d3679c8c8c  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在静态页面（例如1-1718.html）中从url取参数的方法就不用细讲了。于是接下来Giment取到这个参数&lt;code&gt;code&lt;/code&gt;，它还需要再做一次验证，才能真正的让当前用户能够使用Github API。这个验证操作需要调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;POST https://github.com/login/oauth/access_token  
    client_id: ...
    client_secret: ...
    code: ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且它使用POST请求的Accept header来决定以何种格式（xml/json/url-encode）来返回数据。显然地，这里需要在浏览器中使用AJAX请求来向&lt;code&gt;https://github.com/&lt;/code&gt;调用这个API。&lt;/p&gt;

&lt;p&gt;问题就出在这一步。&lt;/p&gt;

&lt;h3 id="83githuboauth"&gt;8.3 Github OAuth并不支持浏览器跨站访问&lt;/h3&gt;

&lt;p&gt;如果你在命令行上或者其它代码中直接访问上述POST API，那么不错，你能拿到返回数据access_token，然而不幸的是：Gitment在浏览器上，只能使用Ajax。&lt;/p&gt;

&lt;p&gt;事实上Gitment可以调用上述API并返回数据，但是注意发起这个API的地址（以上面的post为例）与调用的Github API地址分别是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://aimingoo.github.io/1-1718.html  
https://github.com/login/oauth/access_token  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是浏览器说：这是一个跨站访问！浏览器会把POST请求拆成两个，先发一枚OPTIONS请求问问github.com是否支持跨站，如果github.com接受了OPTIONS并正确返回，那么浏览器才接下来发POST请求。——OPTIONS请求是没有POST BODY区的，显然这是为了避免服务器接受大型的POST请求时浪费资源。关于这个过程的细节，可以参考阮一峰老师的文章『&lt;a href="http://www.ruanyifeng.com/blog/2016/04/cors.html"&gt;跨域资源共享 CORS 详解&lt;/a&gt;』。简单地说，服务器端对OPTIONS和POST请求都必须在返回头中包括&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段，并使该字段带有正确的来源Origin信息。——这样一来，浏览器就会认为服务器是接受跨站访问的了。&lt;/p&gt;

&lt;p&gt;然而Github的access_token接口并不返回上述头。而且，可以预见的将来，它都不会有这个头。因为这是正确的——我们确实不应该在浏览器上直接使用这个接口，并且公开接口中的client_secret。从另一方面来说，这个access_token接口是应该在一个浏览器用户受信的后端应用中，亦即是我们称为Gitment模板的应用内部发起调用的，它可以持有client_secret而不必告诉任何人，这是Github确认『该应用合法』的唯一凭据。&lt;/p&gt;

&lt;p&gt;Gitment没有办法同时做到两件事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;既可以使用一个惟一、统一的Giment client_secret凭据，&lt;/li&gt;
&lt;li&gt;又在redirect_url中指定某个非确定的博客返回地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这使得作者无法公开发布一个公众使用的、不需要每个博主去Github后台配置OAuth Application服务的应用。而接下来，作者也有没办法在没有client_secret凭据的情况下，帮你调用Github's access_token接口。&lt;/p&gt;

&lt;p&gt;所以，你看到了结果：Gitment的代码要求在网页中泄露你的client_secret，然后提交到&lt;code&gt;https://gh-oauth.imsun.net&lt;/code&gt;去，作者会帮助你调用Github API，然后返回一个access_token。&lt;/p&gt;

&lt;p&gt;只有这样，当前的访问才能用这个access_token为每一个XHR Request建立有效的Authorization头。&lt;/p&gt;

&lt;p&gt;问题的根源，仅仅是出在Github OAuth并不支持浏览器跨站访问——它的返回头用没有Access-Control-Allow-Origin。&lt;/p&gt;

&lt;h3 id="84api"&gt;8.4 API网关&lt;/h3&gt;

&lt;p&gt;显然，这绝壁了就是API网关要干的事情。如果我有一个API网关，那么我就只需要接受来自浏览器的Gitment请求，然后将API转发到Github，并且在返回头上塞上一个Access-Control-Allow-Origin就万事大吉了！&lt;/p&gt;

&lt;p&gt;是的，这是对的。不幸的是，没有这么个东东——而且要开放可信的。&lt;/p&gt;

&lt;p&gt;我尝试过阿里云的API网关！很牛x的产品，价格也不贵，而且配置操作一路极顺畅，Ding dong Ding dong分分钟就建好了网关，但是——不能定制返回的HTTP Header！&lt;/p&gt;

&lt;p&gt;我尝试过微软Azure里的API网关！也很牛x产品，骗了我一块钱人民币，居然让我连配置都完不成——最最反程序员的产品就非它莫属了。&lt;/p&gt;

&lt;p&gt;我尝试过很多很多云服务或云端微服务的API网关产品，要么是根本连页面都打不开的，要么就是不支持CORS跨站的。简单地说：你就算想花钱也是花不出去的。&lt;/p&gt;

&lt;p&gt;不过真想花钱，还是有一个法子的。你可以租一台虚拟主机，然后在上面架一个Nginx，通过配置来代理这个POST请求并在返回中加上Access-Control-Allow-Origin头。是的，这相当不错，连代码也不用写。但是搞云主机啊，分分钟收钱的。——你的API能访问几次？一个小小小小得不得了的博客，一个月能用10来条评论就不错了，调用上面的登录接口，大概也就三五次吧！&lt;/p&gt;

&lt;p&gt;不值当搞台云主机啊！&lt;/p&gt;

&lt;p&gt;于是，我说：&lt;/p&gt;

&lt;h3 id="85sir"&gt;8.5 写点代码吧，Sir&lt;/h3&gt;

&lt;p&gt;要写点代码就其实很好办了，用NodeJS也好、PHP/ASP也行，其实甚至BASH脚本都搞得定。只需响应前端（frontend）来的POST请求，然后去Github API接口（backend）上拿数据，在返回前端之前塞上个Header就行了。&lt;/p&gt;

&lt;p&gt;不过具体要做起来，就麻烦一点了。我用PHP写了一个名为intersect的项目（&lt;a href="https://github.com/aimingoo/intersect"&gt;在这里&lt;/a&gt;），它修改自&lt;a href="https://github.com/stamat/corsica"&gt;CORSica&lt;/a&gt;，不过添加了不少的特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTPS POST支持&lt;/li&gt;
&lt;li&gt;添加可配置字段（例如为Github API添加client_secret）&lt;/li&gt;
&lt;li&gt;处理前后端不同的Connection方法&lt;/li&gt;
&lt;li&gt;处理Transfer-Encoding&lt;/li&gt;
&lt;li&gt;处理Content-Length的变化&lt;/li&gt;
&lt;li&gt;一些防止滥用的简单guard代码&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基本上，我的意思是说，它简单的配置下就可用了；而且稍作定制，也可以作为一个通用的CORS网关。所以，接下来，你就需要找一个能放PHP代码的免费主页，然后把intersect放上去，配置其中的&lt;code&gt;DOMAIN_ACCEPT&lt;/code&gt;和&lt;code&gt;PRIVATE_CLIENT_SECRET&lt;/code&gt;。这样这个网站就能拿来替代Gitment中对&lt;code&gt;https://gh-oauth.imsun.net&lt;/code&gt;的访问了。&lt;/p&gt;

&lt;p&gt;当然，Gitment还需要稍稍的改点代码。&lt;/p&gt;

&lt;p&gt;这个我们回头再说，现在我们得搞一个提供免费主页的网站把这个代码放上去。&lt;/p&gt;</content:encoded></item><item><title>手记3：实例教学之Ghost模板定制</title><description>&lt;p&gt;接下来我们聊一下如何定制这个博客的风格。&lt;/p&gt;

&lt;h2 id="7themes"&gt;7. 定制Themes&lt;/h2&gt;

&lt;p&gt;Ghost缺省使用的主题叫casper theme，你可以在博客管理界面&lt;code&gt;Settings -&amp;gt; General -&amp;gt; Themes&lt;/code&gt;中找到你当前安装过的全部Themes，并任意激活/删除它们。&lt;/p&gt;

&lt;p&gt;有两种方法来安装Themes。第一种是在这个管理界面中选最下面的『Upload A Theme』来上传你下载过的Theme .zip包，第二种是直接将.zip包解压到Ghost安装目录的&lt;code&gt;content/themes/&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;我选择的是使用小蘿蔔丁(&lt;a href="http://xlbd.me/"&gt;在这里&lt;/a&gt;)发布的&lt;code&gt;kaldorei - 0.8.0&lt;/code&gt;，你可以下载或阅读这个Theme相关的说明（&lt;a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei"&gt;这里&lt;/a&gt;）。我可能将来会将博客换成别的什么风格，不过现在kaldorei还是挺合用的。&lt;/p&gt;

&lt;p&gt;但我还是做了一些修改（关于Themes的基础使用与修改改可以参考&lt;a href="http://docs.ghost.org/zh/themes/"&gt;这里&lt;/a&gt;）。&lt;/p&gt;

&lt;h3 id="71"&gt;7.1 一些基本和简单的使用&lt;/h3&gt;

&lt;p&gt;Ghost的一个好处是可以随意定制并生成静态页，这些页可以用博客后台来发布或更新，或者仅仅只是一个普通的静态页面（无需通过后台来更新内容）&lt;/p&gt;</description><link>http://aimingoo.github.io/1-1721/</link><guid isPermaLink="false">5e342c06-52cf-44de-b741-428859c06a61</guid><category>Ghost</category><category>博客</category><category>Javascript</category><dc:creator>aimingoo</dc:creator><pubDate>Sat, 27 May 2017 19:28:21 GMT</pubDate><content:encoded>&lt;p&gt;接下来我们聊一下如何定制这个博客的风格。&lt;/p&gt;

&lt;h2 id="7themes"&gt;7. 定制Themes&lt;/h2&gt;

&lt;p&gt;Ghost缺省使用的主题叫casper theme，你可以在博客管理界面&lt;code&gt;Settings -&amp;gt; General -&amp;gt; Themes&lt;/code&gt;中找到你当前安装过的全部Themes，并任意激活/删除它们。&lt;/p&gt;

&lt;p&gt;有两种方法来安装Themes。第一种是在这个管理界面中选最下面的『Upload A Theme』来上传你下载过的Theme .zip包，第二种是直接将.zip包解压到Ghost安装目录的&lt;code&gt;content/themes/&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;我选择的是使用小蘿蔔丁(&lt;a href="http://xlbd.me/"&gt;在这里&lt;/a&gt;)发布的&lt;code&gt;kaldorei - 0.8.0&lt;/code&gt;，你可以下载或阅读这个Theme相关的说明（&lt;a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei"&gt;这里&lt;/a&gt;）。我可能将来会将博客换成别的什么风格，不过现在kaldorei还是挺合用的。&lt;/p&gt;

&lt;p&gt;但我还是做了一些修改（关于Themes的基础使用与修改改可以参考&lt;a href="http://docs.ghost.org/zh/themes/"&gt;这里&lt;/a&gt;）。&lt;/p&gt;

&lt;h3 id="71"&gt;7.1 一些基本和简单的使用&lt;/h3&gt;

&lt;p&gt;Ghost的一个好处是可以随意定制并生成静态页，这些页可以用博客后台来发布或更新，或者仅仅只是一个普通的静态页面（无需通过后台来更新内容）。无论如果，Ghost提供很简单的方法来做这件事，并且允许你为每一个静态页定制自己的页面风格、主题或模板。&lt;/p&gt;

&lt;p&gt;kaldorei主题是使用这个方式来实现『历史归档』的功能（&lt;a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei#开启归档功能"&gt;参考这里&lt;/a&gt;），这也相当于介绍了『定制静态页』功能的用法——所以我的博客的『关于』页面就是这样做的。&lt;/p&gt;

&lt;h4 id="711"&gt;7.1.1 处理背景色与背景图片&lt;/h4&gt;

&lt;p&gt;需要两个操作。其一：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-css"&gt;/* modify file at ./ghost-theme-kaldorei/assets/css/screen.css */
body {  
    margin: 0;
    background: #000;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其二，在default.hbs模板的body标签之后添加如下风格样式：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;style&amp;gt;  
body {  
    background-image: url(/assets/img/background.jpg);
    background-repeat: no-repeat;
    background-position: top center;
    background-attachment: fixed;
    background-size: auto;
}

.site-wrapper {
    background: none;
}

.main-header {
    background: none;
    border-bottom: none;
}

.main-nav a {
    color: #FFF;
}
&amp;lt;/style&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这个风格中的背景图片是放在Ghost安装目录下的&lt;code&gt;content/themes/ghost-theme-kaldorei/assets/img&lt;/code&gt;目录中的。makesite.sh脚本（或Buster工具）会搜索到这个文件，并下载这个文件到你的static目录中。&lt;/p&gt;

&lt;h4 id="712"&gt;7.1.2 为每篇博客添加『编辑』按钮&lt;/h4&gt;

&lt;p&gt;当添加了这个按钮之后，我在本地博客中读博文的时就可以随时编辑它，而不必总是回到管理后台去找到这篇文章——Ghost后台没有搜索功能。&lt;/p&gt;

&lt;p&gt;因为添加的这个按钮对线上的用户没有意义，所以在我的&lt;code&gt;makesite.sh&lt;/code&gt;脚本中有一处代码会将它从&lt;code&gt;./static&lt;/code&gt;中的静态页面中清理掉。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!-- modify file at ./ghost-theme-kaldorei/post.hbs --&amp;gt;  
&amp;lt;span class="post-meta-item pull-right"&amp;gt;  
  &amp;lt;!-- 在这个位置插入如下行 --&amp;gt;
  &amp;lt;a href="/ghost/editor/{{id}}/" target="_blank"&amp;gt;编辑&amp;lt;/a&amp;gt;
&amp;lt;/span&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="713"&gt;7.1.3 移除所有页脚&lt;/h4&gt;

&lt;p&gt;纯粹只是个人不喜欢而已，因此除了保留版权说明之外，其它页脚本全部合并/删除掉了。基本上你在.hbs文件中搜索&lt;code&gt;-footer&lt;/code&gt;然后自己斟情清理就行了。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language- bash"&gt;&amp;gt; grep 'footer' *.hbs partials/*
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="714"&gt;7.1.4 定制个人信息&lt;/h4&gt;

&lt;p&gt;相关的信息页面在如下模板中，斟情修改（许多信息可以在博客后台的个人配置与网页配置中定制）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## 清理掉部分社交信息
ghost-theme-kaldorei/partials/social.hbs  
ghost-theme-kaldorei/partials/post_author.hbs  
## 我移除掉了标签数量的统计
ghost-theme-kaldorei/partials/site_stat.hbs  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="715"&gt;7.1.5 在博客文章中显示作者信息&lt;/h4&gt;

&lt;p&gt;kaldorei主题并没有特别强调多作者博客的功能，所以它的文章（post）中只显示标签云，而不显示该文章的作者信息。因此我添加了这一功能，但需要做的修改极少：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!-- modify file at ./ghost-theme-kaldorei/partials/sidebar.hbs --&amp;gt;  
&amp;lt;!-- 注意在下面位置的is标签后面，多添加一个post参数，就可以了 --&amp;gt;  
    {{! 作者：显示作者信息 }}
    {{#is "author, post"}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于多作者博客的支持，我打算另开一篇博文来讲。&lt;/p&gt;

&lt;p&gt;^^.&lt;/p&gt;

&lt;h4 id="716"&gt;7.1.6 修改语法高亮&lt;/h4&gt;

&lt;p&gt;在default.hbs中载入新的highlight style即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!-- kaldorei的缺省风格是monokai-sublime.css, 在styles目录下找个新的换上就Ok --&amp;gt;  
&amp;lt;!-- 可以先查看https://highlightjs.org/static/demo/来选择风格 --&amp;gt;  
&amp;lt;link rel="stylesheet" type="text/css" href="{{asset "plugins/highlight-9.1.0/styles/xcode.css"}}" /&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，你可能需要调整高亮代码左侧的行号背景（或其它），那么应修改如下样式表：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-css"&gt;/* modify file at ./ghost-theme-kaldorei/assets/css/screen.css */
.pre-numbering {
    position: absolute;
    ...
}

.pre-numbering li {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="717"&gt;7.1.7 指定文章置顶&lt;/h4&gt;

&lt;p&gt;置顶文章是常见的博客操作，你可以将一篇文章设置为&lt;code&gt;featured&lt;/code&gt;，并且通过修改模板来使它们置顶。这会涉及到不少的修改。&lt;/p&gt;

&lt;p&gt;好在所谓『置顶』操作其实只会发生在带有&lt;code&gt;（列表）list&lt;/code&gt;性质的页面中，这类页面在Ghost中称为&lt;code&gt;paged&lt;/code&gt;，它只出现在以下三类页面上：index, tag and author（&lt;a href="https://themes.ghost.org/docs/paged-context#section-description"&gt;参见这里&lt;/a&gt;）。在这三类页面中，可以用loop模板去列举所有页，但它们的&lt;code&gt;第1页&lt;/code&gt;是paged为false的，而之后的&lt;code&gt;第2..n页&lt;/code&gt;则是paged为true的。可以通过这种区别来将你需要的内容置顶，并在其它页面中筛除它们。&lt;/p&gt;

&lt;p&gt;在具体实现中，由于&lt;code&gt;{{get}}&lt;/code&gt;标记在&lt;code&gt;filter&lt;/code&gt;设置时不能使用包含或查找操作（它能使用的运算支持&lt;a href="https://api.ghost.org/docs/filter"&gt;在这里&lt;/a&gt;），所以tag页不能用index/author页相同的方法来实现置顶。然而此外唯一可能做这个运算的&lt;code&gt;{{has}}&lt;/code&gt;标记却不支持参数传入——所以，你已经知道结果了：在tag页中不支持（按标签分类过的）置顶。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!-- 在loop.hbs中用以下代码分别载入置顶风格的posts --&amp;gt;  
{{^is "paged"}}
    {{! list all feated posts on top }}
    {{#is "index"}}
    {{#get "posts" filter="featured:true" limit="all" include="tags" as |featured|}}
    {{#foreach featured}}
        {{&amp;gt; content_featured}}
    {{/foreach}}
    {{/get}}
    {{/is}}

    {{#is "author"}}
    {{#get "posts" filter="featured:true+author:{{author.slug}}" limit="all" include="tags" as |featured|}}
    {{#foreach featured}}
        {{&amp;gt; content_featured}}
    {{/foreach}}
    {{/get}}
    {{/is}}
{{/is}}

&amp;lt;!-- 紧接着载入普通风格的posts --&amp;gt;  
    {{#foreach posts}}
    {{#is "tag"}}
        {{&amp;gt; content_post}}
    {{else}}
        {{#unless featured}}
        {{&amp;gt; content_post}}
        {{/unless}}
    {{/is}}
    {{/foreach}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;partials/content_featured.hbs&lt;/code&gt;和&lt;code&gt;partials/content_post.hbs&lt;/code&gt;中分别设置两种样式即可。——可以将原来在loop.hbs中&lt;code&gt;foreach posts&lt;/code&gt;的代码块直接接到&lt;code&gt;partials/content_post.hbs&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;最后，一些细节可以参考这里：&lt;a href="https://www.ghostforbeginners.com/move-featured-posts-to-the-top-of-your-blog/"&gt;Move Featured Posts to the Top of your Blog&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id="72"&gt;7.2 将站点信息与云标签静态化&lt;/h3&gt;

&lt;p&gt;Ghost博客静态化有一个小的问题，就是如果你加上了类似『站点状态(site_stat)』或『标签云(tag_cloud)』这样的功能的话，那么你几乎每添加或修改一篇文章，就要全部重新生成静态页，然后再重新Push到github仓库——每次都全站发布一回。&lt;/p&gt;

&lt;p&gt;原因是这样，比如说你的site_stat里有一个『站点发表了多少篇文章』的计数，那么，显然你添加/删除一篇博客，就得让所有静态面这个位置的计数变一下；又例如标签名，你添加一个标签那么全站所有页的标签云都要动态生成一下。&lt;/p&gt;

&lt;p&gt;而事实上——99%的博客文章或静态页面在内容上都没有什么变化 。所以，能不能将这些动态变化的信息静态化掉，不至于每次都要重新生成？&lt;/p&gt;

&lt;p&gt;是能的。我采用的策略是：用js装载这些静态化的信息。&lt;/p&gt;

&lt;h4 id="721"&gt;7.2.1 为标签云添加一个静态页&lt;/h4&gt;

&lt;p&gt;在博客后台添加一篇新的博客，将它的页面url设置成tag_cloud，并配配置它为静态页面（参见『历史归档』的做法，&lt;a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei#开启归档功能"&gt;在这里&lt;/a&gt;）。这一篇博客的内容可以为空。&lt;/p&gt;

&lt;p&gt;然后在&lt;code&gt;content/themes/ghost-theme-kaldorei/&lt;/code&gt;目录下新添加一个名为&lt;code&gt;page-tag-cloud.hbs&lt;/code&gt;的模板——它将是上面这篇文章的专用模板，Ghost是通过文件名来识别的。内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;document.writeln(function cloudTagHtmlContext() {/*  
  {{&amp;gt; "tag_cloud"}}
*/}.toString().replace(/^[^\*]+\*+|\*+[^\*]+$/g, ''));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，这是一段标准的JavaScript代码，并且事实上只有一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;document.writeln(...);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当Ghost将在后台把&lt;code&gt;page-tag-cloud.hbs&lt;/code&gt;当成标准的模板文件来处理，所以它会填充其中的Ghost标志，并装载子模板页。而生成出来的静态页实际上是一个.js的文本文件，并且放在（我们在对应博客文章后台配置的）&lt;code&gt;/tag_cloud&lt;/code&gt;这个位置上——不过没有扩展名而已。&lt;/p&gt;

&lt;p&gt;这段脚本的作用仅仅是将cloudTagHtmlContext()这个函数（也可以是匿名函数）中的内容取出来，然后写在网页上。&lt;/p&gt;

&lt;p&gt;这段代码总是通用的，可以用来将任意模板/网页转换成这样一个脚本文件，以便于动态装载。&lt;/p&gt;

&lt;h4 id="722"&gt;7.2.2 修改其它模板以装入上述脚本&lt;/h4&gt;

&lt;p&gt;这很简单，在sitebar.hbs这个文件中找到&lt;code&gt;{{&amp;gt; "tag_cloud"}}&lt;/code&gt;，然后替换成下面的即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!-- modify file at ./ghost-theme-kaldorei/partials/sidebar.hbs --&amp;gt;  
&amp;lt;!-- 找到{{&amp;gt; "tag_cloud"}}然后替换成下面的脚本 --&amp;gt;  
&amp;lt;script type="text/javascript" src="/tag-cloud"&amp;gt;&amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="723site_stat"&gt;7.2.3 关于site_stat&lt;/h4&gt;

&lt;p&gt;与tag_cloud的处理类似，我添加了&lt;code&gt;/profile_site&lt;/code&gt;静态页，并且添加模板如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;// file at ghost-theme-kaldorei/page-profile-site.hbs
document.writeln(function cloudTagHtmlContext() {/*  
    &amp;lt;hr&amp;gt; {{&amp;gt; "site_stat"}}
    &amp;lt;hr&amp;gt; {{&amp;gt; "social"}}
*/}.toString().replace(/^[^\*]+\*+|\*+[^\*]+$/g, ''));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，最后你需要改一下&lt;code&gt;partials/profile.hbs&lt;/code&gt;相应位置来装载&lt;code&gt;/profile_site&lt;/code&gt;这个脚本文件。&lt;/p&gt;

&lt;h3 id="73"&gt;7.3 其它&lt;/h3&gt;

&lt;p&gt;事实上我现在仍然是采用每次都全站生成静态页面来更新整个网站，因此上面的有关『静态化』的处理并不能带来直接的便利。但我的确打算发布一个『只更新最新内容』的小工具，这样网站Online就会变得快些了。&lt;/p&gt;

&lt;p&gt;不同的主题的修改会略有区别，本文只供参考。&lt;/p&gt;</content:encoded></item><item><title>手记2：从本地博客到Github Pages的最佳指南及工具</title><description>&lt;p&gt;现在你来到了Ghost的世界（或别的什么本地博客系统），怎么写博客以及格式等等问题都是这个博客系统的问题了，你应该去搜搜相关的教程。就我来说，Ghost挺好用的，偶尔还有些很便利使用的小惊喜。&lt;/p&gt;

&lt;p&gt;如果你成功的导入了历史博客（或者你只是随手写了几篇），那么现在你面临的问题是：怎么把它放到网上去。当然可以是某个免费主页空间（只需要静态的就可以了），也可以是——比如我选择的就是Github Pages。这样一来，就可以有一个名为&lt;code&gt;xxxxxx.github.io&lt;/code&gt;的博客地址了，而且博客文章和维护等等都使用Github的后台或Git命令行，又熟悉又自然，对吧。&lt;/p&gt;

&lt;h2 id="4github"&gt;4. Github开工&lt;/h2&gt;

&lt;p&gt;你得先有Github账号。然后，创建一个名为&lt;code&gt;xxxxxx.github.io&lt;/code&gt;的仓库。最后，你进入这个仓库，在仓库的Settings（注意不是你的帐户的Settings）中找到&lt;code&gt;GitHub Pages&lt;/code&gt;，检查一下，他可能已经缺省写着：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Your site is published at https://xxxxxx.&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;</description><link>http://aimingoo.github.io/1-1720/</link><guid isPermaLink="false">16433c0c-40f9-4978-9fe3-f56cb56b2102</guid><category>博客</category><category>Ghost</category><category>Github</category><category>OpenSource Project</category><dc:creator>aimingoo</dc:creator><pubDate>Fri, 26 May 2017 18:02:33 GMT</pubDate><content:encoded>&lt;p&gt;现在你来到了Ghost的世界（或别的什么本地博客系统），怎么写博客以及格式等等问题都是这个博客系统的问题了，你应该去搜搜相关的教程。就我来说，Ghost挺好用的，偶尔还有些很便利使用的小惊喜。&lt;/p&gt;

&lt;p&gt;如果你成功的导入了历史博客（或者你只是随手写了几篇），那么现在你面临的问题是：怎么把它放到网上去。当然可以是某个免费主页空间（只需要静态的就可以了），也可以是——比如我选择的就是Github Pages。这样一来，就可以有一个名为&lt;code&gt;xxxxxx.github.io&lt;/code&gt;的博客地址了，而且博客文章和维护等等都使用Github的后台或Git命令行，又熟悉又自然，对吧。&lt;/p&gt;

&lt;h2 id="4github"&gt;4. Github开工&lt;/h2&gt;

&lt;p&gt;你得先有Github账号。然后，创建一个名为&lt;code&gt;xxxxxx.github.io&lt;/code&gt;的仓库。最后，你进入这个仓库，在仓库的Settings（注意不是你的帐户的Settings）中找到&lt;code&gt;GitHub Pages&lt;/code&gt;，检查一下，他可能已经缺省写着：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;Your site is published at https://xxxxxx.github.io/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;OK。建议你将Features中的&lt;code&gt;Wikis&lt;/code&gt;与&lt;code&gt;Restrict editing to collaborators only&lt;/code&gt;设为关闭，而&lt;code&gt;Issues&lt;/code&gt;建议开启——我相信你用得到它。&lt;/p&gt;

&lt;p&gt;最后，你还可以在&lt;code&gt;Theme chooser&lt;/code&gt;中选一个Theme。不过对我来说没什么意义，因为我将使用Ghost中的Theme。不过，如果你使用了Github的Theme，那么你的主页根目录——也就是&lt;code&gt;xxxxxx.github.io&lt;/code&gt;这个仓库的根目录下就会多一个&lt;code&gt;_config.yml&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;此外，还总是会有一个&lt;code&gt;README.md&lt;/code&gt;文件，知道Github的人都知道这个文件用来做什么，建议你留着——尽管删除掉也没什么影响。&lt;/p&gt;

&lt;p&gt;除了上述两个文件，Github什么都没给你，一切都得自己来干。&lt;/p&gt;

&lt;p&gt;当然，只要你创建了这个仓库，那么&lt;code&gt;https://xxxxxx.github.io&lt;/code&gt;就已经可以访问了；如果你更新这个仓库，那么网站也就自动更新了。&lt;/p&gt;

&lt;p&gt;很酷。&lt;/p&gt;

&lt;h2 id="5githubpages"&gt;5. 从本地博客到Github Pages&lt;/h2&gt;

&lt;p&gt;尽管几乎所有的Ghost用户都被推荐使用Buster来生成静态页（generate static pages），但这个工具确实相当不好用，按某博主所说『&lt;strong&gt;是个大坑&lt;/strong&gt;』，不过我也建议你看看他的博客文章（&lt;a href="https://mrcotter.github.io/ghost-to-github-pages/"&gt;在这里&lt;/a&gt;），写得很细致了。不过如果你不怎么用Python的话，我建议你不要安装pyenv和多版本的python，直接用MacOSX原装的就好——或者只用Brew安装Python 2.x。&lt;/p&gt;

&lt;p&gt;参考上面这位博主（&lt;a href="https://mrcotter.github.io/author/kris/"&gt;Kris Cotter&lt;/a&gt;）的文章，我写了一个名为&lt;code&gt;makesite.sh&lt;/code&gt;的脚本，它配合Buster使用，并主要用来填Buster的一些坑。下面说说这个工具。&lt;/p&gt;

&lt;h3 id="51makesitesh"&gt;5.1 使用makesite.sh的标准过程&lt;/h3&gt;

&lt;p&gt;参考下面的控制台命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;## 取一份你的Github Pages仓库，例如(YOURNAME/YOURNAME.github.io)
&amp;gt; git clone https://github.com/YOURNAME/YOURNAME.github.io
&amp;gt; cd ./YOURNAME.github.io

## 定制一下git exclude files
&amp;gt; echo -e '\nstatic/\nmakesite.sh\npatchme.sh\nbuster.log’ &amp;gt;&amp;gt; .git/info/exclude

## 下载makesite.sh文件到本地仓库
&amp;gt; wget -nv 'https://github.com/aimingoo/ghost-utils/raw/master/makesite.sh'

## 使用帮助
&amp;gt; bash makesite.sh --help
###########################################################################
 Usage:
  &amp;gt; bash makesite.sh --generate --reset-domain --short-path --deploy-now
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面列举了makesite.sh对&lt;code&gt;Ghost -&amp;gt; Github Pages&lt;/code&gt;的一个标准过程的理解，亦即是分成四步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;generate: 调用Buster生成静态页&lt;/li&gt;
&lt;li&gt;reset-domain: 重置本地博客的domain到远端（YOURNAME.github.io）&lt;/li&gt;
&lt;li&gt;short-path: 生成简短的网页路径&lt;/li&gt;
&lt;li&gt;deploy-now: 部署到Github仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以使用参数来开启或关闭任何一个步骤，或者从任何一个步骤开始（而无视于其它步骤）。缺省情况下所有的步骤都是关闭的，只检查一下当前目录下是否存在&lt;code&gt;./static&lt;/code&gt;子目录。——注意这个目录是被保留，不被提交到Github仓库中去的（所以前面的脚本中我将它添加到了&lt;code&gt;.git/info/exclude&lt;/code&gt;文件中）。&lt;/p&gt;

&lt;p&gt;整个过程需要依赖&lt;code&gt;git&lt;/code&gt;和&lt;code&gt;buster&lt;/code&gt;两个工具，另外需要&lt;code&gt;wget&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;和MacOSX版本的&lt;code&gt;sed&lt;/code&gt;。如果你是在别的系统上运行这个脚本，你"可能"需要改一下sed的命令行参数。&lt;/p&gt;

&lt;p&gt;如果你只是生成静态页而不部署它，那么你不需要使用&lt;code&gt;--deploy-now&lt;/code&gt;参数，这种情况下没有安装git也是可以的。但我总是建议你先安装buster：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;## 使用Python的PIP安装buster
&amp;gt; pip install buster

## 如果你没有wget或git
&amp;gt; brew install wget git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="52makesitesh"&gt;5.2 makesite.sh的配置与参数&lt;/h3&gt;

&lt;p&gt;如果你读makesite.sh的源代码，你会发现它处理参数的代码非常漂亮（嘿~嘿~）。&lt;/p&gt;

&lt;p&gt;这些参数可以有两种格式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--reset-domain=false&lt;/code&gt;：指定reset-domain参数值为false。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--reset-domain&lt;/code&gt;：这种省略掉值的情况，等效于&lt;code&gt;--reset-domain=true&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也可以指定字符串值，例如设置你的domain（缺省值是我的"aimingoo.github.io"）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;--domain='YOURNAME.github.io'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所有通过命令行参数传入的参数配置，都有相对应的bash变量（全大写字符），所以你也可以直接修改.sh脚本中的变量缺省值，以避免每次都要通过命令行指定（例如，尤其是&lt;code&gt;--domain&lt;/code&gt;和&lt;code&gt;--generate-info&lt;/code&gt;这样的参数）。&lt;/p&gt;

&lt;p&gt;由于通常你都需要配置自己的domain参数，所以我没有将makesite.sh写成通用脚本，而是建议你每个Github本地仓库下载一份独立的，并修改其中DOMAIN变量的缺省值。&lt;/p&gt;

&lt;p&gt;也正是因此，它也被加入了git的排除文件列表。&lt;/p&gt;

&lt;h2 id="6"&gt;6. 填了哪些坑？&lt;/h2&gt;

&lt;p&gt;前面说过makesite.sh用来填Buster的一些坑的。但填了哪些坑呢？下面讲讲技术问题。&lt;/p&gt;

&lt;h3 id="61busterwget"&gt;6.1 Buster调用wget时的参数问题&lt;/h3&gt;

&lt;h4 id="611buster5pages"&gt;6.1.1 Buster其实只帮你抓5页Pages&lt;/h4&gt;

&lt;p&gt;如果你的博客很多，有很多的分页（比如我的就有五十多页），那么你很容易就发现其实Buster只帮你抓了其中的5页——很郁闷吧。&lt;/p&gt;

&lt;p&gt;这是因为Buster调用wget来抓取页面，而它在递归下载时默认搜索的递归尝试就是5层，这个需要修改&lt;code&gt;--level&lt;/code&gt;参数。&lt;/p&gt;

&lt;h4 id="612"&gt;6.1.2 你可能需要忽略掉一些抓取页面&lt;/h4&gt;

&lt;p&gt;Ghost默认会帮你生成很多东西，有SEO用的amp文件、sitemap文件或rss文件，又例如最新的ld+json数据。然而你不见得都需要用到，其中最严重的就是amp，因为这相当于你生成了两份博客，所以我们需要用&lt;code&gt;--reject-regex&lt;/code&gt;来忽略掉它。&lt;/p&gt;

&lt;p&gt;还有一种情况非常特殊。在Ghost博客里，tag页可能有两种url（事实上所有的页面都会有这两种页）：&lt;code&gt;/tags/XXX&lt;/code&gt;和&lt;code&gt;tags/XXX/&lt;/code&gt;。别小看多出来的这个斜杠&lt;code&gt;/&lt;/code&gt;：当wget访问&lt;code&gt;/XXX&lt;/code&gt;页时，它是将url理解为文件的，因此将要写入的是文件XXX（如果加上&lt;code&gt;--adjust-extension&lt;/code&gt;参数那么就写入XXX.html）；而访问&lt;code&gt;/XXX/&lt;/code&gt;时，wget认为它访问的是目录，所以也就会尝试创建XXX这个目录并写入&lt;code&gt;./XXX/index.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;然而我们设想一个问题：如果一个网站中既有&lt;code&gt;/tags/XXX&lt;/code&gt;又有&lt;code&gt;tags/XXX/&lt;/code&gt;，那么当wget先找到前者的时候，就会在当前目录下写一个XXX文件，而下一次它找到后一种的时候，会发生什么呢？&lt;/p&gt;

&lt;p&gt;这有三种可能性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果有XXX目录，而又要创建XXX文件的话，wget会创建一个名为XXX.1的文件；&lt;/li&gt;
&lt;li&gt;如果反过来是有XXX文件的情况下，
&lt;ul&gt;&lt;li&gt;需要再创建./XXX/目录，那么wget直接覆盖XXX文件，于是旧的XXX文件丢失，多出来一个新的XXX目录；&lt;/li&gt;
&lt;li&gt;需要创建&lt;code&gt;./XXX/yyy/index.html&lt;/code&gt;这样的子级目录中的文件的话，那么很不幸，wget抛出一个异常&lt;code&gt;./XXX/yyy : Not a directory&lt;/code&gt;，写文件不成功。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，我们需要忽略掉一些抓取页面，因为他们可能先于一个目录创建之前要写入，又或者与已写入的文件冲突，再或者根本就是多余的、重复的页。&lt;/p&gt;

&lt;h4 id="613busterpy"&gt;6.1.3 不修改buster.py的做法&lt;/h4&gt;

&lt;p&gt;为了不修改Buster的源代码，我在makesite.sh中定义了一个名为wget的函数，并且在当前进程中导出它。这样一来，由于Buster是由makesite.sh这个shell脚本launch起来的，那么当它调用wget下载的时候，就调用了我们在程序中修改过的版本。&lt;/p&gt;

&lt;p&gt;——这是一种在当前脚本中打patch的方法（可以不修改buster.py的源代码）。基本的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;##
## 参见makesite.sh源代码
##

## 声明函数并追加参数
function wget { $RAW_WGET --level=0 inf --reject-regex=... }

## 取原始的wget的路径并导出到当前环境中
export RAW_WGET=`which wget`

## 将wget函数导出到当前环境中
export -f wget

## 调用buster，这时buster将使用我们在代码中声明的wget函数来下载
buster ...  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="62"&gt;6.2 移除版本号&lt;/h3&gt;

&lt;p&gt;在新近一些的前端技巧中，为JavaScript和CSS文件加上版本号已经是很流行的做法了。然而这意味着Buster抓取的文件会存成类似&lt;code&gt;shared/ghost-url.js?v=3edb33f1b1&lt;/code&gt;这样的名字。&lt;/p&gt;

&lt;p&gt;所以在makesite.sh中有两行代码来对&lt;code&gt;assets&lt;/code&gt;和&lt;code&gt;shared&lt;/code&gt;目录中的资源做更名，以移除这种版本号：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;## 移除assets目录中的资源版本号
&amp;gt; find static/assets -name '*\?*' -type f -exec sh -c "echo '{}' | sed 's|\?.*$||' | xargs -I[] mv '{}' '[]'" \;

## 移除shared目录中的资源版本号(通常只有/ghost-url.js这个文件)
&amp;gt; find static/shared -name '*\?*' -type f -exec sh -c "echo '{}' | sed 's|\?.*$||' | xargs -I[] mv '{}' '[]'" \;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="63resetdomainshortpath"&gt;6.3 从reset-domain到short-path&lt;/h3&gt;

&lt;p&gt;reset-domain是&lt;a href="https://mrcotter.github.io/author/kris/"&gt;Kris Cotter&lt;/a&gt;最早版本代码中的功能，简单地说就是将Buster下载的网页文件中残留的&lt;code&gt;localhost:2368&lt;/code&gt;再做一次替换，所以我将这个过程叫做reset-domain。&lt;/p&gt;

&lt;p&gt;事实上wget的&lt;code&gt;--convert-links&lt;/code&gt;参数做过一次高性能的链接转换，但这远远不够——这些转换基于wget的html parser中对"链接"的定义（可以参见tag&lt;em&gt;attr html&lt;/em&gt;allow这个数据结构，位于wget源码html.c中）。而reset-domain针对的是可能存在的文本替换——而无论对象是否是.html，或者是否是真实的url链接。&lt;/p&gt;

&lt;p&gt;经过这两轮的处理（generate和reset-domain）之后，事实上整个&lt;code&gt;./static&lt;/code&gt;目录下的文件已经可以作为静态页发布了。确切地说，你已经可以使用下面的命令来部署本地git仓库，将它推到你的主页&lt;code&gt;YOURNAME.github.io&lt;/code&gt;中去了：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; bash makesite.sh --deploy-now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而makesite.sh脚本还在这个操作之前插入了一个&lt;code&gt;--short-path&lt;/code&gt;——我想你已经注意到这一点了。&lt;/p&gt;

&lt;p&gt;这个short-path的目的是将Ghost生成的类似于&lt;code&gt;/your--post-full-title----as-slug/index.html&lt;/code&gt;这样长的“目录名+文件名”变得短一些。它基本的想法就是让主页根目录下不要太多的目录，因此将这些目录中的index.html上移到它们的父目录中——对于所有的posts来说，其实也就是根目录下。&lt;/p&gt;

&lt;p&gt;这个过程其实有一个更好的解决方案，就是将所有这些文件移入到&lt;code&gt;/posts/your--post-full-title----as-slug.html&lt;/code&gt;，这样一来主页根目录下就只有一个posts目录了。我尝试过，但之后放弃了，因为我写不出一个有效的正则表达式来替换所有“其它”页面中的url——到该页面的新位置。&lt;/p&gt;

&lt;p&gt;好吧，总而言之，我们做了一点工作（尽管实际上这是效率最低的一个步骤）。所以你还是可以在部署之前尝试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;&amp;gt; bash makesite.sh --short-path
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="631url"&gt;6.3.1 更短的url&lt;/h4&gt;

&lt;p&gt;我的主页&lt;code&gt;aimingoo.github.io&lt;/code&gt;中其实使用的是更短的url地址，而并不是Ghost中缺省地按照文章标题通过拼音转换而来——后面这种文件名生成得太长太难看了。这种『更短的url』其实是通过为每个post设置它独自的slug属性而得到的，这需要为每篇文章在Ghost后台管理界面去编辑Post的属性。&lt;/p&gt;

&lt;p&gt;这也是上一篇博客中提到的&lt;code&gt;putrefy.js&lt;/code&gt;这个工具（&lt;a href="https://github.com/aimingoo/ghost-utils"&gt;在这里&lt;/a&gt;）中会有一个&lt;code&gt;SLUG_FROMID&lt;/code&gt;参数的原因。当配置这个参数为true时，你从旧博客中导入的文章就将自动地以&lt;code&gt;author_id&lt;/code&gt;作为前缀，并加上post_id作为slug了——我的博客就是用这种方法来导入的。当然，你也可以将&lt;code&gt;SLUG_FROMID&lt;/code&gt;配置为别的什么字符串来作为前缀。&lt;/p&gt;

&lt;p&gt;但是，你在Ghost后台新添加的文章，就需要你手工地改slug了。这个今后我会发布个小工具来自动化的，这里暂且不提。&lt;/p&gt;

&lt;h3 id="64patchmesh"&gt;6.4 关于patchme.sh&lt;/h3&gt;

&lt;p&gt;这是在makesite.sh中留下的一小处补丁程序。你可以编写一段shell代码（放在makesite.sh同目录中就可以了），让makesite.sh在正式地deploy-now操作之前，由你自己来对&lt;code&gt;./static&lt;/code&gt;目录中的页面做些修补。这偶尔也是必要的，例如我现在这篇文章是在介绍Ghost，那就不可避免地会用到&lt;code&gt;localhost:2368&lt;/code&gt;这样的url地址，而按照Buster和makesite.sh的规则，它们就可能被替换成线上Github仓库中的地址了——所以需要one by one地patch。&lt;/p&gt;

&lt;p&gt;当然，你也可以写点别的什么代码。&lt;/p&gt;

&lt;p&gt;尤其是……程序员总想干点什么黑活之类的啦。&lt;/p&gt;

&lt;p&gt;你懂的。&lt;/p&gt;</content:encoded></item><item><title>手记1：迁移博客之全程工具</title><description>&lt;p&gt;在这一系列的博客中，我将仔细地记录我搭建这个博客的全部过程、工具，以及诸多技巧。&lt;/p&gt;

&lt;h2 id="1blogtowordpress"&gt;1. 如何迁移你的博客 - 推荐BlogToWordpress&lt;/h2&gt;

&lt;p&gt;确实有很多工具来帮助你将历史、陈旧的博客迁到某个地方，而相对来说比较新的做法，就是将博客全文导出，然后按某种格式生成成静态的页面——于是你就有了新的博客站点。&lt;/p&gt;

&lt;p&gt;然而事实上并不那么容易——这些工具分种种流派以及不同的实现语言。有幸的是，综合这些尝试，我们可以找到一个较简单而又完整的工具链条：从旧博客转到markdown文件，然后再将markdown导入到新博客中去。&lt;/p&gt;

&lt;p&gt;在从旧博客到markdown的转换过程中，还存在一种中间格式，就是标准的Wordpress导出文件格式，这是一种.xml文件。Wordpress是一种在国外受到广泛支持的博客系统，因此相关的工具集非常丰富。通过相当长时间的搜索、分析与比较，我得到了一个最终可用的工具集。如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过BlogToWordpress来将旧博客转到Wordpress导出文件
&lt;ul&gt;&lt;li&gt;它支持sina、sohu、csdn、163、baidu、天涯博客等等很多种国内的博客。&lt;/li&gt;
&lt;li&gt;它会抓取图片等文件作为附件保存到指定目录。&lt;/li&gt;
&lt;li&gt;cnblogs或其它博客可以考虑先用工具转成markdown文件的方法，例如使用&lt;a href="https://github.com/yanyingwang/cnblog2jekyll"&gt;cnblog2jekyll&lt;/a&gt;中的generate&lt;em&gt;markdown&lt;/em&gt;all。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通过wp2md来将Wordpress导出的.xml转换到Markdown格式.md
&lt;ul&gt;&lt;li&gt;我最终使用的是Ghost博客系统，&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>http://aimingoo.github.io/1-1719/</link><guid isPermaLink="false">b3d847c3-85a6-489c-bfee-e8096c3c884c</guid><category>博客</category><category>Javascript</category><category>Ghost</category><dc:creator>aimingoo</dc:creator><pubDate>Tue, 23 May 2017 05:38:05 GMT</pubDate><content:encoded>&lt;p&gt;在这一系列的博客中，我将仔细地记录我搭建这个博客的全部过程、工具，以及诸多技巧。&lt;/p&gt;

&lt;h2 id="1blogtowordpress"&gt;1. 如何迁移你的博客 - 推荐BlogToWordpress&lt;/h2&gt;

&lt;p&gt;确实有很多工具来帮助你将历史、陈旧的博客迁到某个地方，而相对来说比较新的做法，就是将博客全文导出，然后按某种格式生成成静态的页面——于是你就有了新的博客站点。&lt;/p&gt;

&lt;p&gt;然而事实上并不那么容易——这些工具分种种流派以及不同的实现语言。有幸的是，综合这些尝试，我们可以找到一个较简单而又完整的工具链条：从旧博客转到markdown文件，然后再将markdown导入到新博客中去。&lt;/p&gt;

&lt;p&gt;在从旧博客到markdown的转换过程中，还存在一种中间格式，就是标准的Wordpress导出文件格式，这是一种.xml文件。Wordpress是一种在国外受到广泛支持的博客系统，因此相关的工具集非常丰富。通过相当长时间的搜索、分析与比较，我得到了一个最终可用的工具集。如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过BlogToWordpress来将旧博客转到Wordpress导出文件
&lt;ul&gt;&lt;li&gt;它支持sina、sohu、csdn、163、baidu、天涯博客等等很多种国内的博客。&lt;/li&gt;
&lt;li&gt;它会抓取图片等文件作为附件保存到指定目录。&lt;/li&gt;
&lt;li&gt;cnblogs或其它博客可以考虑先用工具转成markdown文件的方法，例如使用&lt;a href="https://github.com/yanyingwang/cnblog2jekyll"&gt;cnblog2jekyll&lt;/a&gt;中的generate&lt;em&gt;markdown&lt;/em&gt;all。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通过wp2md来将Wordpress导出的.xml转换到Markdown格式.md
&lt;ul&gt;&lt;li&gt;我最终使用的是Ghost博客系统，所以我使用wp2ghost来直接转换成了Ghost支持的导入格式.json&lt;/li&gt;
&lt;li&gt;Ghost也支持单篇或多篇.md格式文章的导入，后面会讲到使用.md的方法&lt;/li&gt;
&lt;li&gt;你不必非得使用Ghost博客系统，多数新的博客系统都支持Wordpress的.xml导出文件或者独立的.md文件。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BlogToWordpress的支持站点在这里：&lt;a href="http://www.crifan.com/crifan_released_all/website/python/blogstowordpress/"&gt;Crifan的BlogsToWordPress&lt;/a&gt; ，但是下载是放在SourceForge上的：&lt;a href="https://sourceforge.net/projects/blogstowordpress"&gt;https://sourceforge.net/projects/blogstowordpress&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;BlogToWordpress需要Python 2.7.2或2.x，并且需要以下依赖包/库：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python Imaging Library (PIL) &lt;/li&gt;
&lt;li&gt;crifanLib&lt;/li&gt;
&lt;li&gt;chardet，推荐chardet 1.0.1&lt;/li&gt;
&lt;li&gt;BeautifulSoup，推荐BeautifulSoup-3.0.6.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了PIL之外其它三个包/库已经包含在BlogsToWordpress的发布包(v18.3)里了，而PIL是可选安装的（只是在极少数情况下才会用到）。所以，总的来说BlogsToWordpress也是即解压即用的。&lt;/p&gt;

&lt;p&gt;我在mac上使用的命令如下（SourceForge上也有windows .exe版本，可以尝试）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 1. 下载BlogsToWordPress
&amp;gt; curl -L 'https://sourceforge.net/projects/blogstowordpress/files/v18.3/BlogsToWordpress_v18.3_2014-05-23.7z/download' -o BlogsToWordpress_v18.3_2014-05-23.7z
&amp;gt; 7z x BlogsToWordpress_v18.3_2014-05-23.7z

# 2. 生成调用Stub shell script
&amp;gt; echo 'python BlogsToWordpress.py --maxXmlSize 0 --googleTrans no --wpPicPath "/bkImages" -s "$1"' &amp;gt; runner.sh

# 3. 运行脚本
&amp;gt; bash runner.sh "http://blog.sina.com.cn/aimingoo" | tee BlogsToWordpress.log

# 4. 归并文件到目录中
#    - BlogsToWordPress根据url中的UserName部分来生成下载文件的目录，本例中是aimingoo
#    - 脚本中指定的wpPicPath参数会使.xml中的图片url修正，但下载文件仍然是在aimingoo/pic目录中，所以需要更名
&amp;gt; mv WXR_*.xml aimingoo/
&amp;gt; mv BlogsToWordpress.log aimingoo/
&amp;gt; mv aimingoo/pic aimingoo/bkImages
&amp;gt; mv aimingoo blog.sina.com.cn-aimingoo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你需要处理更多的博客网站，那么只需要重复第3~4步即可。&lt;/p&gt;

&lt;h2 id="2ghost"&gt;2. 用本地博客导入 - 例如Ghost&lt;/h2&gt;

&lt;p&gt;如果你得到的是一批Markdown格式（.markdown或.md）的文件，以及用相对目录来保存的图片等附件——注意Ghost使用导入时也支持绝对路径，那么你可以直接将它们导入到支持该格式的本地博客中，例如Ghost。&lt;/p&gt;

&lt;h3 id="21"&gt;2.1 搭建本地博客&lt;/h3&gt;

&lt;p&gt;所谓本地博客，就是一个你在的电脑上运行的，在浏览器中可以使用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;http://localhost/ ...&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;来浏览的博客系统。我们下面就用Ghost来搭一个。&lt;/p&gt;

&lt;p&gt;我在mac上使用的命令如下（应该可以在Windows上安装nodejs并搭建Ghost，但我没有试过）：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 获取和解压Ghost
&amp;gt; curl -L https://ghost.org/zip/ghost-latest.zip -o ghost.zip
&amp;gt; unzip -uo ghost.zip -d ghost
&amp;gt; cd ghost

# 使用npm来安装Ghost
#    - 如果你没有安装brew，那么参考下面的地址安装一份先
#    - https://brew.sh/index_zh-cn.html
&amp;gt; brew install node
&amp;gt; npm install --production

# 将Ghost运行在开发者模式上
&amp;gt; npm start
Ghost is running in development...  
Listening on 127.0.0.1:2368  
Url configured as: http://aimingoo.github.io  
Ctrl+C to shut down  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="22"&gt;2.2 准备导入文件&lt;/h3&gt;

&lt;p&gt;我们之前已经得到了从旧博客网站中导出的两类文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Wordpress导出格式的*.xml，以及（有可能的）bkImages目录；或&lt;/li&gt;
&lt;li&gt;一批Markdown格式的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你直接使用Markdown文件，那么将它们打包在一个.zip文件中即可。如果你使用.xml，那么需要先用wp2ghost来做一下转换（你也可以考虑通过其它工具直接转换成.md）。&lt;/p&gt;

&lt;p&gt;使用wp2ghost的好处是它生成的是.json文件，方便我们用其它工具或简单脚本来做进一步的检测、优化或其它处理。例如我写了一个脚本来做下面这些事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将url-encode的文本解码成可读格式：有些文章的标题或tags都使用了编码，直接导入Ghost是没法看的&lt;/li&gt;
&lt;li&gt;移除多余的tags：有些博客的tags是parse文章得到的，茫茫多&lt;/li&gt;
&lt;li&gt;修正author id：博客中的作者与Ghost中作者是没有对应关系的，需要修正&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等。&lt;/p&gt;

&lt;p&gt;下面的示例说明对.xml文件的处理：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 1. 安装wp2ghost
#    - 也可以直接使用git clone ...
&amp;gt; svn export https://github.com/jonhoo/wp2ghost/trunk wp2ghost
&amp;gt; cd wp2ghost
&amp;gt; npm install

# 2. 从Wordpress转换到json文件
#    - 设文件位于~/blog.sina.com.cn-aimingoo中
#    - 注意wp2ghost.js一次只能转换一个文件，下面用*.xml是省掉写文件名
&amp;gt; node bin/wp2ghost.js ~/blog.sina.com.cn-aimingoo/*.xml &amp;gt; ghost-tmp.json

# 3. 切换工作目录
&amp;gt; mv ghost-tmp.json ~/blog.sina.com.cn-aimingoo/
&amp;gt; cd ~/blog.sina.com.cn-aimingoo/

# 4. 获取putrefy.js脚本
#    - 请直接修改putrefy.js源代码，注意它并不是通过命令行参数来配置的
&amp;gt; curl -L https://github.com/aimingoo/ghost-utils/raw/master/putrefy.js -o putrefy.js
&amp;gt; node putrefy.js ghost-tmp.json &amp;gt; ghost.json
&amp;gt; zip -r ghost_archive.zip ghost.json bkImages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议你根据你的博客的需求来修改putrefy.js中的参数配置，某些情况下（例如你要合并多个博客），那么在转换中所需要的putrefy.js脚本会各个不同，因此需要为它们配置各自适用的putrefy.js脚本。&lt;/p&gt;

&lt;p&gt;现在你所得到的&lt;code&gt;ghost_archive.zip&lt;/code&gt;就是Ghost可用的导入文件了。&lt;/p&gt;

&lt;h3 id="23"&gt;2.3 导入到本地博客&lt;/h3&gt;

&lt;p&gt;我们刚刚启动了本地Ghost博客：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 在你的Ghost安装目录中（例如~/ghost）执行如下命令
&amp;gt; npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺省情况下，在你用&lt;code&gt;http://aimingoo.github.io/&lt;/code&gt;访问它时会看到了一个初始状态的博客。你需要为自己建立一个博客账号，登录并管理它。这时，你应该访问&lt;code&gt;http://aimingoo.github.io/ghost/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;建立博客账号的过程中，在第二步（输入你的名字、邮箱和初始密码）时会要求你设置博客的标题，忘掉了也没关系，你可以随时在管理界面的&lt;code&gt;Settings -&amp;gt; General&lt;/code&gt;中去修改它。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/ghost_startup_step-1.png" alt="ghost_startup_step-1"&gt;&lt;/p&gt;

&lt;p&gt;另外，在第三步时会提示你邀请你的博客团队成员（Ghost是一个多人博客平台），请直接跳过忽略。有关这个功能我们将来再讨论——你随时可以在管理界面的&lt;code&gt;Team&lt;/code&gt;功能中发起邀请。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://aimingoo.github.io/content/images/ghost_startup_step-2.png" alt="ghost_startup_step-2"&gt;&lt;/p&gt;

&lt;p&gt;初始化错了也没关系，来到你的Ghost安装目录，删除数据库文件，然后重启Ghost就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;# 你可能需要先用Ctrl + C键退出正在运行的Ghost
#    - 以开发版本模式运行的Ghost是没有驻留在后台的
&amp;gt; rm content/data/ghost-dev.db
&amp;gt; npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们来到&lt;code&gt;Settings -&amp;gt; Labs&lt;/code&gt;中，使用&lt;code&gt;import&lt;/code&gt;将我们此前准备好的.zip文件导入即可。如果一切顺利，你会在左下角看到导入成功的提示；如果失败，红色提示会出现在当前页面的顶端。&lt;/p&gt;

&lt;p&gt;最后，建议你开启&lt;code&gt;Labs -&amp;gt; Enable Beta Features&lt;/code&gt;中的Public API选项，有许多第三方主题需要使用到这些博客功能。&lt;/p&gt;

&lt;h2 id="3ghost"&gt;3. 迁移与Ghost使用小结&lt;/h2&gt;

&lt;p&gt;其它的一些注意事项包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;你创建的第一个博客账号（也就是作为管理员的这个）是不需要验证mail地址的，但使用邀请功能加入的其它账号就需要验证。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导入博客的过程中确实会出现一些意外，这是我写上面提到的&lt;code&gt;putrefy.js&lt;/code&gt;工具的原因。如果你在导入过程中遇到问题，建议你尝试改写这份代码，或者将出问题的导入文件发给我——我尽量替你的博客内容保密，尽管它作为博客原本是公开的。呵呵&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确实有非常多的途径来完成本文中描述的过程，但坦率地说，我尝试过很多了，目前这种算是最……可行的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一旦你将.zip导入到Ghost，你就可以在Ghost管理和更新它们，发布或静态化等等。因此我在后续文章中提到的过程再与传统博客（例如下载、转换的那些文件）就没什么关系了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你备份content整个目录（例如Ghost导入的图片位于&lt;code&gt;./content/images&lt;/code&gt;目录中），那么你可以随时重装Ghost，或者更新至新的版本而不会丢失数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ghost导入的博客文章是可能存在格式问题的，也可能导致你正在使用的Ghost博客主题（缺省是Casper主题，在&lt;code&gt;Settings -&amp;gt; General&lt;/code&gt;中设置）格式混乱或无法使用，请自行编辑它们。我事实上将所有历年文章逐一更新过，并尽量使用了markdown格式——这样以后管理起来就方便了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ghost的数据库在&lt;code&gt;./content/data&lt;/code&gt;目录中，对应于开发版的是&lt;code&gt;content/data/ghost-dev.db&lt;/code&gt;文件。如果你安装过sqlite，那么可以直接用命令行来操作它——或者e用你喜欢的GUI工具也行。例如：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;  &amp;gt; sqlite3 -header -column ghost-dev.db 'select id, name, email from users'
  id          name        email           
  ----------  ----------  ----------------
  1           aimingoo    aiming@gmail.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住这个&lt;code&gt;id = 1&lt;/code&gt;，它是你的管理帐户id。在导入用的ghost.json文件中，它也被称为&lt;code&gt;author_id&lt;/code&gt;，在将来做多账户操作时你可能需要了解它。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于程序员来说这绝对是个好消息，毕竟我们可以直接用SQL来操作所有的博客文章了。例如以前托管的下载地址更新了，但是在哪些文章中用到它们了呢？不错，用like操作去查找一下posts表中的markdown或html字段就可以了。例如：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-bash"&gt;  &amp;gt; sqlite3 ghost-dev.db 'select id, title from posts where markdown like "%skydrive%"'
  1519|《大道至简》的幕后故事：终结篇、勘误和PDF下载
  1595|近期的公开资源汇总(已完整)~
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果你得到上述的&lt;code&gt;id&lt;/code&gt;值，那么可以直接在Ghost的管理界面中去编辑它——Ghost管理界面没有搜索功能。例如直接在浏览器上使用如下地址：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;http://aimingoo.github.io/ghost/editor/1519/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title>再一次开始更新博客</title><description>&lt;h2 id=""&gt;新博客的开张&lt;/h2&gt;

&lt;p&gt;最近在家养病，开始闲出了些工夫，于是决定把之前散落的博客整合起来，以后也有时间做些更新，有个能认真写写文字的地方。&lt;/p&gt;

&lt;p&gt;于是就有了这个在github上的新站。这里把以前在&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新浪博客 - &lt;a href="http://blog.sina.com.cn/aimingoo"&gt;http://blog.sina.com.cn/aimingoo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CSDN博客 - &lt;a href="http://blog.csdn.net/aimingoo"&gt;http://blog.csdn.net/aimingoo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面分开写的内容全部放在了一起。并且接下来会把“麦秸的垛”也逐渐迁移过来。&lt;/p&gt;

&lt;p&gt;新博客使用的是ghost博客系统，使用buster发布成静态网页，然后提交到github和ghpages来做托管。里面涉及到不少的技术细节，所以最近也会发一些文章来介绍这些。&lt;/p&gt;

&lt;p&gt;在整个博客的内容开始稳定更新之前，近期会有一些小的更新会放在本篇文章最后。&lt;/p&gt;

&lt;h3 id="20170520"&gt;2017.05.20&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;全站交付。&lt;/li&gt;
&lt;li&gt;2009年之后的博客文章全部进行了修订。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="20170613"&gt;2017.06.13&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;主要的架构工作和优化全部完成，大部分日常操作工具化。&lt;/li&gt;
&lt;li&gt;准备正式停用在CSDN和SINA上的博客。&lt;/li&gt;
&lt;li&gt;要去日本玩，因此部分工作先暂停。&lt;/li&gt;
&lt;/ul&gt;</description><link>http://aimingoo.github.io/1-1718/</link><guid isPermaLink="false">30c15750-3f8f-423a-bf39-f305763c1425</guid><category>杂谈</category><category>博客</category><dc:creator>aimingoo</dc:creator><pubDate>Sat, 20 May 2017 16:00:48 GMT</pubDate><content:encoded>&lt;h2 id=""&gt;新博客的开张&lt;/h2&gt;

&lt;p&gt;最近在家养病，开始闲出了些工夫，于是决定把之前散落的博客整合起来，以后也有时间做些更新，有个能认真写写文字的地方。&lt;/p&gt;

&lt;p&gt;于是就有了这个在github上的新站。这里把以前在&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新浪博客 - &lt;a href="http://blog.sina.com.cn/aimingoo"&gt;http://blog.sina.com.cn/aimingoo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CSDN博客 - &lt;a href="http://blog.csdn.net/aimingoo"&gt;http://blog.csdn.net/aimingoo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面分开写的内容全部放在了一起。并且接下来会把“麦秸的垛”也逐渐迁移过来。&lt;/p&gt;

&lt;p&gt;新博客使用的是ghost博客系统，使用buster发布成静态网页，然后提交到github和ghpages来做托管。里面涉及到不少的技术细节，所以最近也会发一些文章来介绍这些。&lt;/p&gt;

&lt;p&gt;在整个博客的内容开始稳定更新之前，近期会有一些小的更新会放在本篇文章最后。&lt;/p&gt;

&lt;h3 id="20170520"&gt;2017.05.20&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;全站交付。&lt;/li&gt;
&lt;li&gt;2009年之后的博客文章全部进行了修订。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="20170613"&gt;2017.06.13&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;主要的架构工作和优化全部完成，大部分日常操作工具化。&lt;/li&gt;
&lt;li&gt;准备正式停用在CSDN和SINA上的博客。&lt;/li&gt;
&lt;li&gt;要去日本玩，因此部分工作先暂停。&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>
