<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Aimingoo's Blog]]></title><description><![CDATA[何不乐乐而有哉]]></description><link>http://aimingoo.github.io/</link><image><url>http://aimingoo.github.io/favicon.png</url><title>Aimingoo&apos;s Blog</title><link>http://aimingoo.github.io/</link></image><generator>Ghost 1.14</generator><lastBuildDate>Sun, 15 Oct 2017 06:10:31 GMT</lastBuildDate><atom:link href="http://aimingoo.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[旧文重发：深夜食味记之五 - 回锅肉]]></title><description><![CDATA[<div class="kg-card-markdown"><ul>
<li>（aimingoo  2016.02.21于上海）</li>
</ul>
<blockquote>
<p>在许多年之前我曾经参加了阿里巴巴在武汉的一次校园招聘，当时面试的一个学生水平确实不错，与我谈起各种技术、方向和方法来都头头是道，从BIOS代码到操作系统的启动代码一直到应用开发的许多问题他都能对答得上，还是计算机学会的一个副主席……</p>
<p>然而，总有什么地方不对。</p>
<p>于是我问了他一个问题：你知道回锅肉是怎么做的吗？他愣了一下。然后从我的眼神中读到“确实是这个问题”的信息之后，便又开始回答下去……过了几分钟，我终于拦住了他，说：我们讨论了很多问题，甚至从计算机谈到了烹饪，然而你知道你的回答中多少是正确的吗？</p>
<p>他喃喃了好久，说：也许，有20%吧。</p>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/R169_1_1.1.181_326X580_1_1.1.181_3744X5616_1_1.1.181_3744X5616.jpg" alt=""></p>
<p>我是很爱吃回锅肉的。而且似乎看起来，川人也很少有不爱吃回锅肉的，其吃相还常常不雅：大块肥肉和着蒜苗、青椒或白菜向嘴里送去，顺便还塞入几口米饭，一副十足的狼吐虎咽模样；贪怀的川人这时也不忘猛呷一口酒，在那酒力与油性中解去一日的劳乏。然而即便如此，连爱美惧胖的女孩子们，却也不太能抵挡住这道菜的诱惑。</p>
<p>这也正代表了这道菜普通、家常而又经典的地位，川人会做饭的，大概都会。我父亲考川菜厨师，这第一道菜就是考回锅肉，</p></div>]]></description><link>http://aimingoo.github.io/59e2f91672c9e7b37c383205/</link><guid isPermaLink="false">59e2f91672c9e7b37c383205</guid><category><![CDATA[深夜食味]]></category><category><![CDATA[诗词文章]]></category><category><![CDATA[杂文]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 15 Oct 2017 06:07:51 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><ul>
<li>（aimingoo  2016.02.21于上海）</li>
</ul>
<blockquote>
<p>在许多年之前我曾经参加了阿里巴巴在武汉的一次校园招聘，当时面试的一个学生水平确实不错，与我谈起各种技术、方向和方法来都头头是道，从BIOS代码到操作系统的启动代码一直到应用开发的许多问题他都能对答得上，还是计算机学会的一个副主席……</p>
<p>然而，总有什么地方不对。</p>
<p>于是我问了他一个问题：你知道回锅肉是怎么做的吗？他愣了一下。然后从我的眼神中读到“确实是这个问题”的信息之后，便又开始回答下去……过了几分钟，我终于拦住了他，说：我们讨论了很多问题，甚至从计算机谈到了烹饪，然而你知道你的回答中多少是正确的吗？</p>
<p>他喃喃了好久，说：也许，有20%吧。</p>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/R169_1_1.1.181_326X580_1_1.1.181_3744X5616_1_1.1.181_3744X5616.jpg" alt=""></p>
<p>我是很爱吃回锅肉的。而且似乎看起来，川人也很少有不爱吃回锅肉的，其吃相还常常不雅：大块肥肉和着蒜苗、青椒或白菜向嘴里送去，顺便还塞入几口米饭，一副十足的狼吐虎咽模样；贪怀的川人这时也不忘猛呷一口酒，在那酒力与油性中解去一日的劳乏。然而即便如此，连爱美惧胖的女孩子们，却也不太能抵挡住这道菜的诱惑。</p>
<p>这也正代表了这道菜普通、家常而又经典的地位，川人会做饭的，大概都会。我父亲考川菜厨师，这第一道菜就是考回锅肉，所以网上的传言不虚。然而这道菜其实并没有“十分标准”的做法，譬如我母亲炒出来，便是另一番味道。</p>
<p>这道菜得先从配菜说起。最经典的配菜是蒜苗，非新鲜肥嫩不用，留杆留叶稍为去尖，切段。至于其它候选的配菜，尚有青椒、白菜（包心菜、莲花白）、大肉椒、尖椒、蒜苔、蕨菜、酸菜、干豇豆、萝卜干等等，实在万无可用时，一方豆腐干或是半卷豆腐皮也是可以的。这配菜虽广，但也就两种用法：若用青椒、肉椒、白菜一类会出水的菜，那么应该晚下一些，略炒过生即可，取其生鲜解油；若是萝卜干、豆腐干之类不出水的，那么可以下得早些，这样配菜吃味较深，余香也厚。这干湿两种配菜的做法，总的来说就是让成菜中油脂红亮，肉片有干香，切不可混入水分。</p>
<p>主菜通常用五花肉、猪腿肉、坐墩儿肉（后腿肉、二刀肉），实在不济，只要肥瘦相连不至于切下断开的一块肥瘦肉即可。先拿水里汆去血水生气，再接着煮至七成熟取出，在冷水里浸一浸，趁外冷内热时下刀切成大片备用。然后用中火起油锅，下肉片后即用剁细的郫县豆瓣、豆豉熬炒，使豆瓣特有的色泽和味道深入肉中，待肉片呈卷窝形状（灯盏窝）时，略施白糖、酱油后马上加入配菜，改为大火翻炒致熟，起锅。</p>
<p>回锅肉的吃口在其绵软。为此，从煮这一道程序就有讲究。所谓七成熟，即通常以筷子能插透瘦肉为准。这基本就是人在咀嚼瘦肉时，其软硬度的最佳口感。肉片入锅至“熬起灯盏窝儿”，这肉片打卷儿时正是肥油将尽，外皮略焦，酥而不硬的状态。这样，再加豆瓣、豆豉，施以配菜增香去腻，加酱油起色，大火翻炒制成后肉片弹性仍在，将肉片夹起，其翻卷中不断抖动，色、香、味、形俱是上乘。由于不加水不出水，所以熬炒之后味道尽渗于肉片之中，各种调料翻覆于肉片之外，味型重而用料省，经济方便着实家常。</p>
<p>回锅肉变化丰富异常，除了配菜的丰富之外，还有加泡菜求酸爽开胃，加尖椒求鲜辣嫩香，以及加花椒、姜片等等口味上的独特调整。此外，还有以旱蒸这样的制法来保留肉鲜，以连山这样的刀法来穷极食欲等等。总之，无论如何改如何变，只要叫着“回锅肉”的名字，得着了这回锅肉“肥而不腻”的好处，便能让食客们远可牵肠挂肚，近则和饭狂啖，闲里就老酒成一席小宴，忙时夹锅盔以佐餐风卷。</p>
<p>想起来在九七年的时候，我曾在成都工作过一年。那时体育学院以西的菊乐路上有一家小店，那老板娘做得一手绝好的连山回锅肉，肉片厚薄恰到好处，真真的巴掌大小却还地道地打着半卷儿，入口时竟然能有化渣之感。再有一两粒豆豉细细地腻在肉片上，余味中品之，油尽而香出，咸苦后甘来……</p>
<p>世间再无此等美味了。</p>
<blockquote>
<p>后续：</p>
<p>引子里讲的这段故事后来是这样的。</p>
<p>我告诉他说：“正好我父亲和哥哥都是厨师，正好我非常了解烹饪，所以关于回锅肉的做法我很清楚，从肉的制作到配料的选择，从味型的调整到吃法讲究等等。我不一定是大家，你也并不一定全都不懂。但是这个问题的意义在于，你对所有问题的答案有多少的‘正确性’是并不了解的，你从未追究过答案的真实，而只在乎答案的获得。原因是你在同学们心目中有较高的地位，在他们看来，你懂得更多、更博学，甚至无所不精。然而为了维护这样的形象，你丢失了对答案的辨别能力以及追求它的欲望。所以，我不能要你。”</p>
<p>他当时真的哭了。</p>
</blockquote>
</div>]]></content:encoded></item><item><title><![CDATA[旧文重发：深夜食味记之四 - 酸菜魔芋]]></title><description><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>本来有其它两款菜式是列在计划中要写的，但一想到这酸菜，我就满口生津，急不可耐地先下笔了。</p>
<ul>
<li>aimingoo 2016.02.13 深夜于悉尼</li>
</ul>
</blockquote>
<p>魔芋本身就是一种很特别的食材。它用来食用的根茎部分其实毒性很强，是得加石灰水浸煮才能去毒，制成后形如灰褐色的凉粉，这才能用来做菜。其粗敝不可多食，火锅菜中有它，但也不算一道好菜，其它能做的菜式也就稀疏几种。我只在杭州时吃过一味烤鱼，拿它做底，味道算是上佳。另外，川菜有一道名菜“魔芋烧鸭”也是美味，这道菜父亲偶尔也做，我极喜欢吃但却自小被忌口，因为身体虚弱寒重多咳者，不可吃魔芋（另外若有皮肤病者，忌食）。所以在我看来，魔芋烧鸭之难得，便在这魔芋不太多见且又不易吃到。</p>
<p>而这里讲到的酸菜，更是四川北部特有的一种食材：土酸菜。由于传统的四川泡菜也被称为酸菜，故而两物皆有异名：四川泡菜被称为泡酸菜，土酸菜被称为淹酸菜——还有人讹作“腌酸菜”，其实工艺上并非“腌制”，反倒是另一异名“积酸菜”更为恰当。“<a href="http://blog.sina.com.cn/cdyangxiaodong">老杨</a>”在一篇《</p></div>]]></description><link>http://aimingoo.github.io/59e2eecd72c9e7b37c383201/</link><guid isPermaLink="false">59e2eecd72c9e7b37c383201</guid><category><![CDATA[深夜食味]]></category><category><![CDATA[诗词文章]]></category><category><![CDATA[杂文]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 15 Oct 2017 05:57:32 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>本来有其它两款菜式是列在计划中要写的，但一想到这酸菜，我就满口生津，急不可耐地先下笔了。</p>
<ul>
<li>aimingoo 2016.02.13 深夜于悉尼</li>
</ul>
</blockquote>
<p>魔芋本身就是一种很特别的食材。它用来食用的根茎部分其实毒性很强，是得加石灰水浸煮才能去毒，制成后形如灰褐色的凉粉，这才能用来做菜。其粗敝不可多食，火锅菜中有它，但也不算一道好菜，其它能做的菜式也就稀疏几种。我只在杭州时吃过一味烤鱼，拿它做底，味道算是上佳。另外，川菜有一道名菜“魔芋烧鸭”也是美味，这道菜父亲偶尔也做，我极喜欢吃但却自小被忌口，因为身体虚弱寒重多咳者，不可吃魔芋（另外若有皮肤病者，忌食）。所以在我看来，魔芋烧鸭之难得，便在这魔芋不太多见且又不易吃到。</p>
<p>而这里讲到的酸菜，更是四川北部特有的一种食材：土酸菜。由于传统的四川泡菜也被称为酸菜，故而两物皆有异名：四川泡菜被称为泡酸菜，土酸菜被称为淹酸菜——还有人讹作“腌酸菜”，其实工艺上并非“腌制”，反倒是另一异名“积酸菜”更为恰当。“<a href="http://blog.sina.com.cn/cdyangxiaodong">老杨</a>”在一篇《老家的酸水豆腐》中详细写过它的做法：</p>
<blockquote>
<p>在菜园子里摘一些青菜，洗净切细。起一锅水，烧到冒热气的时候，把细菜叶倒进去，翻几个滚，掺一些面水，再翻滚均匀，熄火。舀到旁边的缸里，盖上盖子，一缸酸菜就初步成了。</p>
</blockquote>
<p>这用“面水”的做法很可能是最初起的法子，一般来说却并不这样，而是要掺入“老酸菜水”。这跟泡菜要用“老泡菜水”来做是一个道理：要的是老缸中的那些微生物群，做来方可风味不失。而这“酸菜水”极是奇特，初制时如净水，清澈溢香、温凉不滞；储久后如凝浆，透亮不稠、粘沥不断。</p>
<p>土酸菜的酸度与这储藏的时间有关，通常一天即可，若超过三天便极酸了。我确实不知道能在缸中储藏多久，因为最多三天后我母亲就会把这鲜酸菜捞了出来晾晒。而这晾晒的酸菜也分两种，一种是稍微晾晒之后加盐与辣椒等物再腌的，另一种是干透之后收作干酸菜的。如此一味酸菜便可得三种食材，但无论哪一种，均不同于通常见的南、北酸菜，更与传统四川泡菜迵异。所以这些年在广元市已经将它归为川北特有食材的一种，称为“广元酸菜”。</p>
<p>土酸菜制作中加不得一丁点的油盐佐料，所以成品是纯酸的，它说起来清新爽口，实际上却有一种发酵的酸腐气。在鲜酸菜中，尽管这种酸腐气略淡，但有些人一闻这味便觉恶心难忍，原本就并不是人人都可接受的一款食材。再加上成品超常的酸度，所以使用之前要反复兑入清水并挤干，至酸度适宜方可。而另一边，魔芋的成品绵软入口稍有韧性，但除了略有一些石灰的碱味之外，却是极难入味。所以，酸菜魔芋的做法是采用干烧或炝炒：先下酸菜、豆瓣等料，重油重辣地煸炒香了，再下魔芋段（或片）制熟，最后加些热油略作熬炒。整个过程不加水不加汤，尽量用酸菜中的一点水分来收汁入味并用重油将它裹在魔芋上，以补魔芋自身不入味的缺憾。</p>
<p>酸菜魔芋的特点并不是入口的酸，而是川菜另一层的讲究：香。酸菜是作为类似葱、蒜一般的调料来用的，煸炒便是取其独特的清香味，而其自身的酸味就象催化剂一般极大程度地提升着这种清香的体验。所以一道好的酸菜魔芋当有一种甘洌自然的清香，令人不禁脾胃大开，兴兴然不可扼止，辘辘兮四下盼顾。</p>
<p>一旦让酸菜的香味夺了先，便不至于食之寡淡。所以在三种土酸菜成品中，惟以鲜酸菜烧魔芋最佳，故而必然酸菜是现做现吃为好。如今我在北方已经很少见到魔芋，至于鲜酸菜竟然已有二十余年未曾见过。偏巧这酸菜魔芋，又是要凑齐这两种粗陋少见的食材才能制得的一道美味，所以便确实是不可再得了。</p>
<p>这些日在澳洲过春节，饱了眼福却饿了肚腑。于是乎以小诗一首，纪念一下这连米饭也吃不上的日子吧：吞津饥渴甚，离乡肚腑哀。思味至夜深，奈何无良材。</p>
</div>]]></content:encoded></item><item><title><![CDATA[旧文重发：深夜食味记之三 - 麻婆豆腐]]></title><description><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>看了前两篇，老哥发来消息说：你这大半夜的，哪里有味可食，不过是想吃又吃不着的幻想嘛！好吧，我承认这个。但也决定写个连他也再吃不到的，来狠狠地馋他一回。</p>
<p>食味实是思味，其实我一早便是知的。</p>
<ul>
<li>aimingoo 2016.02.04 02:00于墨尔本</li>
</ul>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/----.jpg" alt=""></p>
<p>小时候在我家的附近便有一家豆腐店，是自家现做现卖的。父亲爱做豆腐，便常常差我和哥哥去买。到店中去买的豆腐与菜场购得的并不一样，区别便在于老板会多问你一句：做啥子用的。正宗的麻婆豆腐要用老嫩适中的豆腐，太老就入不得口，太嫩则成不了型。这个所谓“适中”的度，是父亲与豆腐店老板之间的默契。于是我跟哥哥认认真真地答道：麻婆豆腐。</p>
<p>那时邻里之间都熟，父亲跟豆腐店老板是讲过这道麻婆豆腐的门道的。豆腐要用胆水来点，这样豆腐质感会略粗一点，若用石膏则自然会细一些，但看起来是嫩了却难以入味。而且，胆水用得稍轻一点，点成了老豆腐便粗糙不可用了。接下来，豆浆点出豆花之后，豆渣要细细过滤，可能比平常要略多一道，之后用纱布装起用石块轻压成型。这成型的工夫也讲究得很，太久了豆腐过硬便也不能做麻婆豆腐了。</p>
<p>我们俩个孩子便端着这样一块生生的还蒸腾着热气的豆腐，</p></div>]]></description><link>http://aimingoo.github.io/59e2ee4272c9e7b37c3831fd/</link><guid isPermaLink="false">59e2ee4272c9e7b37c3831fd</guid><category><![CDATA[深夜食味]]></category><category><![CDATA[诗词文章]]></category><category><![CDATA[杂文]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 15 Oct 2017 05:57:22 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>看了前两篇，老哥发来消息说：你这大半夜的，哪里有味可食，不过是想吃又吃不着的幻想嘛！好吧，我承认这个。但也决定写个连他也再吃不到的，来狠狠地馋他一回。</p>
<p>食味实是思味，其实我一早便是知的。</p>
<ul>
<li>aimingoo 2016.02.04 02:00于墨尔本</li>
</ul>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/----.jpg" alt=""></p>
<p>小时候在我家的附近便有一家豆腐店，是自家现做现卖的。父亲爱做豆腐，便常常差我和哥哥去买。到店中去买的豆腐与菜场购得的并不一样，区别便在于老板会多问你一句：做啥子用的。正宗的麻婆豆腐要用老嫩适中的豆腐，太老就入不得口，太嫩则成不了型。这个所谓“适中”的度，是父亲与豆腐店老板之间的默契。于是我跟哥哥认认真真地答道：麻婆豆腐。</p>
<p>那时邻里之间都熟，父亲跟豆腐店老板是讲过这道麻婆豆腐的门道的。豆腐要用胆水来点，这样豆腐质感会略粗一点，若用石膏则自然会细一些，但看起来是嫩了却难以入味。而且，胆水用得稍轻一点，点成了老豆腐便粗糙不可用了。接下来，豆浆点出豆花之后，豆渣要细细过滤，可能比平常要略多一道，之后用纱布装起用石块轻压成型。这成型的工夫也讲究得很，太久了豆腐过硬便也不能做麻婆豆腐了。</p>
<p>我们俩个孩子便端着这样一块生生的还蒸腾着热气的豆腐，飞也似地跑回家，眼巴巴地等着父亲执铲做菜。先是用郫县豆瓣煸炒碎肉末的油香升起，继而加清水把这肉香压下拿住，入酱油、盐、白糖等调出色。此时已汁味一体，父亲习惯性地勾一点汤汁在铲边，用手指一沾一尝，一脸满意的神情中已经将豆腐轻轻地滑入锅中。手上轻轻一抖，汤汁沿锅边漫开将豆腐圈了进去。此时再将锅铲探入豆腐下面，轻轻晃几下，让汤汁浸下去。接下来急火猛烧一阵，只见汤汁在豆腐间鼓着泡儿地翻腾着，油色渐收变得鲜亮了起来，然后向炉子里加两小铲煤压住火候，再盖上锅盖让锅里的豆腐细细地收起汁来。又过几分钟，再向锅里兑入芡汁、撒些粗花椒粉，略略翻炒一下即可出锅，入盘之后再撒些葱花就上桌了。</p>
<p>这样一道麻婆豆腐才是极赞的。麻婆豆腐要用花椒，所以自然是麻的，但“麻婆”二字说的却不是这麻味，而是说用芡汁裹在豆腐外面的碎肉，如同麻脸一般。所以，麻并不是第一味，反而这煸炒碎肉末的肉鲜，才是第一味的。煸炒肉末这道工序做不到家，肉味收不到汁里，汁味浸不到豆腐里，还去谈麻婆豆腐麻不麻，就只能当是笑话听了。那豆腐多少是有些豆腥味的，所以若不能收汁入味，麻婆豆腐就会有些生生的豆腥，生腥味在留在了豆腐里，是做豆腐的第一大忌。</p>
<p>麻婆豆腐的第二味才是麻。麻是以嫩入口的，这是很少有人知道的。你看麻味的菜，多是生凉的、白切的、水煮的之类，食材都求的是嫩，麻味若不以嫩入口，就只能单纯地追在其它味型之后做个辅味，毕竟没有人象沾芥末那样去沾着花椒吃东西。所以麻婆豆腐要吃出麻味，前提却是豆腐的嫩。而豆腐的老嫩并不掌握在厨师的手里，而是掌握在做豆腐的老板手上。这关键处，在于豆花的一磨一点、一收一压，这使得豆腐可以嫩到一定程度，而还留有些疏散，这样才能在烹制的时候入得了味，食用的时候觉得出嫩，进而留得住“麻”的味道。</p>
<p>说起这麻味，川菜中有纯麻的，也有名为麻辣而实以辣为第一味的，反倒是麻婆豆腐是少有的以麻味压过辣味的川菜：它先以红亮亮的样子唬着大家以为这是辣味居先，而实底上却是以麻味为主味。当然，这是味型上的说法，若实际做起，你要放多几倍的辣椒，非要让辣味居了先，我也是无话可说的，毕竟麻婆豆腐用的是不太辣的郫县豆瓣，多放些确实辣了却也咸不可食。所以麻婆豆腐中的辣味其实中规中矩，口感温和不辛，并且通常还略略加点糖来调和，生怕它盖住了主味的鲜与麻。</p>
<p>麻婆豆腐是最考川菜厨子的一道菜，因为川菜厨子本身做得再完美也就只能拿五十分，余下的要靠豆腐。像常常说到这道菜的特色之一为“酥”，实际上是豆腐入口的口感，这单单靠厨子做是做不出来的。我听说有人用大豆代替碎肉末来做，以得这酥碎之感的。我想即便可行，也是在得不到一方好豆腐时的权益之计吧。</p>
<p>最后，既然说到这“酥”字，便多谈谈这道菜的吃法。因为吃法是食客行的事，不是厨子做的味，所以多说在这里，便算是篇外之言了。麻婆豆腐因为汁收得久，所以出锅之后豆腐是热透的，而且油又用得厚，所以保温时间长。再加上豆腐本身不易散热，所以“烫”是必然。若豆腐或类似的食材烫嘴且粘，那么就口腹之欲就变成口腹之灾，难以食用了。而麻婆豆腐便巧在这个“酥”字：豆腐入口即烂，这火气便散了去，烫固然还是烫的，但不粘在一处，也不结作一团，口感自然大好。如今很多店里只求“豆腐要细嫩”，换作了内脂豆腐来做这道菜，吃到口中粘软如糕，细食之内中无味，强吞了烧喉灼胸，实如灾难一般。</p>
<p>所以味道归味道，吃法归吃法。厨子要知味，还要知食。不会吃的厨子即便做得到川菜的“色香味俱全”，也是无法让食客满意的。而现如今，我想我父亲即便还做得了这麻婆豆腐的味道，怕会也因为没有了那样生生的、还蒸腾着热气的豆腐，做不成这道经典了吧。</p>
</div>]]></content:encoded></item><item><title><![CDATA[旧文重发：深夜食味记之二 - 鱼香肉丝]]></title><description><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>在《刀与磨刀：手艺》里提到过鱼香肉丝，于是便有网友问正宗的要怎么做。先得说，我充其量算个知道些门道的食客，下手做却是不会的。所以还是顺着“食味”的路子来聊聊这菜这味，做法上大家看看门道即可，细节莫追哈。</p>
<ul>
<li>aimingoo 2016.02.03 02:00于墨尔本</li>
</ul>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/list636022063057877500.jpg" alt=""></p>
<p>印象中的鱼香肉丝经典好吃，但如今我在北方是从来不点这道菜的。因为北方做法已经完全找不到这个菜的特点，总是做成“酸酸甜甜就是我”。而且为了这酸甜的口感，很多的做法都已经简单化到拿点番茄酱加点糖就“调”出来鱼香味了。不过，很多吃惯了这口的，还就喜欢这样子的鱼香肉丝。我倒不是怪这食客的口味，只是说无论如何这也不再是川菜中的鱼香味了，徒用了个名字而已。</p>
<p>鱼香味是种复合味型，也就是能吃到多种的、前后次序的、层次感很强的口味。好的食客是能分出味型的次序的，即使差些，也是分得出鱼香味的各种味别来。</p>
<p>标志着正宗鱼香味的第一味型，其实是鲜。而“鱼香”其实不是入鼻的香味，而是一种如同鱼肉入口的鲜味。再接下来，第二味型是酸，第三味型才是甜。</p></div>]]></description><link>http://aimingoo.github.io/59e2eda072c9e7b37c3831f9/</link><guid isPermaLink="false">59e2eda072c9e7b37c3831f9</guid><category><![CDATA[深夜食味]]></category><category><![CDATA[诗词文章]]></category><category><![CDATA[杂文]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 15 Oct 2017 05:57:15 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>在《刀与磨刀：手艺》里提到过鱼香肉丝，于是便有网友问正宗的要怎么做。先得说，我充其量算个知道些门道的食客，下手做却是不会的。所以还是顺着“食味”的路子来聊聊这菜这味，做法上大家看看门道即可，细节莫追哈。</p>
<ul>
<li>aimingoo 2016.02.03 02:00于墨尔本</li>
</ul>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/list636022063057877500.jpg" alt=""></p>
<p>印象中的鱼香肉丝经典好吃，但如今我在北方是从来不点这道菜的。因为北方做法已经完全找不到这个菜的特点，总是做成“酸酸甜甜就是我”。而且为了这酸甜的口感，很多的做法都已经简单化到拿点番茄酱加点糖就“调”出来鱼香味了。不过，很多吃惯了这口的，还就喜欢这样子的鱼香肉丝。我倒不是怪这食客的口味，只是说无论如何这也不再是川菜中的鱼香味了，徒用了个名字而已。</p>
<p>鱼香味是种复合味型，也就是能吃到多种的、前后次序的、层次感很强的口味。好的食客是能分出味型的次序的，即使差些，也是分得出鱼香味的各种味别来。</p>
<p>标志着正宗鱼香味的第一味型，其实是鲜。而“鱼香”其实不是入鼻的香味，而是一种如同鱼肉入口的鲜味。再接下来，第二味型是酸，第三味型才是甜。至于辣与咸，在鱼香味中是佐味之味，适中即可，不算突出。然而即便如此，其辣味也分三道，一是泡椒之辣，二是泡姜之辣，三是豆瓣之辣。而所谓“北方改良型”，其实先是不由分说地去了姜辣。然后由于豆瓣不可不用，而其本身又带红椒的辣味，所以不敢再用青椒。遂取了青色大肉椒代替，青椒之辣也就没了。北方做法上，在这道菜中若用郫县豆瓣，则还有一点川辣尚存，若换作它种，则川菜之“辣”便丧失殆尽了。</p>
<p>正宗鱼香味用泡青椒、泡白姜和郫县豆瓣中的红椒，这三色是常色。而底色是粉白肉丝、玉白笋丝和亮黑的木耳丝，令人有相当强的食欲。三个常色所用的辣，尽管在鱼香肉丝中只是佐味，但说真的少了这层层丰富的辣，吃起来还就少点意思。</p>
<p>然而讨论这鱼香味，若是吃不出第一味型中的“鲜”味来，那才真是失败至极了。所谓“正宗做法”，其难点也就在这一个鲜字上。这作第一主味的鲜味，其实是川味泡菜调出来的。我自己做过正宗的泡菜，让北方人试过也是称赞好吃的。所以川味泡菜不能流行，不是“能不能吃”，而是“会不会做”的问题。川味泡菜有一特殊的做法，是在泡的过程中加两三条小鲫鱼。这个做法，现在已经绝少有人用了，但却还有人谈到，我第一次读到这个的时候，是在胡晓远先生的一篇《吃鱼不见鱼的鱼香肉丝》文章中。</p>
<p>我父亲那代人学厨师傅教的便是这样，泡菜加鱼的做法我父亲也是不用的，但知道这个做法，也讲起过。但之所以“可选不用”的根源，胡晓远先生的这篇文章里约略提到，却没讲透。泡菜中的“加小鲫鱼”并不是为了“还鱼香肉丝一个吃鱼不见鱼的名头”，而只是为了取鱼之鲜。四川泡菜的鲜味很丰富，也有很多种食材可以取鲜，“加鱼尤甚”但并非惟一之选。这也是必用川味泡菜而可选“加小鲫鱼秘制”的原因：不用这种秘制算不得不正宗，但不用川味泡菜，那……无论如何也做不出正宗鱼香味。</p>
<p>这是惟一一讲便透的秘密，其它的制菜调芡之类，反倒平常了。不过泡菜这件事，在不同的制法中也能得到不同的味型，这带来的菜式差异还是很明显的。如果真的感兴趣这个，下手做做吃吃这泡菜，才能找到最适当的那个味来。</p>
<p>总而言之，鱼香是“鲜”味，不是“鱼”味，是这个鱼香味的要点。在这上面，才谈得到酸甜两味。其中的酸是泡菜的本味，是植物蔬菜之味，入口清爽而无醋之糟酿之感。而甜味最绝，它仍是来自前面的鲜味的——就好象好的鸡汤，鲜味之后有种甜，而这种甜是鲜味之后的舌感而不是加糖带来的。所以，鱼香味可以用糖，但甜的本味实来自于鲜，若糖加得重了，也是失败。</p>
<p>再多说一点这川菜。我19岁之后就不在四川了，而能让我回味川菜的，只有三道：鱼香肉丝、麻婆豆腐和回锅肉。其中鱼香肉丝和麻婆豆腐我已经再吃不到正宗的了，惟只剩下回锅肉，因为重油重咸简单直接，厨子们手上不稳也不会被骂，所以反倒常常有得吃。虽离正宗还远，然聊可果腹吧。</p>
<p>父亲也不怎么做麻婆豆腐了。他常说：已经没有像样能做的豆腐了。</p>
</div>]]></content:encoded></item><item><title><![CDATA[旧文重发：深夜食味记之一 - 番茄鸡蛋汤]]></title><description><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>这两天深夜没得睡，但空出些时间来跟网友聊聊吃的。老友@韩磊 的#深夜谈吃#已经名声在外，这名头我也不敢再用，于是搞了个#深夜食味记#来写写。这样的深夜怕也没几个，所以写得几篇便是几篇吧。</p>
<ul>
<li>aimingoo 2016.02.02于墨尔本</li>
</ul>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/yuan_ae985720321fae27217137626fdc491b.jpg" alt=""></p>
<p>多数人了解的川菜都是道听途说，偶然吃到的，也是坏厨子做坏了的味道。“重油重辣重咸”的川菜特色便是这样的厨子搞出来的。相对应的，有人便把“佐料调味最节约”的好处要归在粤菜里去。然而可有人知道，一个“番茄鸡蛋汤”在好厨师的手里，该是如何做的么？</p>
<p>这个菜在路边小店里常常被叫作“滚蛋汤”，一则是吃到这一道菜差不多就该散席了，另一个原因则是它通常的做法就是鸡蛋打散了下成蛋花，加几片番茄一滚便好。在校园里也多是浑沌沌的一大锅，是用来和饭一吞了事之物。这个菜算不上地道的川菜，而要说它是哪个菜系里的，也难得答上来。所以同一个菜式，便有了不同派别的做法，这与很多人认为的“经典与传统要有定规的做法”不同。</p>
<p>然而我父亲这一辈的川菜厨子里，对这道菜也是有讲究的。假定它就是席上的最后一道菜吧——川菜入席可能有两道汤，</p></div>]]></description><link>http://aimingoo.github.io/59e2e9b272c9e7b37c3831f0/</link><guid isPermaLink="false">59e2e9b272c9e7b37c3831f0</guid><category><![CDATA[诗词文章]]></category><category><![CDATA[杂文]]></category><category><![CDATA[深夜食味]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 15 Oct 2017 05:02:22 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><blockquote>
<p>这两天深夜没得睡，但空出些时间来跟网友聊聊吃的。老友@韩磊 的#深夜谈吃#已经名声在外，这名头我也不敢再用，于是搞了个#深夜食味记#来写写。这样的深夜怕也没几个，所以写得几篇便是几篇吧。</p>
<ul>
<li>aimingoo 2016.02.02于墨尔本</li>
</ul>
</blockquote>
<p><img src="http://aimingoo.github.io/content/images/2017/10/yuan_ae985720321fae27217137626fdc491b.jpg" alt=""></p>
<p>多数人了解的川菜都是道听途说，偶然吃到的，也是坏厨子做坏了的味道。“重油重辣重咸”的川菜特色便是这样的厨子搞出来的。相对应的，有人便把“佐料调味最节约”的好处要归在粤菜里去。然而可有人知道，一个“番茄鸡蛋汤”在好厨师的手里，该是如何做的么？</p>
<p>这个菜在路边小店里常常被叫作“滚蛋汤”，一则是吃到这一道菜差不多就该散席了，另一个原因则是它通常的做法就是鸡蛋打散了下成蛋花，加几片番茄一滚便好。在校园里也多是浑沌沌的一大锅，是用来和饭一吞了事之物。这个菜算不上地道的川菜，而要说它是哪个菜系里的，也难得答上来。所以同一个菜式，便有了不同派别的做法，这与很多人认为的“经典与传统要有定规的做法”不同。</p>
<p>然而我父亲这一辈的川菜厨子里，对这道菜也是有讲究的。假定它就是席上的最后一道菜吧——川菜入席可能有两道汤，一中一后，但不会有前汤。做这道汤，得看前菜是什么。如果前菜太油，这道汤就得淡；前菜若是寡淡，这汤就得做厚一些。以清淡来论，鸡蛋打散下锅，番茄切薄不入锅，用蛋花汤一浇加几粒盐放几点香油就可以上桌，葱花可加可不加，各成味道。若以厚重来做，鸡蛋打散下炒锅用油中火炒成五六分熟，可加少许盐、酱油，然后温水浇下略煮，起锅前加厚番茄片略煮，起锅不再加香油不再用盐。这两类做法顺序和目的都有不同，还有别的许多小细节，又用在不同场合。但总的来说，“汤的清淡与否”，与食客当下的口味与状态是有关的，而不是单纯的节约或不节约佐料。</p>
<p>这其中的讲究，在于川菜讲的是“吃味”，而不是“吃食”。不是说做番茄蛋花汤，就得让食客吃掉一只番茄一只鸡蛋，鸡蛋要几两几钱番茄要红透熟烂之类。并不是这样的。上面说番茄蛋花汤的淡做法，要点在出锅后汤中有番茄的清香，所以番茄是生薄片且不入锅的，这样做来的汤清鲜有生气，是为饱食之后解解油气。而厚做法，则是要留下炒鸡蛋带来的油性，这样可以在喝的时候有一种饱腹感，番茄用厚片并略煮，也是这个目的。这两种做法中，汤都是用来喝，不是用来吃的。油、气、味的控制，是为了宴末的时候，得一余兴余味。</p>
<p>我父亲常说：一菜一味，百菜百味。菜放在席上，菜与菜之间是相互影响口感的，如何调整细节上的做法，使得一道菜呈现出它应有的味道，是很花心思的。仍然以这个蛋花汤为例，开水沸的程度决定了蛋花的细嫩以及番茄的鲜香，这就与火候有关系。而我父亲教徒弟，是连柴灶煤灶如何烧，何时添柴加煤都要教的，连灶的样式我父亲都要指导着泥工师傅去垒。</p>
<p>并不是说非得要这样做灶烧火才能保持传统，只是如今的厨师已经完全不知道这些了，又如何指望他们能用一眼煤气重现这样的手艺呢？</p>
</div>]]></content:encoded></item><item><title><![CDATA[Monster 1.0.6开启的新功能]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="">多人博客</h2>
<p>经过几个版本的更新，Monster已经开始有了丰富的功能，这其中就包括对Ghost多人博客的支持。</p>
<p>Monster主要是在<code>updatesite.sh</code>模式中支持多人博客，也就是说这个功能在<code>update</code>模式下可用。当在<code>.monster</code>配置文件的<code>EMAIL</code>参数中使用一个列表，例如：</p>
<ul>
<li><code>EMAIL=(&quot;aiming@gmail.com&quot; &quot;qomo@gmail.com&quot;)</code></li>
</ul>
<p>那么多人博客的模式就自动开启，并在<code>--sync-removed</code>命令中有效。</p>
<blockquote>
<p>注：如果你只是删除post，或更新theme中post的风格，那么由于<code>update</code>模式无法从数据库感知到你的更新，所以就需要使用<code>--sync-removed</code>来强制更新指定用户/多个用户的博客内容。一旦使用该命令，那么也将导致整个的索引页会强制更新（因为上面的操作事实上也意味着全站的posts index pages页发生了变化）</p>
</blockquote>
<h2 id="pages">可定制强制更新的pages列表</h2>
<p>当使用<code>update</code></p></div>]]></description><link>http://aimingoo.github.io/59e22d961369c498d686e75c/</link><guid isPermaLink="false">59e22d961369c498d686e75c</guid><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sat, 14 Oct 2017 17:36:43 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="">多人博客</h2>
<p>经过几个版本的更新，Monster已经开始有了丰富的功能，这其中就包括对Ghost多人博客的支持。</p>
<p>Monster主要是在<code>updatesite.sh</code>模式中支持多人博客，也就是说这个功能在<code>update</code>模式下可用。当在<code>.monster</code>配置文件的<code>EMAIL</code>参数中使用一个列表，例如：</p>
<ul>
<li><code>EMAIL=(&quot;aiming@gmail.com&quot; &quot;qomo@gmail.com&quot;)</code></li>
</ul>
<p>那么多人博客的模式就自动开启，并在<code>--sync-removed</code>命令中有效。</p>
<blockquote>
<p>注：如果你只是删除post，或更新theme中post的风格，那么由于<code>update</code>模式无法从数据库感知到你的更新，所以就需要使用<code>--sync-removed</code>来强制更新指定用户/多个用户的博客内容。一旦使用该命令，那么也将导致整个的索引页会强制更新（因为上面的操作事实上也意味着全站的posts index pages页发生了变化）</p>
</blockquote>
<h2 id="pages">可定制强制更新的pages列表</h2>
<p>当使用<code>update</code>模式时，如果一个置为<code>static page</code>的页面是使用动态生成方式来生成的——例如archive页，那么仍然是由于数据库不可感知的缘故，就需要使用<code>--force</code>参数来强制生成。你可以通过一个名为<code>FORCEPAGE_LIST</code>的参数来指定这些页面的列表，该参数也在<code>.monster</code>配置文件中。例如：</p>
<ul>
<li><code>FORCEPAGE_LIST=(&quot;archives-post-second-user/&quot;)</code></li>
</ul>
<p>在这个例子中，由于<code>/archives-post/</code>页总是动态生成的网站归档页，所以它缺省是被Monster内部处理的。但如果是使用多人博客（或者其它原因），那么可能就需要生成多个这样的归档。这“动态生成”就意味着从sqlite数据库中感知不到，所以就需要象上面这样强制定义列表。</p>
<p>与此类似的，由于<code>update</code>模式总是尝试使用short_path，因此缺省情况下会将类似<code>/about/index.html</code>这样的页面处理成<code>/about.html</code>。这在大多数情况下是适用的，但Ghost却默认会将导航栏上的链接转换成<code>/.../</code>这样的格式，也就是说它必须使用<code>/about/index.html</code>。这一类的问题在<code>update</code>模式时必须手工指定，你可以使用类似下面的配置：</p>
<ul>
<li><code>FORCEINDEX_LIST=(&quot;about-second-user&quot;)</code></li>
</ul>
<p>在使用Monster的<code>generate</code>模式时也会有这个问题，这是通过<code>IGNORE_LIST</code>来处理的。事实上<code>makesite.sh</code>模块会将这个列表与<code>FORCEINDEX_LIST</code>列表合在一起，来跳过所有不需要处理——亦即是将会保留index.html文件——的目录。</p>
<h2 id="">搜索功能</h2>
<p>Monster提供一种快速搜索的功能，这可以通过<code>monster search ...</code>来实现。</p>
<p>在Ghost 0.9x版本与1.x版本中的数据库结构并不相同，而Monster会自动识别并处理不同的查询条件。因此，现在开始，你可以简单的了解一下你的Posts中都有些什么了（Monster只搜索Posts的内文，而在Ghost Admin后台上搜索只处理标题）：</p>
<pre><code class="language-bash">&gt; monster search &quot;关键字&quot;
id        slug        created_at           title                                 
--------  ----------  -------------------  --------------------------------------
59dafc1a  1-44        2006-04-16 21:03:00  Qomo OpenProject beta1 精彩图集～
59dafc1a  1-50        2006-10-09 14:23:00  【原创】搞了个NetGear的路由?
...
</code></pre>
<h2 id="shortpath">短路径（Short Path）的规则</h2>
<p>在使用Ghost 0.9x时，数据库中的Post ID是从1开始的自增序的，因此Monster采用的short-path规则是<code>authorId-postId</code>。但从Ghost 1.x开始，数据库中的authrId和postId都不再是自增序的整数了，而是一个长的字符串（从旧数据库中导入的一些数据存在例外）。因此，即使使用Monster的<code>--short-path</code>参数，也无法按旧规则来生成这个名字。</p>
<p>因此从Monster 1.06开始，<code>update</code>模式下的<code>--sync-slug</code>会根据数据库版本来选择如下两种格式之一：</p>
<ul>
<li>在Ghost 1.x中采用<code>postId</code>作为post slug；</li>
<li>在Ghost 0.9x中采用<code>authorId-postId</code>作为post slug。</li>
</ul>
<p>考虑到从0.9x迁移到1.x的情况，<code>--sync-slug</code>不对已经采用了short-path格式的slug再做sync操作——了就是说0.9x已经使用了short-path的post会被忽略。<strong>但在识别这种情况时，只处理authorId&lt;9的情况</strong>，这在一般情况下是够用的。</p>
<h2 id="fastcommands">快速命令（Fast commands）</h2>
<p>Monster为一些常用命令建立了快速命令风格，例如上面的<code>monster search ...</code>。在这种风格中，<code>search</code>并不是一个模式——Monster目前只支持<code>generate/update/preview</code>三种模式。</p>
<p>事实上，<code>monster search ...</code>是等效于<code>monster update --search ...</code>的，从Monster v1.0.5开始就提供了这样的一种快速命令风格，用于简单地执行一些命令开关。虽然目前只有<code>search/list</code>两个，但将来会扩充它。</p>
<h2 id="posts">支持无限数量的Posts</h2>
<p>在早前的Monster脚本中只能处理有限数据的Posts，因为过多的Posts生成特别大的正则表达式，从而导致sed调用失效。在Monster v1.0.6中修正了这个Bug，使得Post会根据标题长度自动计算批次，分批处理，从而实现了对“无限数量”的Posts的支持。</p>
<h2 id="">其它</h2>
<p>Monster从v1.0.5开始就不再需要预先安装Buster了，所以它也不再依赖Python环境——如果你不使用<code>preview</code>功能的话。</p>
<p>你可以使用brew来快速安装Monster：<code>brew install aimingoo/repo/monster</code>。</p>
<p>也可以从Github下载Monster：<a href="https://github.com/aimingoo/monster">https://github.com/aimingoo/monster</a>。</p>
</div>]]></content:encoded></item><item><title><![CDATA[麦秸的垛 - 多人博客上线啦]]></title><description><![CDATA[<div class="kg-card-markdown"><p>麦子的文字写得比我好看，她的博客就叫“麦秸的垛”。</p>
<p>很早就说要把这个博客做成多人博客，其实也一早就做了，只是一直没上线。原因是从旧博客迁移过来的时候，几乎所有的文章都得再按markdown格式重排一遍。这个确实很花时间，比如我的那部分大概做了三个月呢。</p>
<p>所以“麦秸的垛”就一直拖着没上线。</p>
<p>麦子之前在新浪、搜狐和微软MSN上发的博文其实不少，我一次全迁移过来了，也是200多篇呢。所以接下来又得花阵子功夫来做排版了，不过应该会比我的快：毕竟她的博文没代码……</p>
<p>我的文字太硬气，读起来难以让人愉悦，麦子的不会。这个，相信我。</p>
<p>点右上方的链接就好了。</p>
</div>]]></description><link>http://aimingoo.github.io/59df7101a550c258f56eab34/</link><guid isPermaLink="false">59df7101a550c258f56eab34</guid><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Thu, 12 Oct 2017 13:42:06 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>麦子的文字写得比我好看，她的博客就叫“麦秸的垛”。</p>
<p>很早就说要把这个博客做成多人博客，其实也一早就做了，只是一直没上线。原因是从旧博客迁移过来的时候，几乎所有的文章都得再按markdown格式重排一遍。这个确实很花时间，比如我的那部分大概做了三个月呢。</p>
<p>所以“麦秸的垛”就一直拖着没上线。</p>
<p>麦子之前在新浪、搜狐和微软MSN上发的博文其实不少，我一次全迁移过来了，也是200多篇呢。所以接下来又得花阵子功夫来做排版了，不过应该会比我的快：毕竟她的博文没代码……</p>
<p>我的文字太硬气，读起来难以让人愉悦，麦子的不会。这个，相信我。</p>
<p>点右上方的链接就好了。</p>
</div>]]></content:encoded></item><item><title><![CDATA[博客中的系列文章]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="">【技术类】</h2>
<h3 id="qomo">Qomo技术系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-15/">从基础开始：Qomo OpenProject中的一些关键词</a></li>
<li><a href="http://aimingoo.github.io/1-16/">从基础开始：Qomo OpenProject中的一些关键词(2)</a></li>
<li><a href="http://aimingoo.github.io/1-18/">JavaScript面向对象的支持(1)</a></li>
<li><a href="http://aimingoo.github.io/1-21/">JavaScript面向对象的支持(2)</a></li>
<li><a href="http://aimingoo.github.io/1-22/">JavaScript面向对象的支持(3)</a></li>
<li><a href="http://aimingoo.github.io/1-23/">JavaScript面向对象的支持(4)</a></li>
<li><a href="http://aimingoo.github.io/1-24/">JavaScript面向对象的支持(5)</a></li>
<li><a href="http://aimingoo.github.io/1-26/">JavaScript面向对象的支持(6)</a></li>
<li><a href="http://aimingoo.github.io/1-27/">JavaScript面向对象的支持(7)</a></li>
<li><a href="http://aimingoo.github.io/1-30/">Qomolangma实现篇(一)：内核载入模块system.js的实现</a></li>
<li><a href="http://aimingoo.github.io/1-32/">Qomolangma实现篇(二)：命名空间和别名子系统的实现</a></li>
<li><a href="http://aimingoo.github.io/1-35/">Qomolangma实现篇(三)：兼容层设计</a></li>
<li><a href="http://aimingoo.github.io/1-36/">Qomolangma实现篇(四)：基本特性增强与多投事件系统</a></li>
<li><a href="http://aimingoo.github.io/1-38/">Qomolangma实现篇(五)：Qomo的OOP的语法和类继承体系</a></li>
<li><a href="http://aimingoo.github.io/1-39/">Qomolangma实现篇(六)：Qomo的OOP框架的实现技术</a></li>
<li><a href="http://aimingoo.github.io/1-42/">Qomolangma实现篇(七)：Qomo的接口机制</a></li>
<li><a href="http://aimingoo.github.io/1-43/">Qomolangma实现篇(八)：Qomo中的AOP框架</a></li>
<li><a href="http://aimingoo.github.io/1-47/">Qomolangma实现篇(九)</a></li></ul></div>]]></description><link>http://aimingoo.github.io/1-1747/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c4</guid><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 08 Oct 2017 14:29:50 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="">【技术类】</h2>
<h3 id="qomo">Qomo技术系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-15/">从基础开始：Qomo OpenProject中的一些关键词</a></li>
<li><a href="http://aimingoo.github.io/1-16/">从基础开始：Qomo OpenProject中的一些关键词(2)</a></li>
<li><a href="http://aimingoo.github.io/1-18/">JavaScript面向对象的支持(1)</a></li>
<li><a href="http://aimingoo.github.io/1-21/">JavaScript面向对象的支持(2)</a></li>
<li><a href="http://aimingoo.github.io/1-22/">JavaScript面向对象的支持(3)</a></li>
<li><a href="http://aimingoo.github.io/1-23/">JavaScript面向对象的支持(4)</a></li>
<li><a href="http://aimingoo.github.io/1-24/">JavaScript面向对象的支持(5)</a></li>
<li><a href="http://aimingoo.github.io/1-26/">JavaScript面向对象的支持(6)</a></li>
<li><a href="http://aimingoo.github.io/1-27/">JavaScript面向对象的支持(7)</a></li>
<li><a href="http://aimingoo.github.io/1-30/">Qomolangma实现篇(一)：内核载入模块system.js的实现</a></li>
<li><a href="http://aimingoo.github.io/1-32/">Qomolangma实现篇(二)：命名空间和别名子系统的实现</a></li>
<li><a href="http://aimingoo.github.io/1-35/">Qomolangma实现篇(三)：兼容层设计</a></li>
<li><a href="http://aimingoo.github.io/1-36/">Qomolangma实现篇(四)：基本特性增强与多投事件系统</a></li>
<li><a href="http://aimingoo.github.io/1-38/">Qomolangma实现篇(五)：Qomo的OOP的语法和类继承体系</a></li>
<li><a href="http://aimingoo.github.io/1-39/">Qomolangma实现篇(六)：Qomo的OOP框架的实现技术</a></li>
<li><a href="http://aimingoo.github.io/1-42/">Qomolangma实现篇(七)：Qomo的接口机制</a></li>
<li><a href="http://aimingoo.github.io/1-43/">Qomolangma实现篇(八)：Qomo中的AOP框架</a></li>
<li><a href="http://aimingoo.github.io/1-47/">Qomolangma实现篇(九)：Qomo中的模板系统</a></li>
<li><a href="http://aimingoo.github.io/1-49/">Qomolangma框架库(一)：概述、工具、异常、调试与分析</a></li>
<li><a href="http://aimingoo.github.io/1-51/">Qomolangma框架库(二)：时间线与时间处理器</a></li>
<li><a href="http://aimingoo.github.io/1-57/">Qomolangma框架库(三)：处理池与处理机</a></li>
</ul>
<h3 id="">“前端要给力”系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-160/">前端要给力之：代码可以有多烂？</a></li>
<li><a href="http://aimingoo.github.io/1-162/">前端要给力之：URL应该有多长？</a></li>
<li><a href="http://aimingoo.github.io/1-163/">前端要给力之：原子，与原子联结的友类、友函数</a></li>
<li><a href="http://aimingoo.github.io/1-164/">前端要给力之：分解对象构造过程new()</a></li>
<li><a href="http://aimingoo.github.io/1-195/">前端要给力之：红绿灯大战中的火星生命-Promise</a></li>
</ul>
<h3 id="android">Android玩乐系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-178/">Android玩乐系列：修改汇编代码支持原生高清来电大头贴（一）</a></li>
<li><a href="http://aimingoo.github.io/1-179/">Android玩乐系列：修改汇编代码支持原生高清来电大头贴（二）</a></li>
<li><a href="http://aimingoo.github.io/1-180/">Android玩乐系列：修改汇编代码支持原生高清来电大头贴（三）</a></li>
</ul>
<h3 id="javascript">JavaScript类型讨论系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-167/">再谈JavaScript的数据类型问题</a></li>
<li><a href="http://aimingoo.github.io/1-168/">三谈类型问题：ECMAScript为什么错了？</a></li>
<li><a href="http://aimingoo.github.io/1-170/">JavaScript类型总览(图)</a></li>
</ul>
<h3 id="">元语言及其应用系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-112/">元语言基础技术之：在JS中如何自由地创建函数</a></li>
<li><a href="http://aimingoo.github.io/1-110/">QoBean的元语言系统（一）</a></li>
<li><a href="http://aimingoo.github.io/1-111/">QoBean的元语言系统（二）</a></li>
<li><a href="http://aimingoo.github.io/1-146/">为脚本语言平反-JavaScript篇（1）</a></li>
<li><a href="http://aimingoo.github.io/1-147/">为脚本语言平反-JavaScript篇（2）</a></li>
<li><a href="http://aimingoo.github.io/1-148/">为脚本语言平反-JavaScript篇（3）</a></li>
</ul>
<h3 id="">设计师的实战过程系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-113/">内训资料公开：设计师的实战过程(1)</a></li>
<li><a href="http://aimingoo.github.io/1-115/">内训资料公开：设计师的实战过程(2)</a></li>
<li><a href="http://aimingoo.github.io/1-116/">内训资料公开：设计师的实战过程(3)</a></li>
</ul>
<h2 id="">【论谈类】</h2>
<h3 id="">我读《人月神话》系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-63/">杀不死的人狼——我读《人月神话》（一）</a></li>
<li><a href="http://aimingoo.github.io/1-64/">杀不死的人狼——我读《人月神话》（二）</a></li>
<li><a href="http://aimingoo.github.io/1-65/">杀不死的人狼——我读《人月神话》（三）</a></li>
<li><a href="http://aimingoo.github.io/1-66/">杀不死的人狼——我读《人月神话》（四）</a></li>
<li><a href="http://aimingoo.github.io/1-67/">杀不死的人狼——我读《人月神话》（五）</a></li>
</ul>
<h3 id="">《大道至简》的幕后故事系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-70/">《大道至简》的幕后故事(1)</a></li>
<li><a href="http://aimingoo.github.io/1-71/">《大道至简》的幕后故事(2)：“愚公移山记”人物篇</a></li>
<li><a href="http://aimingoo.github.io/1-72/">《大道至简》的幕后故事(3)：“愚公移山记”事物篇</a></li>
<li><a href="http://aimingoo.github.io/1-73/">《大道至简》的幕后故事(4)：“愚公移山记”军事地理篇</a></li>
<li><a href="http://aimingoo.github.io/1-74/">《大道至简》的幕后故事(5)：“愚公移山记”军事谋略篇</a></li>
<li><a href="http://aimingoo.github.io/1-75/">《大道至简》的幕后故事：终结篇、勘误和PDF下载</a></li>
</ul>
<h3 id="vclrad">“VCL已死，RAD已死”系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-123/">VCL已死，RAD已死(1)</a></li>
<li><a href="http://aimingoo.github.io/1-124/">VCL已死，RAD已死(2)</a></li>
<li><a href="http://aimingoo.github.io/1-125/">VCL已死，RAD已死(3)</a></li>
<li><a href="http://aimingoo.github.io/1-126/">VCL已死，RAD已死(插播)</a></li>
<li><a href="http://aimingoo.github.io/1-129/">VCL已死，RAD已死(4)</a></li>
<li><a href="http://aimingoo.github.io/1-130/">关于“VCL已死、RAD已死”答读者问</a></li>
<li><a href="http://aimingoo.github.io/1-131/">VCL已死，RAD已死(5)</a></li>
<li><a href="http://aimingoo.github.io/1-132/">VCL已死，RAD已死(6) - 结语与预测</a></li>
</ul>
<h3 id="">《大道至易：实践者的思想》第二版发布小述系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-1735/">电子书《我的架构思想》小述</a></li>
<li><a href="http://aimingoo.github.io/1-1734/">电子书《程序原本》小述</a></li>
<li><a href="http://aimingoo.github.io/1-1736/">小述系列最终篇：说说《大道至易：实践者的思想》</a></li>
</ul>
<h3 id="oschina">OSCHINA答读者问系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-186/">OSCHINA答读者问之一：“软件工程”的学法与用法</a></li>
<li><a href="http://aimingoo.github.io/1-187/">OSCHINA答读者问之二：什么是架构？以及什么是架构师？</a></li>
<li><a href="http://aimingoo.github.io/1-188/">OSCHINA答读者问之三：架构是否就是把问题域理清楚？软件工程各要素可有比重？</a></li>
<li><a href="http://aimingoo.github.io/1-189/">OSCHINA答读者问之四：如何做好团队建设以及提高个人领导力？</a></li>
<li><a href="http://aimingoo.github.io/1-190/">OSCHINA答读者问之五：小作坊如何实施所谓的软件工程？</a></li>
<li><a href="http://aimingoo.github.io/1-191/">OSCHINA答读者问之六：杂谈（完结篇）</a></li>
</ul>
<h2 id="">【应用类】</h2>
<h3 id="pdf">PDF工具系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-62/">关于做PDF的FAQ（一）～（四）</a></li>
<li><a href="http://aimingoo.github.io/1-1726/">Kindle电子书中该用多大的图片</a></li>
<li><a href="http://aimingoo.github.io/1-1728/">在电子书中使用SVG</a></li>
</ul>
<h3 id="">博客迁移手记系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-1719/">手记1：迁移博客之全程工具</a></li>
<li><a href="http://aimingoo.github.io/1-1720/">手记2：从本地博客到Github Pages的最佳指南及工具</a></li>
<li><a href="http://aimingoo.github.io/1-1721/">手记3：实例教学之Ghost模板定制</a></li>
<li><a href="http://aimingoo.github.io/1-1722/">手记4：谈谈Gitment中泄露secret的前因后果与解决方法</a></li>
<li><a href="http://aimingoo.github.io/1-1723/">手记5：如何获得一个支持HTTPS的免费空间</a></li>
<li><a href="http://aimingoo.github.io/1-1725/">手记6：改造Gitment</a></li>
<li><a href="http://aimingoo.github.io/1-1724/">博客迁移手记之快速导航</a></li>
</ul>
<h3 id="monster">Monster使用系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-1741/">Monster - 用Ghost写博客的终极利器</a></li>
<li><a href="http://aimingoo.github.io/1-1743/">将Monster用作网站离线下载的方法</a></li>
<li><a href="http://aimingoo.github.io/1-1742/">详解Monster的初始化及配置</a></li>
<li><a href="http://aimingoo.github.io/1-1744/">Monster的三种工作模式</a></li>
</ul>
<h2 id="">【非技术类】</h2>
<h3 id="">坐而论道系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-205/">坐而论道（之一）</a></li>
<li><a href="http://aimingoo.github.io/1-206/">坐而论道（之二）</a></li>
<li><a href="http://aimingoo.github.io/1-211/">坐而论道（之三）</a></li>
<li><a href="http://aimingoo.github.io/1-219/">坐而论道（之四）</a></li>
<li><a href="http://aimingoo.github.io/1-259/">坐而论道（之五）：关于佛学中的“我”</a></li>
</ul>
<h2 id="">【其它/综合】</h2>
<h3 id="">旧文重发系列</h3>
<ul>
<li><a href="http://aimingoo.github.io/1-99/">旧文重发：程序员的一天</a></li>
<li><a href="http://aimingoo.github.io/1-100/">旧文重发：谈企业软件架构设计</a></li>
<li><a href="http://aimingoo.github.io/1-101/">旧文重发：产品线工程：团队迭代及其问题</a></li>
<li><a href="http://aimingoo.github.io/1-102/">旧文重发：程序员的七种武器</a></li>
<li><a href="http://aimingoo.github.io/1-103/">旧文重发：剑走偏锋：非主流的程序员</a></li>
<li><a href="http://aimingoo.github.io/1-104/">旧文重发：苹果是怎么吃到的？</a></li>
<li><a href="http://aimingoo.github.io/1-105/">旧文重发：做人、做事，做架构师——架构师能力模型解析</a></li>
</ul>
</div>]]></content:encoded></item><item><title><![CDATA[解决静态Blog中timeago显示问题的方法]]></title><description><![CDATA[<div class="kg-card-markdown"><p>因为使用的是Ghost博客的静态化页面，因此一篇文章发布到github上的时候显示的“发表于x分钟之前”，那么过了N多天再去看，还是这个“x分钟之前”。极不爽。所以，最近修改了一个timeAgo模块，用来搞定在静态博客中实时地显示timeAgo信息。</p>
<p>在页面中使用的时候也很简单，基本的做法是：</p>
<pre><code class="language-html">// 在页面中添加timeAgo模块
&lt;script src=&quot;https://aimingoo.github.io/assets/js/timeAgo.js&quot;&gt;&lt;/script&gt;

// 在需要显示的位置使用下面的代码
&lt;script&gt;document.writeln(timeAgo(&quot;DATETIME_OF_YOUR_POST&quot;))&lt;/script&gt;
</code></pre>
<p>在具体到Ghost的模板中使用的时候，会略有不同。</p>
<p><strong>1. 修改default.</strong></p></div>]]></description><link>http://aimingoo.github.io/1-1746/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c3</guid><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><category><![CDATA[Javascript]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 27 Sep 2017 10:10:47 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>因为使用的是Ghost博客的静态化页面，因此一篇文章发布到github上的时候显示的“发表于x分钟之前”，那么过了N多天再去看，还是这个“x分钟之前”。极不爽。所以，最近修改了一个timeAgo模块，用来搞定在静态博客中实时地显示timeAgo信息。</p>
<p>在页面中使用的时候也很简单，基本的做法是：</p>
<pre><code class="language-html">// 在页面中添加timeAgo模块
&lt;script src=&quot;https://aimingoo.github.io/assets/js/timeAgo.js&quot;&gt;&lt;/script&gt;

// 在需要显示的位置使用下面的代码
&lt;script&gt;document.writeln(timeAgo(&quot;DATETIME_OF_YOUR_POST&quot;))&lt;/script&gt;
</code></pre>
<p>在具体到Ghost的模板中使用的时候，会略有不同。</p>
<p><strong>1. 修改default.hbs</strong></p>
<p>将下面的代码插入页面合适的位置以加载timeAgo模块：</p>
<pre><code class="language-html">&lt;!-- 将timeAgo.js置入模板的assets目录 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;{{asset &quot;js/timeAgo.js&quot;}}&quot;&gt;&lt;/script&gt;

&lt;!-- 或使用在线的版本 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://aimingoo.github.io/assets/js/timeAgo.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>如果你的模板有自己的初始化代码（一般放在<code>assets/js/index.js</code>文件中），应该将这行代码插入在初始化代码之前。</p>
<p><strong>2. 修改post.hbs</strong></p>
<p>在<code>post.hbs</code>中找到显示一个Post的日期的位置。它可能使用如下代码（缺省使用Ghost内置的timeago方法显示）：</p>
<pre><code class="language-bash">{{date published_at timeago=&quot;true&quot;}}
</code></pre>
<p>根据你打算在<code>post.hbs</code>使用该值的不同方法，可以直接输出，也可以在页面加载之后重置这个值。</p>
<p>如果是直接在该页面中输出，则将上面的改为：</p>
<pre><code class="language-html">&lt;script&gt;document.writeln(timeAgo(&quot;{{date published_at format='YYYY-MM-DDTHH:mm:ss.sssZ'}}&quot;))&lt;/script&gt;
</code></pre>
<p>注意上面的代码中，我们是用format参数来取得更加精确的时间值（而不是直接使用timeago格式的值）。</p>
<p><strong>3. 如果采用延迟加载的方法</strong></p>
<p>如果这个值是采用延迟加载的方法来显示的，那么它可能放在<code>post.hbs</code>的一对标签中。类似：</p>
<pre><code class="language-html">&lt;time class=&quot;post-date&quot; datetime=&quot;{{date format='YYYY-MM-DDTHH:mm:ss.sssZ'}}&quot; timeago=&quot;true&quot;&gt;&lt;/time&gt;
</code></pre>
<p>注意这里的<code>timeago</code>只是一个html标签属性——这个属性是我添加的，用来标示这个<code>&lt;time&gt;</code>标签将采用<code>timeago</code>方式显示。</p>
<p>在延迟加载的情况下，通常是在全局的ready回调中做一些针对当前页面的规格化操作。它可能通过在<code>default.hbs</code>中加载一个<code>.js</code>文件来进入。以我们上面说到过的例子，假如在<code>assets/js/index.js</code>文件中，那么它可能的代码是：</p>
<pre><code class="language-javascript">$(document).ready(function() {
  ...
})
</code></pre>
<p>在这个代码块中，加入下面的代码即可：</p>
<pre><code class="language-javascript">// 列出所有'class=&quot;post-date&quot;的标签
$(&quot;.post-date&quot;).each(function() {
    // 检查上面添加的'timeago'属性值是否为'true'
    if ($(this).attr(&quot;timeago&quot;) == &quot;true&quot;) {
        // 从'datetime'属性中取时间值，用timeAgo()转换并回写到当前标签中
        $(this).text(timeAgo($(this).attr(&quot;datetime&quot;)));
    }
});
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[怎么会有两个“原本”]]></title><description><![CDATA[<div class="kg-card-markdown"><p>今天很突然地发现裘宗燕老师还翻译了一本《编程原本》，英文名是&quot;Elements of Programming&quot;，是C++的STL库之父Alexander Stepanov，简单地说就是“一个大牛”。而看到这个书名的时候，就是一惊：撞衫撞脸撞书名，我那本《程序原本》的英文名原本也是打算用&quot;Elements of Programming&quot;的呀。</p>
<p><img src="http://aimingoo.github.io/content/images/2017/09/two_elements.png" alt="two_elements"></p>
<blockquote>
<p>这两本书的介绍在这里：</p>
<ul>
<li>《编程原本》<a href="https://book.douban.com/subject/7564093/">https://book.douban.com/subject/7564093/</a></li>
<li>《程序原本》<a href="http://blog.csdn.net/aimingoo/article/details/75506782">http://blog.csdn.net/aimingoo/article/details/75506782</a></li>
</ul>
</blockquote>
<p>Alex这本书是2009年出的，中文版则等到了2012年。所以我写《大道至易》的时候并不知道这本书，这很正常。到2012年《大道至易》</p></div>]]></description><link>http://aimingoo.github.io/1-1745/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c2</guid><category><![CDATA[程序原本]]></category><category><![CDATA[书序书评]]></category><category><![CDATA[读书]]></category><category><![CDATA[杂谈]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 24 Sep 2017 10:53:20 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>今天很突然地发现裘宗燕老师还翻译了一本《编程原本》，英文名是&quot;Elements of Programming&quot;，是C++的STL库之父Alexander Stepanov，简单地说就是“一个大牛”。而看到这个书名的时候，就是一惊：撞衫撞脸撞书名，我那本《程序原本》的英文名原本也是打算用&quot;Elements of Programming&quot;的呀。</p>
<p><img src="http://aimingoo.github.io/content/images/2017/09/two_elements.png" alt="two_elements"></p>
<blockquote>
<p>这两本书的介绍在这里：</p>
<ul>
<li>《编程原本》<a href="https://book.douban.com/subject/7564093/">https://book.douban.com/subject/7564093/</a></li>
<li>《程序原本》<a href="http://blog.csdn.net/aimingoo/article/details/75506782">http://blog.csdn.net/aimingoo/article/details/75506782</a></li>
</ul>
</blockquote>
<p>Alex这本书是2009年出的，中文版则等到了2012年。所以我写《大道至易》的时候并不知道这本书，这很正常。到2012年《大道至易》发行的时候，我在“程序原本”这一篇上用的标题是“程序源流”，是再到后来把这一部分独立成书并打算出电子版的时候，才用回到更早拟的名字，也就是《程序原本》。</p>
<p>于是现在就有了两个“原本”：《编程原本》和《程序原本》。</p>
<p>我仔细读了读Alex的《编程原本》，感叹于裘宗燕老师精准的翻译——是的，没错，这本书确实应该叫“编程（Programming）原本”。Alex在讲的，根本就不是“程序是怎么一回事”，而是“怎么写出好程序”——编程源于数学，因而可以从一个数学系统的构建和演进来理解编程的精髓，并“（或许就是）希望基于这种思维方法和开发技术，为范围广泛的软件系统建立起坚实基础”。由于这样的观念，Alex的《编程原本》中的数学系统既不是严格学术上的数学，也不是一般含义上的计算机系统。</p>
<p>在书中，Alex用于定义/构建数学系统的篇幅很小，也就是第一章（“基础”，14页）。而在这14页中，用于讨论“数/数据”的篇幅更少，大概只有3~4个小节。在全书接下来的篇幅中，Alex就基于这样的数学系统开始设计和分析算法，并以之解决实际问题了。</p>
<p>这与我在《程序原本》中讲述的内容与方法完全不同，并且存在着根本观念上的不同。在《程序原本》的第一个小节中，我就通过一个断言“算是程序之表，数是程序之本”，将整本书定调在了对“数”的讨论之中。由数的结构化延伸到算的结构化，以及后面的应用和系统的结构化，其本质上是在讨论：如今在“程序”中出现的种种元素，无非是大家在“结构化”这一个求解方向上的所得。因此我才在《我的架构思想》中提出了我对这所有观察作出的结论：程序是可被组织的元素。并由此提出进一步的观点：结构化——只是“程序是什么”的一个解，而绝非唯一解。</p>
<p>所以，我其实是在讨论“程序（Program）的原本”，而Alex在讨论的是“编程（Programming）的原本”。正是因此，《程序原本》中看到的就是数据，或者结构化视角下的可组织元素；《编程原本》中看到的就是数学系统，以及由此构建的算法与实现。</p>
<p>在<code>算法 + 数据结构 = 程序</code>这个经典的描述中，我讨论的是“数据结构”的问题，并进一步的讨论了“对数据、算法和程序的结构化”的问题，而Alex讨论的是算法问题。源于这种分析问题的剖面不同，Alex的《编程原本》要求读者有较高的数学基础，而《程序原本》则几乎对此没有什么要求——所以你看我在致谢中就只感谢了“我的小学数学老师”。^^.</p>
<p>不过《程序原本》要求你有很好的抽象思维能力，你可以把整本书看成一个完整的抽象思维与论证的训练——如何拿着最基础、简单的“数”的概念与原则，构建出对整个的系统描述。这本书回顾了你所有见到过的“程序”的样子，以及这些“样子”背后的逻辑，但是却并不教你写一行有效的代码、一个有用的算法，或者一个看起来有明确运行逻辑的系统。</p>
<p>算是程序之表，数是程序之本。</p>
<blockquote>
<p>又：</p>
<p>我最终觉得我在这本书的英文译名上还是犯了“严重且不可饶恕的错误”，所以只好悻悻然地将所有已经用过英文名的地方（例如github上）都进行了修改。我的《程序原本》这本书，今后就只用*&quot;Elements of Program&quot;*这个英文的书名吧。</p>
<p>好象更确切的译法是*“Elements of Programs”<em>？比如“算法 + 数据结构 = 程序”原书名就是</em>&quot;Algorithms + Data Structures = Programs&quot;*。算了，就这样吧！我的英文还没有好到可以较真这个东西的地步😹</p>
</blockquote>
</div>]]></content:encoded></item><item><title><![CDATA[Monster的三种工作模式]]></title><description><![CDATA[<div class="kg-card-markdown"><p>Monster有三种工作模式generate、update和preview。可以通过Monster的第一个参数来指定，在第一个参数缺省时直接使用generate模式。例如：</p>
<pre><code class="language-bash"># 下面两个指令是相同的
&gt; monster --generate
&gt; monster generate --generate
</code></pre>
<p>但Monster也有自己的<code>--help</code>参数，所以与generate模式下的<code>--help</code>参数不一致，后者显示的<code>makesite.sh</code>的帮助：</p>
<pre><code class="language-bash"># 显示monster的帮助
&gt; monster --help
# 显示generate模式(即makesite.sh)的帮助
&gt; monster generate --help
</code></pre>
<p>工作模式<code>preview</code>是非常简单的，它只是调用python来开启一个web服务器，这样你就可以在本地预览生成的页面文件了。</p>
<pre><code class="language-bash"># 可以指定端口地址（缺省为8000）
&gt; monster preivew 8010
Serving HTTP on 0.</code></pre></div>]]></description><link>http://aimingoo.github.io/1-1744/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c1</guid><category><![CDATA[Monster]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Thu, 21 Sep 2017 15:50:03 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>Monster有三种工作模式generate、update和preview。可以通过Monster的第一个参数来指定，在第一个参数缺省时直接使用generate模式。例如：</p>
<pre><code class="language-bash"># 下面两个指令是相同的
&gt; monster --generate
&gt; monster generate --generate
</code></pre>
<p>但Monster也有自己的<code>--help</code>参数，所以与generate模式下的<code>--help</code>参数不一致，后者显示的<code>makesite.sh</code>的帮助：</p>
<pre><code class="language-bash"># 显示monster的帮助
&gt; monster --help
# 显示generate模式(即makesite.sh)的帮助
&gt; monster generate --help
</code></pre>
<p>工作模式<code>preview</code>是非常简单的，它只是调用python来开启一个web服务器，这样你就可以在本地预览生成的页面文件了。</p>
<pre><code class="language-bash"># 可以指定端口地址（缺省为8000）
&gt; monster preivew 8010
Serving HTTP on 0.0.0.0 port 8010 ...
</code></pre>
<h2 id="generateupdate">generate与update模式的原理不同</h2>
<p>generate工作模式定义了一个对“网站迁移的标准过程”的理解，亦即是分成四步：</p>
<ul>
<li>generate: 调用wget生成静态页</li>
<li>reset-domain：重置页面中的domain地址（它有两个前置过程）
<ul>
<li>pick-sitemap：尝试下载sitemaps文件</li>
<li>patch-version：修补assets等目录中的文件名后缀中的版本号</li>
</ul>
</li>
<li>short-path: 生成简短的网页路径</li>
<li>deploy-now: 部署到Github仓库（它有一个前置过程）
<ul>
<li>check-static：检查reset-domain过程之后的static目录</li>
</ul>
</li>
</ul>
<p>这个迁移并不是特指针对于Git Pages（xxxx.github.io）的，因此generate模式可以在非Ghost博客上正常工作，并且也可以将生成的静态网页Delpoy到非Git Pages的网站上去。所谓“Ghost -&gt; Git Pages”只是上述过程的一个运用而已。</p>
<p>generate工作模式在网页抓取上并不“积极”，它只是使用wget对Site入口（<code>/index.html</code>）进行深度递归并下载所有页面以及图片等等其它附件与资源而已。相对于Buster，它最大的进步是定义和有效利用了上述的四个阶段。</p>
<p>工作模式update在原理上就与generate不同。update工作模式是直接依赖Ghost的数据库文件的，它必须位于Monster可访问的路径上。update工作模式并没有上述的四个阶段，它缺省就直接读取数据库中最新的条目，并根据其title直接使用wget下载该页面和可能的资源。</p>
<p>update工作模式只有<code>fetch</code>和<code>deploy</code>两种行为。其中<code>fetch</code>行为是默认总是进行——除了在使用<code>--deploy-only</code>参数的情况下，而<code>deploy</code>行为是由<code>--deploy-now</code>或<code>--deploy-only</code>来触发的。</p>
<p>update工作模式的<code>deploy</code>行为是直接调用generate模式来实现的，所以事实上二者在Deploy功能上完全一致——只是在调用时，update模式会把<code>--pick-sitemap</code>和<code>--short-path</code>置为false，因为这两个步骤已经在update工作模式中处理过了，不需要generate模式去处理。</p>
<p>在update工作模式之内，<code>--pick-sitemap</code>和<code>--short-path</code>缺省是打开的，并且总是“推荐”使用short path——这在update工作模式中是更佳的选择。</p>
<h2 id="generate">generate模式的缺省行为</h2>
<p>下面的代码将直接调用generate模式的缺省行为：</p>
<pre><code class="language-bash">&gt; monster generate
</code></pre>
<p>在缺省情况下，Monster相关的配置如下：</p>
<pre><code class="language-bash"># GENERATE过程
GENERATE=false

# RESET_DOMAIN过程
PICK_SITEMAP=true
PATCH_VERSION=true
RESET_DOMAIN=true

# SHORT_PATH过程
SHORT_PATH=false

# DEPLOY过程
CHECK_STATIC=true
DEPLOY_NOW=false
</code></pre>
<p>因此generate模式缺省会跳过GENERATE过程，然后：</p>
<ul>
<li>判断Static path（例如缺省的<code>./static</code>）是否有效</li>
</ul>
<p>如果<code>./static</code>不存在，那么直接退出并提示：</p>
<blockquote>
<p>Abort because have not './static' directory.</p>
</blockquote>
<p>否则接下来处理：</p>
<ul>
<li>首先根据<code>PICK_SITEMAP</code>和<code>PATCH_VERSION</code>的配置来处理<code>RESET_DOMAIN</code>的前置过程；然后，</li>
<li>将检查生成文件的<code>SITE</code>值与发布到的<code>DOMAIN</code>地址，如果不一样（例如想从本地site生成文件并发布到domain），重置Static目录中所有文件中的domain值（<code>RESET_DOMAIN</code>）。</li>
</ul>
<p>最后跳过SHORT_PATH过程，并：</p>
<ul>
<li>检查一次Static目录中的文件是否都重置过domain（<code>CHECK_STATIC</code>）。</li>
</ul>
<h2 id="update">update模式的缺省行为</h2>
<p>下面的代码将直接调用update模式的缺省行为：</p>
<pre><code class="language-bash">&gt; monster update
</code></pre>
<p>对于update模式来说，以下参数是缺省置为true值的：</p>
<pre><code class="language-bash">PICK_ROBOTS_TXT=true
PICK_SITEMAP=true
SHORT_PATH=true
RESET_DOMAIN=true
</code></pre>
<p>前面说过：update与generate的行为逻辑很不一样。update模式的<code>fetch</code>行为看起来总是更“贪婪”的：</p>
<ul>
<li>它将尝试获取全部更新文件（依赖.sqlitedb中的信息来分析），并且如果发现有新的post创建，就会尝试获取全部列表文件——例如作者文章列表，以及首页文章索引等（包括<code>PICK_ROBOTS_TXT</code>、<code>PICK_SITEMAP</code>等等）。</li>
<li>一旦上述过程完成，<code>fetch</code>行为将进一步地检查Static目录，由于<code>SHORT_PATH</code>为true，所以它会尝试将Url中的路径变短。</li>
<li>最后，update模式会进入<code>RESET_DOMAIN</code>过程，并传入参数<code>--generate=false --pick-sitemap=false --short-path=false</code>以避免makesite.sh模块重复操作。</li>
</ul>
<p>update模式缺省并不Deploy（除非你在命令行上指定了<code>--deploy-now</code>，它缺省是false值）。</p>
<p>你无法让update过程什么也不做，这一点也与generate不同。唯一可算作例外的，是如果上一次update之后在Ghost中什么变化也没有（没有添加、删除或更新post），那么在update时就不会获得什么更新数据，也不会创建<code>./static</code>目录：</p>
<pre><code class="language-bash">&gt; monster update
Pick updated or new files ...

Try refresh author's pages ...
&gt; Skiped.
Abort because have not './static' directory.
</code></pre>
<h2 id="">开始构建你的网站</h2>
<p>你可以从一开始就选择两种工作模式之一。generate模式每一次总是做全站生成，而update模式只在第一次调用时，读sqlite库中的全部post做一次全站生成——并且部署。</p>
<p>如果你使用过<code>monster update --deploy-now</code>一次，那么Monster会在当前目录下生成一个<code>.sqlitedb</code>文件，用于存储数据库状态的一个时间点——以便下次update增量。</p>
<p>如果已经在用<code>monster generate</code>来直接做全站生成和部署了，那么第一次使用update工作模式时，可以使用下面的命令：</p>
<pre><code class="language-bash">&gt; monster update --init
File .sqlitedb saved.
</code></pre>
<p>这并不真的部署和更新任何东西，只是将<code>.sqlitedb</code>对齐到当前数据库。——之后，无论是<code>--deploy-now</code>还是<code>--deploy-only</code>，update模式每次都会更新<code>.sqlitedb</code>。</p>
<h2 id="generate">generate模式下的参数</h2>
<p>除了需要显式地用<code>monster generate --help</code>显示帮助信息之外，其它情况下都可以省掉第一个参数<code>generate</code>。其它的参数包括：</p>
<pre><code>#
# 参数开关，--paramName=true/false，只用--paramName相当于指定true
#

## 四个主要过程
# - 生成全站
--generate
# - 重置静态页中的domain(缺省为true)
--reset-domain
# - 生成短的Url路径
--short-path
# - 调用Git部署
--deploy-now

## 'RESET_DOMAIN'的前置操作(缺省为true)
# - 下载sitemap文件
--pick-sitemap
# - 修正文件名中的版本信息
--patch-version

## 'DEPLOY_NOW'的前置操作(缺省为true)
# - 检查Static目录中的静态页是否已经重置过domain
--check-static

## 在generate过程中是否显示更详细的信息(缺省为false)
--generate-info

#
# 传入其它配置值（字符串）
#

## 部署到的domain
--domain=&quot;...&quot;

## 下载静态页的Site，支持https
--site=&quot;http://...&quot;

## 存放静态页的目录
--static-path=&quot;...&quot;

#
# 其它
#

## 显示帮助
--help

## 显示版本号
--version
</code></pre>
<h2 id="update">update模式下的参数</h2>
<p>可以用<code>monster update</code>来按缺省配置运行udpate模式。其它的参数包括：</p>
<pre><code class="language-bash">#
# 参数开关，--paramName=true/false，只用--paramName相当于指定true
#

## 与Fetch和Deply行为相关
#- 是否调用reset-domain过程(缺省为true)
--reset-domain
#- 是否使用短路径(缺省为true)
--short-path
#- 在Fetch行为中，尝试为remove post行为而更新所有索引页
--sync-removed
#- 直接部署
--deploy-now
#- 不fetch文件，只部署Static目录
--deploy-only


## 特定文件获取
#- 总是下载/tag-cloud
--pick-static-tagcloud
#- 总是下载/profile-xxx
--pick-static-profile
#- 总是下载/archive-post
--pick-archive-post
#- 总是下载/robot.txt
--pick-robot-txt
#- 总是下载sitemap文件
--pick-sitemap
#- 强制下载上述--pick-xxxx和索引页等文件
--force


#
# 传入其它配置值（字符串）
#

## 部署到的domain
--domain=&quot;...&quot;
#- 在使用'--sync-issue'功能时，在Issue body中写入的Url上使用的协议名，缺省为'https'
--protocol=&quot;...&quot;

## 下载静态页的Site，支持https
--site=&quot;http://...&quot;

## 存放静态页的目录
--static-path=&quot;...&quot;

## 本地Ghost的数据库文件路径
--db=&quot;...&quot;

## 本地Ghost登录帐号，可以用'monster --list user'查看
#- (帐号邮箱)
--email=&quot;...&quot;

## 一个标记字符串，极少使用
#-（仅在update功能中用于检查特定文件中是否包含该字符串，以确保整个内容有效）
--ad-token=&quot;...&quot;
</code></pre>
<p>此外，Monster还在update工作模式下提供了一些直接命令，它们与一个（类似上述的）更新和部署过程无关，例如<code>—help</code>。这些命令包括：</p>
<pre><code class="language-bash">#
# 直接指令
#

## 生成.sqlitedb文件，对齐当前数据库
# - 'checksums'参数是仅仅由Monster内部使用的
--init [checksums]

## 将所有post的slug修改成'authorId-postId'格式
# - 这意味着生成的Url会是短路径名
--sync-slug

## 在对应的Github仓库中，为所有的post生成Gitment格式的Issue
# - Gitment需要用户为每个Post点一次创建Issue按钮，本功能可自动完成
# - 生成的Issue有两个标签：'${slug}'和'gitment'
# - 会忽略掉已经生成过的Issue，不会重复生成
--sync-issue

## 列出unment或user
# - unment是指“未创建Gitment格式Issue”的post
# - user是指Ghost库中的用户名
--list &lt;unment|user&gt;]

## 显示帮助
--help

## 显示版本号
--version
</code></pre>
<p><strong>关于<code>--sync-removed</code>参数</strong></p>
<p>Monster是通过记录数据库中的时间点的方法，来实现增量更新的。由于Ghost并没有在数据库中记录删除post的行为，也并不导致时间点变化，所以Monster也并没有办法简单确认当前Ghost环境中删除过post。</p>
<p>因此一旦用户只删除了post——而又没有任何其它添加或更新操作的话，那么就需要用下面的命令来提交一次update：</p>
<pre><code class="language-bash">&gt; monster --sync-removed --deploy-now
</code></pre>
<p>这个命令将会重建所有的索引页、标签页等，以便体现删除post这样的操作。</p>
<p>但是有一个小的问题：如果有“上一篇”、“下一篇”这样的导航，那么被删除post的链接仍然会出现在其它post页面上。——不过，由于是增量更新，所以这个链接仍然是可用的。换言之，被删除的post只是不再出现在各种列表页中，并没有真正移除。</p>
<p>很遗憾，目前这是无法直接解决的。</p>
<blockquote>
<p>注1：你可以删除<code>.sqlitedb</code>文件再执行<code>monster update</code>，这样可以全站重新生成一次，就可以了。</p>
<p>注2：monster只是从Static目录中复制了文件覆盖你的git仓库，这意味着它并没有<code>git rm …</code>来删除仓库中的既有文件——例如你刚刚删除掉的那个post。也就是说，即使你重新全站生成并deploy，那个post已经上传的的静态网页也仍然需要你手工从git仓库中删除。</p>
</blockquote>
<p><strong>关于<code>--force</code>参数</strong></p>
<p>这是一个用在update工作模式下的比较特别的参数。</p>
<p>前面说过，update工作模式是根据sqlite数据库的状况来实现的。这样一来，某些页面（通常是指定为static的、由特定模板或生成算法动态生成的网页）就不能被更新。在Ghost系统中，这些页面包括author和tag的索引页，以及手工定制的一些类似profile的页面。</p>
<p>当Monster发现有一个post新建的时候，它将认为所有上述页面都可能导致变化，所以就会主动（贪婪）地更新这些页面。但如果没有post新建——而只是更新了既有post，那么由于感知不到上述变化，所以就需要用<code>--force</code>来强制生成这些页面。</p>
<p>Monster不可能穷举所有类似的页面，所以在后续的版本中可能会提供一个机制来让用户定制这个页面列表。就目前而言，如果你有更多页面要处理，你只能手工修改updatesite.sh模块。这个文件位置在：</p>
<pre><code class="language-bash">&gt; brew list monster | grep updatesite
/usr/local/Cellar/monster/xxxx/libexec/updatesite.sh
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[详解Monster的初始化及配置]]></title><description><![CDATA[<div class="kg-card-markdown"><p>尽管Monster并不强制你创建与初始化工作目录，并且也不强制依赖Ghost来工作，但是“Ghost + 工作目录”仍然<br>
是Monster的最佳使用场景。</p>
<blockquote>
<p>关于在没有Ghost的情况下使用Monster的说明请看这里：<a href="http://aimingoo.github.io/1-1743">将Monster用作网站离线下载的方法</a>。</p>
</blockquote>
<h2 id="">预备工作</h2>
<ul>
<li>你需要先启动Ghost并了解它运行在的本地地址</li>
</ul>
<pre><code class="language-bash">&gt; npm start
Ghost is running in development... 
Listening on 127.0.0.1:2368 
...
</code></pre>
<p>Ghost可以运行在不同的模式下，上面的是<code>development</code>模式，这种情况下它的缺省端口是<code>:2368</code>。</p>
<p>另外，你需要找到Ghost运行的目录中的sqlite数据库文件。假设你的Ghost运行的目录是在<code>${GHOST}</code>，那么这些数据文件的位置是在：</p>
<pre><code class="language-bash">&gt; grep -Fe '.db' ${GHOST}/config.js
filename: path.join(__dirname, '/</code></pre></div>]]></description><link>http://aimingoo.github.io/1-1742/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5bf</guid><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Monster]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 19 Sep 2017 19:43:06 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>尽管Monster并不强制你创建与初始化工作目录，并且也不强制依赖Ghost来工作，但是“Ghost + 工作目录”仍然<br>
是Monster的最佳使用场景。</p>
<blockquote>
<p>关于在没有Ghost的情况下使用Monster的说明请看这里：<a href="http://aimingoo.github.io/1-1743">将Monster用作网站离线下载的方法</a>。</p>
</blockquote>
<h2 id="">预备工作</h2>
<ul>
<li>你需要先启动Ghost并了解它运行在的本地地址</li>
</ul>
<pre><code class="language-bash">&gt; npm start
Ghost is running in development... 
Listening on 127.0.0.1:2368 
...
</code></pre>
<p>Ghost可以运行在不同的模式下，上面的是<code>development</code>模式，这种情况下它的缺省端口是<code>:2368</code>。</p>
<p>另外，你需要找到Ghost运行的目录中的sqlite数据库文件。假设你的Ghost运行的目录是在<code>${GHOST}</code>，那么这些数据文件的位置是在：</p>
<pre><code class="language-bash">&gt; grep -Fe '.db' ${GHOST}/config.js
filename: path.join(__dirname, '/content/data/ghost.db')
filename: path.join(__dirname, '/content/data/ghost-dev.db')
filename: path.join(__dirname, '/content/data/ghost-test.db')
</code></pre>
<p>根据你启动的Ghost的版本不同，选择上面的一个库文件即可（一般是<code>ghost-dev.db</code>）。</p>
<ul>
<li>(<strong>discard</strong>)你需要安装Buster并确信它可用</li>
</ul>
<blockquote>
<p>在Monster早期版本中是调用Buster来生成全站的，但从v1.0.5版本开始就移除了对Buster的依赖。</p>
</blockquote>
<ul>
<li>你需要确信mac环境是否能运行Monster</li>
</ul>
<p>Monster依赖mac环境上的一些工具。如果你使用brew，那么可以用下面的命令来安装它：</p>
<pre><code class="language-bash">&gt; brew install wget jq curl
...
</code></pre>
<p>其它还会使用到的工具包括<code>sqlite3</code>、<code>sum</code>和<code>git</code>：<code>sqlite3</code>应该已经在安装Ghost时安装过了，而<code>sum</code>是MacOSX原生自带的；多数情况下，建议你安装<code>git</code>，使用<code>brew install git</code>即可。</p>
<blockquote>
<p><strong>注：</strong></p>
<p>Monster主要是用于生成静态网页，只有当你使用它的部署(deploy)功能时，才会用到<code>git</code>。所以事实上git并不是必须安装。</p>
<p>Monster使用Git api访问github issues，所以在使用评论相关的功能时并不要求安装git客户端。</p>
</blockquote>
<ul>
<li>最后，你需要安装Monster</li>
</ul>
<p>有两种方法安装Monster：</p>
<pre><code class="language-bash"># 使用Brew安装
&gt; brew install aimingoo/repo/monster

# 使用Git仓库安装
&gt; git clone https://github.com/aimingoo/monster
&gt; ln -s &quot;$(pwd)/monster/libexec/monster.sh&quot; /usr/local/bin/monster
&gt; chmod +x /usr/local/bin/monster
</code></pre>
<h2 id="">初始化及配置</h2>
<pre><code class="language-bash"># 创建一个目录，并在该目录中运行如下命令
&gt; monster --init
Your Github name or domain : aimingoo
Your Github access token, or Enter to skip: 
Your Ghost local account(e-mail), or Enter to skip: 
Your Ghost local .db file, or Enter to skip: 
Your Ghost site, or Enter set default [localhost:2368]: 
File .monster saved.
File .gitignore updated.
</code></pre>
<p>第一项配置<code>Github name or domain</code>总是必须输入的。它可以是一个名为<code>xxxx.github.io</code>的域名，或只是<code>xxxx</code>这样的域名前缀（亦即是Github用户账号名），此外还可以是一个非github的域名，例如<code>your.site.com</code>。</p>
<h3 id="domain">如果domain是无效的</h3>
<p>你可以使用任何domain——哪怕它不是真实的值。Monster的基本逻辑是：</p>
<ul>
<li><strong>GENERATE</strong>：下载一个<code>SITE</code>上的网页，放在<code>STATIC_PATH</code>中；并尝试</li>
<li><strong>RESET_DOMAIN</strong>：将网页中有关<code>SITE</code>的信息替换成<code>DOMAIN</code>；以及</li>
<li><strong>DEPLOY_NOW</strong>：将<code>STATIC_PATH</code>中的文件复制到当前目录，并尝试将当前目录作为Git仓库来部署。</li>
</ul>
<p>所以只要不启用RESET_DOMAIN（传入<code>--reset-domain=false</code>参数或者修改<code>.monster</code>配置），那么无效的DOMAIN是不影响Monster的使用的。</p>
<h3 id="domain">如果domain是空值</h3>
<p>在调用<code>monster --init</code>并输入缺省配置时，是不能使domain值为空的。</p>
<p>你可以编辑<code>.monster</code>以使该参数值为空，但这样的配置仅对update工作模式是有意义的。这会缺省使用<code>&lt;GITHUB_USER&gt;.github.io</code>来作为DOMAIN值，如果在update工作模式中调用了<code>--deploy-now</code>、<code>--deploy-only</code>或<code>--reset-domain</code>，那么该值也会通过命令行参数传入<code>makesite.sh</code>，以确保后者可用。</p>
<p>你不应当使<code>.monster</code>文件中的<code>DOMAIN</code>和<code>GITHUB_USER</code>值同时为空值。——如果是这样，你就必须总是从命令行中传入参数了。</p>
<h3 id="domain">关于domain的协议</h3>
<p>由于Monster并不访问你的domain（它只是更新本地静态网页中的内容），所以在配置文件中并不需要指定domain使用的协议，例如<code>https</code>或<code>http</code>。但有一个极小极小的例外，如果：</p>
<ul>
<li>你使用了Git issues来作评论，并且</li>
<li>你的domain并没有host在<code>xxxx.github.io</code>上，并且</li>
<li>你还打算使用Monster的<code>update --sync-issue</code>来管理它，</li>
</ul>
<p>那么你需要修改<code>.monster</code>中的<code>PROTOCOL</code>参数，缺省时它的值是<code>https</code>。</p>
<h3 id="monster">如果没有<code>.monster</code>文件</h3>
<p>如果你没有调用<code>monster --init</code>来初始化一个<code>.monster</code>文件，或者你误删除了它，那么你事实上仍然是可以使用Monster的。</p>
<p>这种情况下，对于generate工作模式来说，你必须从命令行通过<code>--domain</code>传入DOMAIN参数；对于update工作模式来说，则必须传入<code>--db</code>。当然你还可能需要传入其它在运行中要用到的参数，例如<code>GITHUB_USER</code>。</p>
<h2 id="monster">配置文件.monster的详细说明</h2>
<pre><code>## Github domain
#  - （参见上文）
DOMAIN=&quot;...&quot;

## Ghost .db file path
# - update工作模式下的相关功能依赖该配置
DB=&quot;/User/...&quot;

## Ghost site address
# - 要静态化（下载）的网站，可以是本地Ghost或远端的任何网址
# - 可以是任何网站（不是Ghost的网站，甚至不是博客）
SITE=&quot;http://...&quot;

## Github account, and rate of api access
# - 你的Github账号，是指当前工作目录对应的xxxx.github.io
GITHUB_USER=&quot;Your name&quot;
# - 你需要在Github后台为Git client创建一个Access token
GITHUB_TOKEN=&quot;Access token&quot;
# - 每次Github API访问之后sleep的时间（单位为秒）；当值为1时，意味着每分钟不会超过60次访问
GITHUB_APIRATE=1
# - 当读取Gitment等博客评论时，每次用Github取数据时的页大小（缺省为每页100条记录）
GITHUB_PAGESIZE=100

## Other
# - 你在本地Ghost中的登录帐号
EMAIL=&quot;...&quot;
# - 特殊情况下需要用到的domain的协议值（参见上文）
PROTOCOL=&quot;https&quot;

## Advertisement token string for your site
# - 一个标记字符串，极少使用（仅在update功能中用于检查特定文件中是否包含该字符串，以确保整个内容有效）
AD_TOKEN=&quot;&quot;

## Default directory of static files
# - 生成静态文件的路径
# - （对于Monster的preview工作模式来说，必须使用该配置而不能用命令行传入参数）
STATIC_PATH=&quot;./static&quot;

## Default behavior
# - 在GENERATE阶段中显示更多信息
GENERATE_INFO=false
# - 在update工作模式下，强制更新列表类网页
SYNC_REMOVED=false
# - 在操作过程中是否移除static目录中的文件名的'?xxxxxx'版本后缀
PATCH_VERSION=true
# - 是否启用RESET_DOMAIN阶段
RESET_DOMAIN=true
# - 是否启用SHORT_PATH阶段
SHORT_PATH=false
# - 是否启用CHECK_STATIC阶段
CHECK_STATIC=true

## Pick more files
# - 是否拾取静态化的云标签文件/tag-cloud
PICK_STATIC_TAGCLOUD=false
# - 是否拾取静态化的profile文件/profile-xxx
PICK_STATIC_PROFILE=false
# - 是否拾取静态化的归档文件/archive-post
PICK_ARCHIVES_POST=false
# - 是否拾取/robots.txt
PICK_ROBOTS_TXT=true
# - 是否拾取sitemap文件/sitemap-*
PICK_SITEMAP=true
# - 在update工作模式下，强制尝试上述PICK_xxxx和索引页等文件
FORCE=false

## Other override
# - 在SHORT_PATH阶段中不处理的目录名
IGNORE_LIST=(&quot;archives-post&quot; &quot;author&quot; &quot;page&quot; &quot;rss&quot; &quot;tag&quot; &quot;assets&quot; &quot;content&quot; &quot;shared&quot;)
# - 在PATCH_VERSION阶段中需要处理的目录名
VERDIR_LIST=(&quot;assets&quot; &quot;shared&quot; &quot;public&quot;)
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[将Monster用作网站离线下载的方法]]></title><description><![CDATA[<div class="kg-card-markdown"><p>没有Ghost也是可以运行Monster，有极少功能是为这种情况准备的，例如用来作网站的离线下载。</p>
<h3 id="">在非工作目录中（不推荐）</h3>
<ul>
<li>将网站全站下载到<code>./static</code>目录</li>
</ul>
<pre><code class="language-bash"># 由于site与domain相同，所以不会触发reset-domain操作
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=&quot;your.site.com&quot;

# OR，置reset-domain为false
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=. --reset-domain=false
</code></pre>
<ul>
<li>对<code>./static</code>目录中的静态页面作<code>reset-domain</code>操作（缺省该选项是打开的）</li>
</ul>
<pre><code class="language-bash">&gt; monster --domain=</code></pre></div>]]></description><link>http://aimingoo.github.io/1-1743/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5c0</guid><category><![CDATA[Monster]]></category><category><![CDATA[博客]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 19 Sep 2017 19:42:58 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>没有Ghost也是可以运行Monster，有极少功能是为这种情况准备的，例如用来作网站的离线下载。</p>
<h3 id="">在非工作目录中（不推荐）</h3>
<ul>
<li>将网站全站下载到<code>./static</code>目录</li>
</ul>
<pre><code class="language-bash"># 由于site与domain相同，所以不会触发reset-domain操作
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=&quot;your.site.com&quot;

# OR，置reset-domain为false
&gt; monster --generate --site=&quot;http://your.site.com&quot; --domain=. --reset-domain=false
</code></pre>
<ul>
<li>对<code>./static</code>目录中的静态页面作<code>reset-domain</code>操作（缺省该选项是打开的）</li>
</ul>
<pre><code class="language-bash">&gt; monster --domain=&quot;your.site.com&quot;
</code></pre>
<ul>
<li>预览<code>./static</code>目录中的静态页面</li>
</ul>
<pre><code class="language-bash">&gt; monster preview
</code></pre>
<h3 id="">初始化一个工作目录用来下载</h3>
<p>我们可以将一个目录初始化，用作专门的网络离线下载（备份/归档）。</p>
<p><strong>初始化一个工作目录</strong></p>
<pre><code class="language-bash"># 直接用--init初始化一个工作目录，除了domain之外其它的跳过
#	- 随便填写一个domain地址即可，例如填写一个“.”符号
&gt; monster --init
Your Github name or domain: .
...

# 置RESET_DOMAIN=false
&gt; sed -i '' 's/[# ]*\(RESET_DOMAIN\)=.*/\1=false/' .monster

# 添加一行配置
&gt; echo &quot;GENERATE=true&quot; &gt;&gt; .monster
</code></pre>
<p><strong>常用操作</strong></p>
<pre><code class="language-bash"># 下载一个站点(例如https://aimingoo.github.io)
&gt; monster --site=&quot;https://aimingoo.github.io&quot;

# 将站点下载到指定目录
&gt; monster --site=&quot;https://aimingoo.github.io&quot; --static-path=&quot;./archive&quot;

# 不尝试下载sitemap文件
&gt; monster --site=&quot;https://aimingoo.github.io&quot; --pick-sitemap=false
</code></pre>
</div>]]></content:encoded></item><item><title><![CDATA[Monster - 用Ghost写博客的终极利器]]></title><description><![CDATA[<div class="kg-card-markdown"><h2 id="bustermonster">是时候从Buster转到Monster了</h2>
<p>我最先开始用Ghost写博客时，用来生成静态页面（并发布到<a href="https://aimingoo.github.io">aimingoo.github.io</a>）的工具是Buster。首先它确实不太好用，其次用它生成（generate）出来的页面还需要做许多的后续处理才能使用。由于这个缘故，我写了Monster这个工具的第一代产品并放在了我的<a href="https://github.com/aimingoo/ghost-utils">ghost-utils</a>仓库中，名为<code>makesite.sh</code>。</p>
<p><code>makesite.sh</code>其实是类似Buster的。由于采用了相同的实现方案，所以也就有着Buster的最根本的问题：每次都要对全站做重新生成。为此，我另外又写了一个脚本，名为<code>updatesite.sh</code>，用来实现增量生成基于Ghost的静态网站。</p>
<p>再之后，将这两个脚本合在一起，就变成了：</p>
<blockquote>
<p><strong>Monster</strong>，一个同时支持全量和增量生成Ghost静态网站的工具。</p>
</blockquote>
<p>这是一个用Bash写开源项目，Github地址在这里: <a href="https://github.com/aimingoo/monster">https://github.com/aimingoo/monster</a></p>
<blockquote>
<p><strong>注：</strong><code>makesite.sh</code>在早期就是Buster一个壳，从v1.0.5版本开始直接使用wget而不再依赖Buster。</p></blockquote></div>]]></description><link>http://aimingoo.github.io/1-1741/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5be</guid><category><![CDATA[OpenSource Project]]></category><category><![CDATA[博客]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[Monster]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 19 Sep 2017 07:27:23 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><h2 id="bustermonster">是时候从Buster转到Monster了</h2>
<p>我最先开始用Ghost写博客时，用来生成静态页面（并发布到<a href="https://aimingoo.github.io">aimingoo.github.io</a>）的工具是Buster。首先它确实不太好用，其次用它生成（generate）出来的页面还需要做许多的后续处理才能使用。由于这个缘故，我写了Monster这个工具的第一代产品并放在了我的<a href="https://github.com/aimingoo/ghost-utils">ghost-utils</a>仓库中，名为<code>makesite.sh</code>。</p>
<p><code>makesite.sh</code>其实是类似Buster的。由于采用了相同的实现方案，所以也就有着Buster的最根本的问题：每次都要对全站做重新生成。为此，我另外又写了一个脚本，名为<code>updatesite.sh</code>，用来实现增量生成基于Ghost的静态网站。</p>
<p>再之后，将这两个脚本合在一起，就变成了：</p>
<blockquote>
<p><strong>Monster</strong>，一个同时支持全量和增量生成Ghost静态网站的工具。</p>
</blockquote>
<p>这是一个用Bash写开源项目，Github地址在这里: <a href="https://github.com/aimingoo/monster">https://github.com/aimingoo/monster</a></p>
<blockquote>
<p><strong>注：</strong><code>makesite.sh</code>在早期就是Buster一个壳，从v1.0.5版本开始直接使用wget而不再依赖Buster。</p>
</blockquote>
<h2 id="monster">Monster的功能</h2>
<ul>
<li>全量和增量生成Ghost静态网站</li>
<li>可以在本地预览或向<code>github.io</code>部署生成的网站</li>
<li>支持生成并不Host在<code>github.io</code>上的网站</li>
<li>支持同时管理多个网站，独立配置</li>
<li>支持在url中使用缩短路径的风格（使用更精减的ghost slug）</li>
<li>支持Ghost的多作者（multi-author）功能</li>
<li>支持基于github issues的评论管理（面向gitment的工具功能）</li>
</ul>
<h2 id="monster">安装Monster</h2>
<pre><code class="language-bash">&gt; brew install aimingoo/repo/monster
</code></pre>
<h2 id="">快速上手</h2>
<pre><code class="language-bash"># 了解ghost运行的本地地址(例如下面的127.0.0.1:2368)
&gt; npm start
Ghost is running in development... 
Listening on 127.0.0.1:2368 
...

# 如果你已经在Github上创建了自己的pages，那么你应该先将它clone到本地
#  - (设网站domain为xxxx.github.io)
&gt; git clone 'https://github.com/xxxx/xxxx.github.io'

# 配置初始化(用上面的项目作为工作目录)
#	- 可以不使用xxxx.github.io，而使用自己的domain，例如your.site.com
#	- 路径&quot;Ghost local .db file&quot;可用如下命令查看(或先略过它)：
#		&gt; grep -Fe '.db' ${GHOST安装目录}/config.js
&gt; cd xxxx.github.io
&gt; monster --init
Your Github name or domain: xxxx
Your Github access token, or Enter to skip: 
Your Ghost local account(e-mail), or Enter to skip: 
Your Ghost local .db file, or Enter to skip: 
Your Ghost site, or Enter set default [localhost:2368]: 
...

# 全站生成
&gt; monster --generate

# 更新
&gt; monster update

# 预览(ctrl+c退出)
&gt; monster preview
Serving HTTP on 0.0.0.0 port 8000 ...

# 发布/部署(在生成全站之后)
&gt; monster --deploy-now
# 或发布更新（在使用'monster update'之后）
&gt; monster update --deploy-only

# 其它

# 直接生成全站并发布
&gt; monster --generate --deploy-now
# 或在更新后直接发布
&gt; monster update --deploy-now
</code></pre>
<h2 id="">工作目录</h2>
<p>在使用<code>monster --init</code>初始化之后，当前目录就被Monster视为工作目录。</p>
<p>Monster会根据当前目录下的<code>.monster</code>配置工作，因此只需要为多个site建立不同的目录，就可以管理multi-domain了。</p>
<p>Monster会操作和维护当前目录下的<code>./static</code>目录来生成静态文件，你可以通过上述的<code>.monster</code>配置来改变这个目录的位置。</p>
<p>最后，当前目录下的<code>monster.log</code>和<code>.sqlitedb</code>也是由Monster来管理的。你可以手工编写一个名为<code>patchme.sh</code>的文件来实现一些复杂的操作，如果它存在，那么Monster会调用并管理它。</p>
<p>Monster的多数操作信息会直接出现在控制台，只有<code>monster --generate</code>和<code>monster update</code>会操作monster.log文件，前者总是覆盖整个文件，而后者是追加日志。</p>
<p>Monster会维护<code>.gitignore</code>或<code>.git/info/exclude</code>文件来避免git将多余的文件push到仓库。所以，上述<code>./static</code>目录以及<code>.monster</code>、<code>.sqlitedb</code>、<code>patchme.sh</code>和<code>monster.log</code>等文件也已经加入了git的ingore list。</p>
<h2 id="">高级特性</h2>
<p>关于Monster的Git issues评论、short path、sync、multi author等特性，请参考：</p>
<p><strong>阅读列表</strong></p>
<ul>
<li><a href="http://aimingoo.github.io/1-1742">详解Monster的初始化及配置</a></li>
<li><a href="http://aimingoo.github.io/1-1743">将Monster用作网站离线下载的方法</a></li>
<li><a href="http://aimingoo.github.io/1-1744">Monster的三种工作模式</a></li>
</ul>
</div>]]></content:encoded></item><item><title><![CDATA[简单实现Ghost Theme的置顶效果]]></title><description><![CDATA[<div class="kg-card-markdown"><p>在<a href="http://aimingoo.github.io/1-1721">《手记3：实例教学之Ghost模板定制》</a>里面我提到了在Theme中“指定文章置顶”的方法，但说得不细致。这里便重新写一个简单的指引。</p>
<p>下面的内容以affinity为例，这个Theme在这里：<a href="https://github.com/Showfom/Affinity">https://github.com/Showfom/Affinity</a></p>
<h2 id="loop">找到loop</h2>
<p>在<code>affinity/partials</code>目录中的<code>loop.hbs</code>是一个关键文件，它通常如下结构（<a href="https://github.com/Showfom/Affinity/blob/master/affinity/partials/loop.hbs">代码在这里</a>）：</p>
<pre><code class="language-html">&lt;div class=&quot;content-cards&quot;&gt;
  {{#foreach posts}}
...
  {{/foreach}}
&lt;/div&gt;

{{!-- Previous/next page links - displayed on every page --}}
{{pagination}</code></pre></div>]]></description><link>http://aimingoo.github.io/1-1739/</link><guid isPermaLink="false">59dafc1a1e9aa777abb0d5bc</guid><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 09 Aug 2017 06:22:59 GMT</pubDate><content:encoded><![CDATA[<div class="kg-card-markdown"><p>在<a href="http://aimingoo.github.io/1-1721">《手记3：实例教学之Ghost模板定制》</a>里面我提到了在Theme中“指定文章置顶”的方法，但说得不细致。这里便重新写一个简单的指引。</p>
<p>下面的内容以affinity为例，这个Theme在这里：<a href="https://github.com/Showfom/Affinity">https://github.com/Showfom/Affinity</a></p>
<h2 id="loop">找到loop</h2>
<p>在<code>affinity/partials</code>目录中的<code>loop.hbs</code>是一个关键文件，它通常如下结构（<a href="https://github.com/Showfom/Affinity/blob/master/affinity/partials/loop.hbs">代码在这里</a>）：</p>
<pre><code class="language-html">&lt;div class=&quot;content-cards&quot;&gt;
  {{#foreach posts}}
...
  {{/foreach}}
&lt;/div&gt;

{{!-- Previous/next page links - displayed on every page --}}
{{pagination}}
</code></pre>
<p>我们将这一对<code>{{#foreach}}</code>标签中（含标签本身）的全部内容剪切出来，并放到一个新的的<code>partials/content_post.hbs</code>文件去。然后，将<code>content_post.hbs</code>复制一份，命名为<code>content_featured.hbs</code>。这样，在<code>partials</code>目录中就有了下面三个文件：</p>
<pre><code>partials/loop.hbs
partials/content_post.hbs
partials/content_featured.hbs
</code></pre>
<h2 id="loop">在loop中标记置顶贴</h2>
<p>现在<code>loop.hbs</code>中还有一对<code>div</code>标签：：</p>
<pre><code class="language-html">&lt;div class=&quot;content-cards&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>我们只需要把下面的代码直接复制到这一对标签之中，就好了：</p>
<pre><code class="language-html">&lt;!-- 置顶风格 --&gt;
{{^is &quot;paged&quot;}}
  {{! list all feated posts on top }}
  {{#is &quot;index&quot;}}
  {{#get &quot;posts&quot; filter=&quot;featured:true&quot; limit=&quot;all&quot; include=&quot;tags&quot; as |featured|}}
  {{#foreach featured}}
      {{&gt; content_featured}}
  {{/foreach}}
  {{/get}}
  {{/is}}

  {{#is &quot;author&quot;}}
  {{#get &quot;posts&quot; filter=&quot;featured:true+author:{{author.slug}}&quot; limit=&quot;all&quot; include=&quot;tags&quot; as |featured|}}
  {{#foreach featured}}
      {{&gt; content_featured}}
  {{/foreach}}
  {{/get}}
  {{/is}}
{{/is}}

&lt;!-- 普通风格 --&gt;
  {{#foreach posts}}
    {{#is &quot;tag&quot;}}
        {{&gt; content_post}}
    {{else}}
        {{#unless featured}}
        {{&gt; content_post}}
        {{/unless}}
    {{/is}}
  {{/foreach}}
</code></pre>
<h2 id="">设定置顶贴的效果</h2>
<p>现在你只需要修改<code>partials/content_featured.hbs</code>中的样式，就可以定制你需要的置顶贴的效果了。以affinity为例，我在<code>content_featured.hbs</code>中的下面代码位置添加了一个<code>featured</code>类名：</p>
<pre><code>      ...
      &lt;header class=&quot;card-header featured&quot;&gt;
        &lt;div class=&quot;card-title&quot;&gt;

</code></pre>
<p>然后，找到<code>assets/css/screen.css</code>文件，添加这个类的CSS样式：</p>
<pre><code class="language-css">.content-cards .featured {
  border: 1px solid red;
}
</code></pre>
<p>Ok. 你刷新一下博客效果，每个置顶贴的标题就加了个红框框啦。</p>
<blockquote>
<p>更多的效果请自己搞哇。</p>
</blockquote>
<h2 id="">确认置顶效果会影响的内容</h2>
<p>你可以简单地通过下面的方法确认它会影响到的页面：</p>
<pre><code class="language-bash">&gt; cd affinity
&gt; grep -H 'loop' *.hbs
index.hbs:{{!-- The tag below includes the post loop - partials/loop.hbs --}}
index.hbs:{{&gt; &quot;loop&quot;}}
tag.hbs:{{!-- The tag below includes the post loop - partials/loop.hbs --}}
tag.hbs:{{&gt; &quot;loop&quot;}}
</code></pre>
<p>这说明tag和index页会受到loop的影响——不过在前面文章里我已经说过，置顶效果是无法影响到tag页的。所以……另外，事实上这里可以列出有index.hbs、author.hbs和tag.hbs三种页面的，只是affinity这个theme没有author.hbs页罢了。</p>
<h2 id="loophbs">如果没有loop.hbs</h2>
<p>如上所提示到的，如果<code>loop.hbs</code>没有单独地放在<code>partials</code>目录中，那么它可能直接用一对标签<code>{{#foreach posts}}</code>放在index、author或tag三个页面中了。找一找？</p>
<p>你可以直接参考本文来处理这个<code>foreach</code>。或者，我建议把这部分内容/代码取出来放在<code>loop.hbs</code>中，然后再照本文所述处理就好啦。</p>
<p>当然，这种情况下你得把loop.hbs作为子模板嵌入到index、author或tag页面中，这个请参考affinity就好了。在这里：<a href="https://github.com/Showfom/Affinity/blob/master/affinity/index.hbs">https://github.com/Showfom/Affinity/blob/master/affinity/index.hbs</a></p>
</div>]]></content:encoded></item></channel></rss>
