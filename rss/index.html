<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Aimingoo's Blog]]></title><description><![CDATA[何不乐乐而有哉]]></description><link>http://aimingoo.github.io/</link><generator>Ghost 0.11</generator><lastBuildDate>Wed, 09 Aug 2017 06:28:20 GMT</lastBuildDate><atom:link href="http://aimingoo.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[简单实现Ghost Theme的置顶效果]]></title><description><![CDATA[<p>在<a href="http://aimingoo.github.io/1-1721.html">《手记3：实例教学之Ghost模板定制》</a>里面我提到了在Theme中“指定文章置顶”的方法，但说得不细致。这里便重新写一个简单的指引。</p>

<p>下面的内容以affinity为例，这个Theme在这里：<a href="https://github.com/Showfom/Affinity">https://github.com/Showfom/Affinity</a></p>

<h2 id="loop">找到loop</h2>

<p>在<code>affinity/partials</code>目录中的<code>loop.hbs</code>是一个关键文件，它通常如下结构（<a href="https://github.com/Showfom/Affinity/tree/master/affinity">参见这里</a>）：</p>

<pre><code class="language-html">&lt;div class="content-cards"&gt;  
  {{#foreach posts}}
...
  {{/foreach}}
&lt;/div&gt;

{{!-- Previous/next page links - displayed on every page --}}
{{pagination}}
</code></pre>

<p>我们将这一对<code>{{#foreach}</code></p>]]></description><link>http://aimingoo.github.io/1-1739.html/</link><guid isPermaLink="false">8d2d0859-a75f-4b1d-97e3-0ef92e4b556f</guid><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 09 Aug 2017 06:22:59 GMT</pubDate><content:encoded><![CDATA[<p>在<a href="http://aimingoo.github.io/1-1721.html">《手记3：实例教学之Ghost模板定制》</a>里面我提到了在Theme中“指定文章置顶”的方法，但说得不细致。这里便重新写一个简单的指引。</p>

<p>下面的内容以affinity为例，这个Theme在这里：<a href="https://github.com/Showfom/Affinity">https://github.com/Showfom/Affinity</a></p>

<h2 id="loop">找到loop</h2>

<p>在<code>affinity/partials</code>目录中的<code>loop.hbs</code>是一个关键文件，它通常如下结构（<a href="https://github.com/Showfom/Affinity/tree/master/affinity">参见这里</a>）：</p>

<pre><code class="language-html">&lt;div class="content-cards"&gt;  
  {{#foreach posts}}
...
  {{/foreach}}
&lt;/div&gt;

{{!-- Previous/next page links - displayed on every page --}}
{{pagination}}
</code></pre>

<p>我们将这一对<code>{{#foreach}}</code>标签中（含标签本身）的全部内容剪切出来，并放到一个新的的<code>partials/content_post.hbs</code>文件去。然后，将<code>content_post.hbs</code>复制一份，命名为<code>content_featured.hbs</code>。这样，在<code>partials</code>目录中就有了下面三个文件：</p>

<pre><code>partials/loop.hbs  
partials/content_post.hbs  
partials/content_featured.hbs  
</code></pre>

<h2 id="loop">在loop中标记置顶贴</h2>

<p>现在在<code>loop.hbs</code>中还有一对<code>div</code>标签：：</p>

<pre><code class="language-html">&lt;div class="content-cards"&gt;  
&lt;/div&gt;  
</code></pre>

<p>我们只需要把下面的代码直接复制到这一对标签之中，就好了：</p>

<pre><code class="language-html">&lt;!-- 置顶风格 --&gt;  
{{^is "paged"}}
  {{! list all feated posts on top }}
  {{#is "index"}}
  {{#get "posts" filter="featured:true" limit="all" include="tags" as |featured|}}
  {{#foreach featured}}
      {{&gt; content_featured}}
  {{/foreach}}
  {{/get}}
  {{/is}}

  {{#is "author"}}
  {{#get "posts" filter="featured:true+author:{{author.slug}}" limit="all" include="tags" as |featured|}}
  {{#foreach featured}}
      {{&gt; content_featured}}
  {{/foreach}}
  {{/get}}
  {{/is}}
{{/is}}

&lt;!-- 普通风格 --&gt;  
  {{#foreach posts}}
    {{#is "tag"}}
        {{&gt; content_post}}
    {{else}}
        {{#unless featured}}
        {{&gt; content_post}}
        {{/unless}}
    {{/is}}
  {{/foreach}}
</code></pre>

<h2 id="">设定置顶贴的效果</h2>

<p>现在你只需要修改<code>partials/content_featured.hbs</code>中的样式，就可以定制你需要的置顶贴的效果了。以affinity为例，我在<code>content_featured.hbs</code>中的下面代码位置添加了一个<code>featured</code>类名：</p>

<pre><code>      ...
      &lt;header class="card-header featured"&gt;
        &lt;div class="card-title"&gt;
</code></pre>

<p>然后，找到<code>assets/css/screen.css</code>文件，添加这个类的CSS样式：</p>

<pre><code class="language-css">.content-cards .featured {
  border: 1px solid red;
}
</code></pre>

<p>Ok. 你刷新一下博客效果，每个置顶贴的标题就加了个红框框啦。</p>

<blockquote>
  <p>更多的效果请自己搞哇。</p>
</blockquote>

<h2 id="">确认置顶效果会影响的内容</h2>

<p>你可以简单地通过下面的方法确认它会影响到的页面：</p>

<pre><code class="language-bash">&gt; cd affinity
&gt; grep -H 'loop' *.hbs
index.hbs:{{!-- The tag below includes the post loop - partials/loop.hbs --}}  
index.hbs:{{&gt; "loop"}}  
tag.hbs:{{!-- The tag below includes the post loop - partials/loop.hbs --}}  
tag.hbs:{{&gt; "loop"}}  
</code></pre>

<p>这说明tag和index页会受到loop的影响——不过在前面文章里我已经说过，置顶效果是无法影响到tag页的。所以……另外，事实上这里可以列出有index.hbs、author.hbs和tag.hbs三种页面的，只是affinity这个theme没有author.hbs页罢了。</p>

<h2 id="loophbs">如果没有loop.hbs</h2>

<p>如上所提示到的，如果<code>loop.hbs</code>没有单独地放在<code>partials</code>目录中，那么它可能直接用一对标签<code>{{#foreach posts}}</code>放在index、author或tag三个页面中了。找一找？</p>

<p>你可以直接参考本文来处理这个<code>foreach</code>。或者，我建议把这部分内容/代码取出来放在<code>loop.hbs</code>中，然后再照本文所述处理就好啦。</p>

<p>当然，这种情况下你得把loop.hbs作为子模板嵌入到index、author或tag页面中，这个请参考affinity就好了。在这里：<a href="https://github.com/Showfom/Affinity/blob/master/affinity/index.hbs">https://github.com/Showfom/Affinity/blob/master/affinity/index.hbs</a></p>]]></content:encoded></item><item><title><![CDATA[小述系列最终篇：说说《大道至易：实践者的思想》]]></title><description><![CDATA[<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt="poster-1"></p>

<blockquote>
  <p>这最后一篇小述，是写《大道至易》的。我想我又是犯了文绉绉的老毛病，把这篇“述”写成了自说自话的道可道与非常道。之所以写得这么晦涩难看，除了拽拽文之外，其实可能最大的原因还是自己吃得不够透彻，所以表达上就深入得进去，却浅不出来……</p>
  
  <p>所谓大道，终归是难写的，所以还是请大家原谅我的这些不成熟吧。</p>
  
  <p>本电子书可自由下载和传播。</p>
</blockquote>

<h2 id="">霍泰稳先生的序</h2>

<p>认识泰稳兄已经很多年，第一次请他写序。之所以邀他来写，是因为他是少见的、有着对技术深刻理解的管理者。这十多年来，国内IT技术的、尤其是工程与管理相关的每一次动荡变化，他都是参与者与亲历者。</p>

<p>而到了现在，在他成功地管理着极客邦、InfoQ等等公司的时候，他说出的秘诀却是“落地为要”四个字。这令我钦佩，也令我感叹：知易而行难，泰稳兄选的是一条更难的路。我不及泰稳的地方便是在这里，这些年来，从《大道至简》到《大道至易》，我一直是在“谈”一种工程，以及“谈”这种工程下的管理，我称之为“</p>]]></description><link>http://aimingoo.github.io/1-1736.html/</link><guid isPermaLink="false">47888d52-efb0-4fb6-a589-590dacc7c381</guid><category><![CDATA[电子书]]></category><category><![CDATA[出版]]></category><category><![CDATA[软件工程]]></category><category><![CDATA[大道至易]]></category><category><![CDATA[书序书评]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 30 Jul 2017 03:35:54 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt="poster-1"></p>

<blockquote>
  <p>这最后一篇小述，是写《大道至易》的。我想我又是犯了文绉绉的老毛病，把这篇“述”写成了自说自话的道可道与非常道。之所以写得这么晦涩难看，除了拽拽文之外，其实可能最大的原因还是自己吃得不够透彻，所以表达上就深入得进去，却浅不出来……</p>
  
  <p>所谓大道，终归是难写的，所以还是请大家原谅我的这些不成熟吧。</p>
  
  <p>本电子书可自由下载和传播。</p>
</blockquote>

<h2 id="">霍泰稳先生的序</h2>

<p>认识泰稳兄已经很多年，第一次请他写序。之所以邀他来写，是因为他是少见的、有着对技术深刻理解的管理者。这十多年来，国内IT技术的、尤其是工程与管理相关的每一次动荡变化，他都是参与者与亲历者。</p>

<p>而到了现在，在他成功地管理着极客邦、InfoQ等等公司的时候，他说出的秘诀却是“落地为要”四个字。这令我钦佩，也令我感叹：知易而行难，泰稳兄选的是一条更难的路。我不及泰稳的地方便是在这里，这些年来，从《大道至简》到《大道至易》，我一直是在“谈”一种工程，以及“谈”这种工程下的管理，我称之为“具体工程”。而我所谈诸多，也莫过于“落地”二字之要：这二字的前面，是我所经历与感悟的种种工程与思想；其后面，于读者而言的，不过是“具体到项目该怎么做”这样的一句发问。</p>

<p>我写《大道至易》的本意，就是不想教读者怎么“去做”。然而清谈无用，还要先有行，才有思的。所以我是期望读者在做的过程中，哪怕有一霎时的反思能触到书中的所言，便是我做到了。</p>

<p>只是一如书中所言：</p>

<blockquote>
  <p>“拉屎就算是一项工程，具体来说，也得自己拉”</p>
</blockquote>

<p>——行是你的事。</p>

<h2 id="">这本书是最难写的</h2>

<p>这本书原是其第一版中的一编，它是成书最晚的部分。我是先回顾了自己对技术的认识，这大概只写了半年（即《程序原本》）；再用半年就写完了对自己架构观点的总结（即《我的架构思想》）。然而在写本编时，却用了接近一年的时间；我不是一个情绪化的人，其间却好几次写到情绪失控，几乎无法完成本编。</p>

<p>而书中却看不到“我的情绪”——这就是《大道至易》最难写的地方。</p>

<p>有所谓“大义微言”，这是指《春秋》一书以记事为条贯，而微言大义与其中。我虽然没有什么“大义”要讲，却不慎地采用了“微言”这一写法。所以令读者可读可受而不自知，原本就是目的与方法所在。这是难写处之一。</p>

<p>难处之二在于要谈什么。</p>

<p>《大道至易》根底里还是要谈软件工程的，毕竟它是承续《大道至简》而来。但我越来越发现，《大道至简》所讲的其实只是工程的要略，而不是工程之实作。工程要实际做起来的时候，人、事和物是一个也分不开的。也就是说，真正的在做工程的时候，你面临的并不是敏捷不敏捷、方法不方法，而是各种扯皮、各种纷乱，以及具体到的那个产品做不出来。</p>

<p>——没有那么多理论让你可用，也没有一个具体可行的、不会出错的“最佳实践”让你去试。</p>

<p>如《大道至易》书中所言，连佛祖都在教你拉屎，但你具体要拉的时候佛祖也是无能为力的。所以我也就不愿做那书写定规的佛祖，而只好写些让你“思而不解”的文字。</p>

<p>要点是你要去思，才会有你的解。我不会比佛祖更强，他都教不了你拉屎，况乎我哉！</p>

<blockquote>
  <p>注：别说我亵渎佛祖，的确有本《毗尼母经》写了佛祖教僧众拉屎的方法。</p>
</blockquote>

<h2 id="">所以……</h2>

<p>要解决“人的问题”，核心是解决“权的问题”，更核心是解决“利的问题”。所谓“势者，利之所趋”，作为管理者，你懂得了所有人的“利的诉求”，你就看到了形势；你顺应了形势，也就事半功倍了。</p>

<p>这是最最核心的那点观察。然而如果你从这本书中看到的就是权术，读到的就是势利，那就又错读了书。因为我并没有谈这些，我谈的仍然是工程中的种种，从学术的到民间的，从组织的到个人的，从团队到产品……总之，我要谈的仍然是你想做的那些具体的事。如同泰稳兄一开始所言：</p>

<blockquote>
  <p>“大道至易，落地为要”</p>
</blockquote>

<p>我不能帮你走，所以我只能让你读到这些观察。这是我能告诉你的、或指示你去看到的、在这个地表上的真相。就如同书中一再用的那四个字：</p>

<blockquote>
  <p>“这是现实”。</p>
</blockquote>

<h2 id="66">什么是“66%的从众者”</h2>

<p>起初，这一系列（三本）电子书的封面是一直悬而未决的。我为此找过图灵的编辑，找过我曾经的同事……然而出于我对这本书前作封面的喜好，我否定了许多精彩而用心的设计（不好意思，此处确有私念）。直到我最终决定封面的风格时，便是先定下了这本《大道至易（第二版）》——也就是这黑黑的封面，而封皮上只有两个人，和一句话：</p>

<blockquote>
  <p>“你是66%的从众者吗？”</p>
</blockquote>

<p>从《大道至简》的三人论道，变成如今的两人问诘。书的封面的变化，反映了我思想与陈述方法的变化 。如今，我不已不甚在意于“论”，而在意于“问”。</p>

<p>正确的问题，本身就是答案。“你是66%的从众者吗？”如果不是，那么你是谁？你面对的是谁？他面对的是你吗？你何以知道他是从众者，而你不是？若他追随你，又何以证明不是在从众？若不追随你，那又何谓从众？从众的本质属性是什么？是管理与控制？是精神教化？是同理心？若这些是本质属性，那么为什么不是你的属性？你何以觉出“这些”是或不是你的属性？</p>

<p>若三人为众，那么这三个人，又有哪一个不是从众者呢？</p>

<h2 id="">要懂得人</h2>

<p>现在你大概已经知道了，这本书之最难处，在于我谈的是人性，而不是工程的方法。</p>

<p>懂得人心，才是具体工程的要义。</p>

<p>心变，则万物为之变；这才是“易”理。</p>

<h2 id="">要容人</h2>

<p>所以，“易”是最难管的。你的团队的每个人都活在自己的心上，而你连我心都安不下来，谈何去管别人的。收束人心，大概是为人父母者最悲剧的事情了；如你所知的，连天下父母也无法收束的心，又如何能让管理者去收束。</p>

<p>哪有这样的道理啊。</p>

<p>所以莫老想着要管这管那，莫老想着要管人管事。所谓“管”，就是官头上的帽子，你越努力去管，就越是官相毕现，而被管者就越是奴相毕现。所以我说“要做事，不要管理”，容得大家一门心思地去把事情做好，那么管不管，有什么要紧？</p>

<p>所以要“容得下易”。容得下易，也就是容得下可变之心；心可变了，才有万物之可变，才有生活之气象。所以总有团队会死气沉沉，总有产品会胎死腹中，总有工程会不知其所终……</p>

<p>容不下变化，那么就死路一条了。</p>

<h2 id="">下载</h2>

<p><strong>1. 高质量的PDF版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Easy_and_Changes.zip">【下载】</a></strong></p>

<p>推荐在桌面系统、PAD或大屏幕移动设备上阅读。</p>

<p><strong>2. 适用于Kindle的版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Easy_and_Changes.azw3">【下载】</a></strong></p>

<p>下载后用USB上传到Kindle即可。</p>

<blockquote>
  <p>如果你使用Amazon的“发送到设备”服务，那么这本书是不显示封面的。并且可能你需要将书的扩展名从.azw3改为.mobi。</p>
  
  <p>上述的修改不影响阅读效果。</p>
</blockquote>

<p><strong>3. 使用了SVG图的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Easy_and_Changes.epub">【下载】</a></strong></p>

<p>推荐在Macbook、iPhone或iPad中的iBooks软件上阅读。在其它支持“内置SVG图的.epub电子书”的阅读器上也有较好的阅读效果。</p>

<p><strong>4. 一般质量图片的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Easy_and_Changes.epub">【下载】</a></strong></p>

<p>一般的掌上阅读软件都可以支持。</p>

<p><strong>5. 低版本Kindle使用的阅读格式</strong></p>

<p>即低版本.mobi文件，阅读体验较差。请移驾我的Github（<a href="https://github.com/aimingoo/my-ebooks">在这里</a>）获取下载。</p>

<h2 id="">其它下载点(不定期更新)</h2>

<ul>
<li><p>CSDN下载页：<a href="http://download.csdn.net/user/aimingoo/uploads">http://download.csdn.net/user/aimingoo/uploads</a></p></li>
<li><p>图灵出版社区：<a href="http://www.ituring.com.cn/book/2428">http://www.ituring.com.cn/book/2428</a></p></li>
<li><p>我的Github：<a href="http://github.com/aimingoo/my-ebooks">http://github.com/aimingoo/my-ebooks</a></p></li>
</ul>]]></content:encoded></item><item><title><![CDATA[电子书《我的架构思想》小述]]></title><description><![CDATA[<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt="poster-1"></p>

<blockquote>
  <p>接下来谈谈《我的架构思想》。上一篇是“电子书《程序原本》小述”，在这里：<a href="http://aimingoo.github.io/1-1734.html">https://aimingoo.github.io/1-1734.html</a>。</p>
  
  <p>本电子书可自由下载和传播。</p>
</blockquote>

<h2 id="">这些年来我所谈的“架构思想”</h2>

<p>在2007年，我还在盛大的时候曾做过一次名为《设计师的实战过程》的内部分享，这个分享现今在CSDN还能下载到（<a href="http://blog.csdn.net/aimingoo/article/details/75948724">在这里</a>）。但在此之后，我便再也没有讲过“设计”，而是开始讲“架构”，例如我在2009年第一届QCon大会中所讲的《我之于架构的主要观点》。</p>

<p>在我看来，设计与架构是完全不同的两个层面的东西。就如同我后来在《架构之美》的序中所写的：</p>

<blockquote>
  <p>画家的笔最终描绘的是他自己心里的映像。</p>
</blockquote>

<p>就架构来说，这个“映像”并不是设计出来的。这个映像如何得来，便是架构思想的全部。</p>

<p>是我们的认识从根底里决定了我们如何去理解一个系统，并为之描绘一个架构以便于进一步的沟通交流。从“架构之为物”的角度来说，架构其实就是一个沟通的工具，它与模型/模具，与白板/</p>]]></description><link>http://aimingoo.github.io/1-1735.html/</link><guid isPermaLink="false">622c6cb8-8677-4aac-94ea-d304eb64e7ac</guid><category><![CDATA[电子书]]></category><category><![CDATA[书序书评]]></category><category><![CDATA[架构]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 23 Jul 2017 13:58:00 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt="poster-1"></p>

<blockquote>
  <p>接下来谈谈《我的架构思想》。上一篇是“电子书《程序原本》小述”，在这里：<a href="http://aimingoo.github.io/1-1734.html">https://aimingoo.github.io/1-1734.html</a>。</p>
  
  <p>本电子书可自由下载和传播。</p>
</blockquote>

<h2 id="">这些年来我所谈的“架构思想”</h2>

<p>在2007年，我还在盛大的时候曾做过一次名为《设计师的实战过程》的内部分享，这个分享现今在CSDN还能下载到（<a href="http://blog.csdn.net/aimingoo/article/details/75948724">在这里</a>）。但在此之后，我便再也没有讲过“设计”，而是开始讲“架构”，例如我在2009年第一届QCon大会中所讲的《我之于架构的主要观点》。</p>

<p>在我看来，设计与架构是完全不同的两个层面的东西。就如同我后来在《架构之美》的序中所写的：</p>

<blockquote>
  <p>画家的笔最终描绘的是他自己心里的映像。</p>
</blockquote>

<p>就架构来说，这个“映像”并不是设计出来的。这个映像如何得来，便是架构思想的全部。</p>

<p>是我们的认识从根底里决定了我们如何去理解一个系统，并为之描绘一个架构以便于进一步的沟通交流。从“架构之为物”的角度来说，架构其实就是一个沟通的工具，它与模型/模具，与白板/粉笔，与纸张/文字并没有质的区别。也如同这些工具一般，如果我们脑中空无一物，那么模型、模具、白板……等等也百无一用。</p>

<p>真正决定你的架构水平的东西，仍然是你认识这个世界的方法与能力。</p>

<h2 id="">怎么来讲“思想”</h2>

<p>孟岩先生在序中将本书称为“一本架构思维的认知升级之作”。首先谢谢孟岩对此书的厚赞，另一方面，他也确实戳到了本书对“如何讲思想”的问题。</p>

<p>但凡要读到本书，大抵都是有一些架构经验或经历的读者了。即使不济，也多少看过、用过一些经典的架构。既如此，读者心中已然有一个自己的“思维模型”，有自己对事物的认知方法与逻辑，否则他也原本就不会做、不会看、不会用那些架构了。所以，《我的架构思想》的读者并不是白板一块，可以任由我将我的思想抹涂在上面。</p>

<p>那么“认知升级”又是什么意思呢？是不是托大地说，“周爱民的架构思想”就是更高级的，所以读者需要通过这本书来统统地完成一次升级呢？不。我没有这个意思，也不做这种企图。这也是这本书名字强调是“我的”的原因：我的是我的，你的是你的；最终之于你有价值的仍然是你的，而非我的。</p>

<p>好吧，说得简单直白一些：我期望读者通过这本书，能提炼与升级自己在架构过程中的思想，得到更新的、更高层次的、更有实战与更富效力的“你的架构思想”。</p>

<p>所以我并不是在讲我的思想，或教述我如何想，而是谈论思想何以得来的方法论，“我的架构思想”本不过是个印证与参考罢了。</p>

<p>在这一点上，孟岩先生看得很真切。</p>

<h2 id="">“方法论”的结构化</h2>

<p>我的方法论最终总要呈现出来，才是可以作为你我所讨论的对象的。这一点我一开始就很清楚：我必须清楚地描述它。</p>

<p>我其实一早就把这个结果给了读者，但我想你未见得能看到它。这段文字就在引言里面：</p>

<blockquote>
  <p>任何一个优秀的架构师都有自己独特的思考方式，这决定了他如何抽象系统，以及如何“创造性地”设计与构画这个系统。……在这个过程中，我们需要三种能力：概念抽象能力、概念表达能力和基于概念的逻辑表达能力。</p>
</blockquote>

<p>这三种能力在后文的架构师能力模型中被概括为“领悟”。</p>

<p>整本书都是在一次又一次应用这三种能力，教读者如何跟随这个过程去得到最终的架构对象。这些架构对象包括：“引言：架构师的思维”的“修养和思维”，正文中之“知识”、“认识”、“系统”与“架构”等等，以及附录中的“VEO模型”等等。我不过是在运用上述能力去得到并解释它们，而读者则可以作为一个观察者来观见、见证这一过程。</p>

<p>在这些“过程与方法”之外的，是方法论和它之上的认识论。读者可以更深层次地将自己的方法论与认识论与书中对接印证。能行进到这一步，就真的是大有斩获了。</p>

<p>书之用在读。你是读者，我是写者，我是那个于"读得"之事无能为力的人。</p>

<h2 id="">基本模型、理论与原则</h2>

<p>严格地来说，《我的架构思想》只提出了一个基本模型，亦即是架构师的能力模型。并且，也只对这个模型中的“领悟”做了进一步细化的讨论，提出了它由“概念抽象、概念表达和基于概念的逻辑表达”三个部分构成。</p>

<p>而其中最核心的，又是指“概念抽象”。“架构意图”这一关键的要素，就是从对这个能力的辨识而得出来的。从认识论的角度上，这就是所谓的“见所欲见”——你看见的，是你所想看见的。你的意图决定了你的认识，进而决定了你的架构，这是一个“从认识到表达”的基本逻辑。</p>

<p>“架构意图”在这本书中有着不容争辩、毋庸置疑的重要位置。所以我说“架构意图是架构的灵魂”，并认为几乎所有的架构活动，以及有关架构的争议都可以围绕对它的识别和理解来进行。因此我后来在一些大会中讲述我的架构思想时，会概括为“架构意图驱动的过程模型”——这一过程包括架构发起、架构构建和架构交付三个部分。</p>

<p>而本书中所谓的“架构原则”，不过是在上述过程的生命周期中的一些关键判断。</p>

<h2 id="">下载</h2>

<p><strong>1. 高质量的PDF版本 <a href="http://aimingoo.github.io/content/images/attachments/Thinking_in_Architecture.zip">【下载】</a></strong></p>

<p>推荐在桌面系统、PAD或大屏幕移动设备上阅读。</p>

<p><strong>2. 适用于Kindle的版本 <a href="http://aimingoo.github.io/content/images/attachments/Thinking_in_Architecture.azw3">【下载】</a></strong></p>

<p>下载后用USB上传到Kindle即可。</p>

<blockquote>
  <p>如果你使用Amazon的“发送到设备”服务，那么这本书是不显示封面的。并且可能你需要将书的扩展名从.azw3改为.mobi。</p>
  
  <p>上述的修改不影响阅读效果。</p>
</blockquote>

<p><strong>3. 使用了SVG图的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Thinking_in_Architecture.epub">【下载】</a></strong></p>

<p>推荐在Macbook、iPhone或iPad中的iBooks软件上阅读。在其它支持“内置SVG图的.epub电子书”的阅读器上也有较好的阅读效果。</p>

<p><strong>4. 一般质量图片的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Thinking_in_Architecture-i.epub">【下载】</a></strong></p>

<p>一般的掌上阅读软件都可以支持。</p>

<p><strong>5. 低版本Kindle使用的阅读格式</strong></p>

<p>即低版本.mobi文件，阅读体验较差。请移驾我的Github（<a href="https://github.com/aimingoo/my-ebooks">在这里</a>）获取下载。</p>

<h2 id="">其它下载点（不定期更新）</h2>

<ul>
<li><p>CSDN下载页：<a href="http://download.csdn.net/user/aimingoo/uploads">http://download.csdn.net/user/aimingoo/uploads</a></p></li>
<li><p>图灵出版社区：<a href="http://www.ituring.com.cn/book/2430">http://www.ituring.com.cn/book/2430</a></p></li>
<li><p>我的Github：<a href="http://github.com/aimingoo/my-ebooks">http://github.com/aimingoo/my-ebooks</a></p></li>
</ul>]]></content:encoded></item><item><title><![CDATA[电子书《程序原本》小述]]></title><description><![CDATA[<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt=""></p>

<blockquote>
  <p>《程序原本》作为电子书首发已经一个月了（下载附后），它到底是一本怎么样的书呢？我想站在我自己的角度对它做一些阐述，或是有利于对它的理解与传播的。</p>
  
  <p>本电子书可自由下载和传播。</p>
</blockquote>

<h2 id="">什么是“原本”</h2>

<p>书名取自于《几何原本（Euclid's Elements）》，因此这个“原本”，其实原意应从Elements来找，一般来说理解成“不可或缺的、核心的要素，或元素”就好了。</p>

<p>《程序原本》确实就是想从这个角度来阐述“程序”这个主题。这本书从数、算以及抽象的源起谈起，从它们之间的关系，以及计算范式的定义谈起，把“计算机程序（或程序计算）”整件事的骨架抽离出来。然后再谈到在这个骨架之外来描述它的语言——计算机程序设计语言的方方面面。</p>

<p>这是这本书的前面部分。坦率地说，这部分并没有什么“新”东西。因为这些认识其实一早都有了，先哲大贤们已经论述得很清楚了，而我只是做了个引线人，把这些东西串起来并摆成了一个角度以便于大家观察罢了。</p>

<p>我在这个观察之外提出的问题是：“程序”是如何演进的？如今你所见的种种语言，以及由这些种种语言所得的种种“程序”</p>]]></description><link>http://aimingoo.github.io/1-1734.html/</link><guid isPermaLink="false">60b41365-0ee9-4c3e-89a7-5385eb91b13d</guid><category><![CDATA[电子书]]></category><category><![CDATA[出版]]></category><category><![CDATA[大道至易]]></category><category><![CDATA[书序书评]]></category><category><![CDATA[程序原本]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Thu, 20 Jul 2017 05:18:54 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt=""></p>

<blockquote>
  <p>《程序原本》作为电子书首发已经一个月了（下载附后），它到底是一本怎么样的书呢？我想站在我自己的角度对它做一些阐述，或是有利于对它的理解与传播的。</p>
  
  <p>本电子书可自由下载和传播。</p>
</blockquote>

<h2 id="">什么是“原本”</h2>

<p>书名取自于《几何原本（Euclid's Elements）》，因此这个“原本”，其实原意应从Elements来找，一般来说理解成“不可或缺的、核心的要素，或元素”就好了。</p>

<p>《程序原本》确实就是想从这个角度来阐述“程序”这个主题。这本书从数、算以及抽象的源起谈起，从它们之间的关系，以及计算范式的定义谈起，把“计算机程序（或程序计算）”整件事的骨架抽离出来。然后再谈到在这个骨架之外来描述它的语言——计算机程序设计语言的方方面面。</p>

<p>这是这本书的前面部分。坦率地说，这部分并没有什么“新”东西。因为这些认识其实一早都有了，先哲大贤们已经论述得很清楚了，而我只是做了个引线人，把这些东西串起来并摆成了一个角度以便于大家观察罢了。</p>

<p>我在这个观察之外提出的问题是：“程序”是如何演进的？如今你所见的种种语言，以及由这些种种语言所得的种种“程序”之间的关系是如何的？</p>

<h2 id="">怎么来讲述这些“原本”</h2>

<p>在书中，我总是试图用非常严谨地推论来提出或论证观点。我已然尽极大可能地来做这件事，并尝试让读者还能“不太费力”地理解它。</p>

<p>《结构程序设计》这本书在“论证”这件事上做得远比我要好得多，然而却更多的使用了数理逻辑。我可能采用的逻辑会略有些不同。比如下面这段：</p>

<p><img src="http://aimingoo.github.io/content/images/2017/07/-----2017-07-20-11.05.55.png" alt="屏幕快照 2017-07-20 11.05.55"></p>

<p>这段文字在讲述一个“获取/捕获/剥离”抽象的过程，它最终只是想说明“对于计算来说，<code>equ0()</code>与<code>值0</code>是同义的”。这句话看起来没有什么特别需要强调的——也许你早就明白了，或者它已经显白得不需要论述。但是，有了这个观点，接下来的论述就完全成立了：</p>

<blockquote>
  <p>现在，我们提出最后一个推论。</p>
  
  <ul>
  <li>既然<code>equ0</code>可以指代任意有限的计算步骤，那么它必等价于图灵机的“顺序逻辑”中所有步骤；</li>
  <li>既然<code>equ0</code>可以指代图灵机所有的顺序步骤，则必然能指代顺序步骤的两种特例：分支与循环；</li>
  <li>既然<code>equ0</code>既可以指代计算的要素“数”，又可以指代计算的要素“算”，还可以指代描述正确计算所必须的逻辑，那么<code>equ0</code>本身——在概念抽象上——必然等同于一个完整的计算系统。</li>
  </ul>
  
  <p>这就是“函数式”计算范式的基本抽象。</p>
</blockquote>

<p>这直接地解释了“函数式”是什么的问题，解释了“函数式”的核心的“值无关”和“值等义于函数（以及其确定性）”的问题，解释了函数式计算完备的问题……</p>

<p>非但对“语言范式”的解释如此，整本书对它所讨论的几乎所有主题，都是采用这种方式来叙述与论证的。一旦你理解了一个观点、概念与逻辑，那么更多的内容就如同覆盆之珠，琳琅满目了。</p>

<h2 id="">什么是“不变的”</h2>

<p>我们总试图在纷繁的表相之中找到其内在“不变的”那些规律，有人谓之为“道”。我也是这样，我试图去追寻这些不变的东西，所以也有朋友说我是“求道者”。这其实太过抬举——我并不求道，我追求的只是知道而已。</p>

<p>这也许谈得远了，然而更近一些的问题是：我为什么要去寻找“程序原本”中那些不变的东西呢？</p>

<p>这十余年来，我的架构经历告诉我：所谓问题，要么是系统与其要素之间的矛盾，要么是观察与其预期之间的矛盾。撷其一而论，若是“系统与其要素”之间的矛盾，那么认清“这些要素是什么”就是极重要的问题了。</p>

<p>所以我会去找寻一个“计算系统”内部的种种要素，从最核心的，到某种特定系统的，无一遗漏。正是在这个过程中，我得到了《程序原本》一书的全部框架。也正是因此，这本书就是在描述这一切要素以及它们之间的冲突与矛盾。</p>

<p>更重要的是，我看到了这么多年以来（我的意思是自有“计算机程序”至今），我们从末改变过的解题思路：结构化。要知道，时至今日，我们居然只知道、只尝试过、只成功过这样一种方法。</p>

<p>这难道不是一件可怕的事吗？</p>

<h2 id="">为什么是“架构师的入门之径”</h2>

<p>在《程序原本》这本书的简介中称，这本书“是架构师的入门之径”。你也许会奇怪我为什么会这样来介绍它。</p>

<p>其实这套电子书的第一版（《大道至易》）中，我的确就是先从《程序原本》写起的，之后再写到《我的架构思想》。因此从思维的路径来说，我也是将这“程序原本”作为了我讨论架构话题的入门之径的。所以，这简介也并非妄言。</p>

<p>如果你仔细地读这本《程序原本》，你会发现它已经讨论到了“系统”、“子系统”、“模块”、“分布”、“依赖”等等这些系统架构的“元素”，在它的后半部分更像是涉足到架构领域的书了。然而，它仍然是在“程序”这个体系下进行深入的讨论，而对“架构”只字不提。</p>

<p>这就是所谓“入门之径”的另一层真义了。</p>

<p>我们真的太容易在种种大会以及种种文章中听到或看到上面这些词汇（以及要素）了，并且由它们所组成的方案更是多如牛毛。然而，这些听来的看来的，最多让你知之皮表而已，你真的了解“架构为何物”，以及“如何得到架构”吗？</p>

<p>不，《程序原本》原本就只是打算让你清晰、明了、一览无遗地看到这些皮表，而已。更多的，我们要到《我的架构思想》中去谈。</p>

<h2 id="">下载</h2>

<p><strong>1. 高质量的PDF版本 <a href="http://aimingoo.github.io/content/images/attachments/Elements_of_Programming.zip">【下载】</a></strong></p>

<p>推荐在桌面系统、PAD或大屏幕移动设备上阅读。</p>

<p><strong>2. 适用于Kindle的版本 <a href="http://aimingoo.github.io/content/images/attachments/Elements_of_Programming.azw3">【下载】</a></strong></p>

<p>下载后用USB上传到Kindle即可。</p>

<blockquote>
  <p>如果你使用Amazon的“发送到设备”服务，那么这本书是不显示封面的。并且可能你需要将书的扩展名从.azw3改为.mobi。</p>
  
  <p>上述的修改不影响阅读效果。</p>
</blockquote>

<p><strong>3. 使用了SVG图的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Elements_of_Programming.epub">【下载】</a></strong></p>

<p>推荐在Macbook、iPhone或iPad中的iBooks软件上阅读。在其它支持“内置SVG图的.epub电子书”的阅读器上也有较好的阅读效果。</p>

<p><strong>4. 一般质量图片的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Elements_of_Programming-i.epub">【下载】</a></strong></p>

<p>一般的掌上阅读软件都可以支持。</p>

<p><strong>5. 低版本Kindle使用的阅读格式</strong></p>

<p>即低版本.mobi文件，阅读体验较差。请移驾我的Github（<a href="https://github.com/aimingoo/my-ebooks">在这里</a>）获取下载。</p>

<h2 id="">其它下载点（不定期更新）</h2>

<ul>
<li><p>CSDN下载页：<a href="http://download.csdn.net/user/aimingoo/uploads">http://download.csdn.net/user/aimingoo/uploads</a></p></li>
<li><p>图灵出版社区：<a href="http://www.ituring.com.cn/book/2429">http://www.ituring.com.cn/book/2429</a></p></li>
<li><p>我的Github：<a href="http://github.com/aimingoo/my-ebooks">http://github.com/aimingoo/my-ebooks</a></p></li>
</ul>]]></content:encoded></item><item><title><![CDATA[三本免费电子书齐齐完工了]]></title><description><![CDATA[<p>首先感谢图灵出版社，能许可我将之前的《大道至易》拿回来重制并发布免费电子书。这也是此次选择图灵出版社、图灵社区来首发这套电子书的原因。</p>

<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt=""></p>

<ul>
<li>大道至易：实践者的思想</li>
<li>我的架构思想：基础模型、理论与原则</li>
<li>程序原本</li>
</ul>

<p>这套书同时发行了多种格式的电子版，包括ePub、eBook、PDF、mobi等。如果你使用桌面电脑，我推荐你阅读PDF格式的电子版。PDF格式的电子版采用了标准纸质书的排版方法，包括页眉、页脚、奇偶页设置，以及目录等等，因此建议阅读时使用“双页”版式并设置“首页不同”（在Macbook的预览中是默认的）。</p>

<blockquote>
  <p>本电子书也针对Kindle进行过优化，全部插图采用了.svg矢量格式，确保在Kindle中阅读效果最佳。</p>
</blockquote>

<p><strong>下载：</strong></p>

<p>目前推荐在图灵社区下载和讨论（当然也欢迎你在我的博客中留言，要登录你的Github账号先）：</p>

<ul>
<li>下载在这里：<a href="http://github.com/aimingoo/my-ebooks">http://github.com/aimingoo/my-ebooks</a>, 相关信息在这里：<a href="http://aimingoo.github.io/1-1736.html">大道至易</a>、<a href="http://aimingoo.github.io/1-1735.html">我的架构思想</a>和<a href="http://aimingoo.github.io/1-1734.html">程序原本</a>；或，</li>
<li><a href="http://www.ituring.com.cn/book?tab=ebook&amp;sort=new">图灵电子书</a></li></ul>]]></description><link>http://aimingoo.github.io/1-1732.html/</link><guid isPermaLink="false">528fdfaa-f05a-492d-a914-b8296a57e7bd</guid><category><![CDATA[电子书]]></category><category><![CDATA[出版]]></category><category><![CDATA[软件工程]]></category><category><![CDATA[大道至易]]></category><category><![CDATA[架构]]></category><category><![CDATA[语言]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 20 Jun 2017 03:54:33 GMT</pubDate><content:encoded><![CDATA[<p>首先感谢图灵出版社，能许可我将之前的《大道至易》拿回来重制并发布免费电子书。这也是此次选择图灵出版社、图灵社区来首发这套电子书的原因。</p>

<p><img src="http://aimingoo.github.io/content/images/2017/06/poster-1.jpg" alt=""></p>

<ul>
<li>大道至易：实践者的思想</li>
<li>我的架构思想：基础模型、理论与原则</li>
<li>程序原本</li>
</ul>

<p>这套书同时发行了多种格式的电子版，包括ePub、eBook、PDF、mobi等。如果你使用桌面电脑，我推荐你阅读PDF格式的电子版。PDF格式的电子版采用了标准纸质书的排版方法，包括页眉、页脚、奇偶页设置，以及目录等等，因此建议阅读时使用“双页”版式并设置“首页不同”（在Macbook的预览中是默认的）。</p>

<blockquote>
  <p>本电子书也针对Kindle进行过优化，全部插图采用了.svg矢量格式，确保在Kindle中阅读效果最佳。</p>
</blockquote>

<p><strong>下载：</strong></p>

<p>目前推荐在图灵社区下载和讨论（当然也欢迎你在我的博客中留言，要登录你的Github账号先）：</p>

<ul>
<li>下载在这里：<a href="http://github.com/aimingoo/my-ebooks">http://github.com/aimingoo/my-ebooks</a>, 相关信息在这里：<a href="http://aimingoo.github.io/1-1736.html">大道至易</a>、<a href="http://aimingoo.github.io/1-1735.html">我的架构思想</a>和<a href="http://aimingoo.github.io/1-1734.html">程序原本</a>；或，</li>
<li><a href="http://www.ituring.com.cn/book?tab=ebook&amp;sort=new">图灵电子书</a>首页查看；</li>
<li>或直接<a href="http://www.ituring.com.cn/book/2429">《程序原本》</a>、<a href="http://www.ituring.com.cn/book/2428">《大道至易：实践者的思想》</a>，以及<a href="http://www.ituring.com.cn/book/2430">《我的架构思想》</a>。</li>
</ul>]]></content:encoded></item><item><title><![CDATA[发布《大道至简》电子版（第三版）]]></title><description><![CDATA[<p><img src="http://aimingoo.github.io/content/images/Tao-Simplest-Cover.png" alt=""></p>

<blockquote>
  <p><strong>第六版：2017.05.03，电子版（第三版）</strong></p>
  
  <ul>
  <li><p>在发布《大道至易（第二版）》时为本书重制了电子版。</p></li>
  <li><p>内容在本书电子版（第二版）的基础上没有更新。</p></li>
  <li><p>使用markdown重排了全部格式，发布了.epub和.azw3版本，并重制了pdf版本。</p></li>
  </ul>
</blockquote>

<h2 id="">关于本电子版</h2>

<p>该电子版是采用上一版为底本的，并且没有作文字上的增修。主要是为了发布质量更好的版本而制作的。</p>

<p>从第一版开始，本书的电子版一直都是没有封面的（考虑到效果，在本版本的.PDF上制作了一个简单的封面效果）。</p>

<h2 id="">下载</h2>

<p><strong>1. 高质量的PDF版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.zip">【下载】</a></strong></p>

<p>推荐在桌面系统、PAD或大屏幕移动设备上阅读。</p>

<p><strong>2. 适用于Kindle的版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.azw3">【下载】</a></strong></p>

<p>下载后用USB上传到Kindle即可。</p>

<blockquote>
  <p>如果你使用Amazon的“发送到设备”服务，那么这本书是不显示封面的。并且可能你需要将书的扩展名从.azw3改为.mobi。</p>
  
  <p>上述的修改不影响阅读效果。</p>
</blockquote>

<p><strong>3. 使用了SVG图的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.epub">【下载】</a></strong></p>

<p>推荐在Macbook、</p>]]></description><link>http://aimingoo.github.io/1-1731.html/</link><guid isPermaLink="false">ffa393a9-8644-4750-b302-0f0a9bf8c6e6</guid><category><![CDATA[大道至简]]></category><category><![CDATA[电子书]]></category><category><![CDATA[出版]]></category><category><![CDATA[软件工程]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Thu, 15 Jun 2017 20:03:08 GMT</pubDate><content:encoded><![CDATA[<p><img src="http://aimingoo.github.io/content/images/Tao-Simplest-Cover.png" alt=""></p>

<blockquote>
  <p><strong>第六版：2017.05.03，电子版（第三版）</strong></p>
  
  <ul>
  <li><p>在发布《大道至易（第二版）》时为本书重制了电子版。</p></li>
  <li><p>内容在本书电子版（第二版）的基础上没有更新。</p></li>
  <li><p>使用markdown重排了全部格式，发布了.epub和.azw3版本，并重制了pdf版本。</p></li>
  </ul>
</blockquote>

<h2 id="">关于本电子版</h2>

<p>该电子版是采用上一版为底本的，并且没有作文字上的增修。主要是为了发布质量更好的版本而制作的。</p>

<p>从第一版开始，本书的电子版一直都是没有封面的（考虑到效果，在本版本的.PDF上制作了一个简单的封面效果）。</p>

<h2 id="">下载</h2>

<p><strong>1. 高质量的PDF版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.zip">【下载】</a></strong></p>

<p>推荐在桌面系统、PAD或大屏幕移动设备上阅读。</p>

<p><strong>2. 适用于Kindle的版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.azw3">【下载】</a></strong></p>

<p>下载后用USB上传到Kindle即可。</p>

<blockquote>
  <p>如果你使用Amazon的“发送到设备”服务，那么这本书是不显示封面的。并且可能你需要将书的扩展名从.azw3改为.mobi。</p>
  
  <p>上述的修改不影响阅读效果。</p>
</blockquote>

<p><strong>3. 使用了SVG图的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest.epub">【下载】</a></strong></p>

<p>推荐在Macbook、iPhone或iPad中的iBooks软件上阅读。在其它支持“内置SVG图的.epub电子书”的阅读器上也有较好的阅读效果。</p>

<p><strong>4. 一般质量图片的.epub版本 <a href="http://aimingoo.github.io/content/images/attachments/Tao-Simplest-i.epub">【下载】</a></strong></p>

<p>一般的掌上阅读软件都可以支持。</p>

<p><strong>5. 低版本Kindle使用的阅读格式</strong></p>

<p>即低版本.mobi文件，阅读体验较差。请移驾我的Github（<a href="https://github.com/aimingoo/my-ebooks">在这里</a>）获取下载。</p>

<h2 id="">历史中的版本</h2>

<ul>
<li><p>最早发布这本书的电子版是在12年前，在这里：<a href="http://aimingoo.github.io/1-197.html">公开《大道至简——软件工程实践者的思想》电子版</a> </p></li>
<li><p>2012年发布了它的电子版第二版，在这里：<a href="http://aimingoo.github.io/1-261.html">大动作！！！公开《大道至简：软件工程实践者的思想》电子版（第二版）</a></p></li>
<li><p>本书（含纸质版）主要版次共有六版。其中各版本细节，请翻阅电子书末尾的“版本历史”。</p></li>
</ul>]]></content:encoded></item><item><title><![CDATA[Kindle的四种封面]]></title><description><![CDATA[<p>Kindle电子书的封面到底是多大呢？</p>

<p>这是个几乎无解的问题，无论如何，你找不到一个通用、有效的答案。但总的来说，视作用的不同，Kindle的封面为成四种：</p>

<ul>
<li>官方营销封面</li>
<li>收藏夹封面</li>
<li>首页列表封面</li>
<li>电子书封面</li>
</ul>

<h2 id="">一、官方营销封面</h2>

<p>这个封面设计见于官方文档（<a href="http://http://kindlegen.s3.amazonaws.com/AmazonKindlePublishingGuidelines.pdf">Amazon Kindle Publishing Guidelines</a>）。营销封面最好是2700×1688px，300ppi，图片大小不得超过5MB。</p>

<blockquote>
  <p>在稍早一些的文档中，这个大小被推荐为2560×1600，其比例是16:10。</p>
</blockquote>

<p>营销封面是用于亚马逊官方营销推广的，通常它是一本书“封面+书脊+封底”的完整样式。它不在书籍中直接使用，而是要求通过官方发布系统上传给亚马逊网站的。</p>

<p>营销封面如果没有达到指定大小，那么在上传的时候会有一个提示；如果图片最小边小于500px，那么在网站上根本就不显示了。</p>

<h2 id="">二、收藏夹封面</h2>

<p>这个封面是指从Kindle设备的首页进入“我的图书馆”或“收藏夹”时所看到的图书封面。</p>

<p>如果你直接从电脑放拷贝电子书到Kindle设备中，那么是不会显示这个封面的。它的大小并没有任何约定的规则，</p>]]></description><link>http://aimingoo.github.io/1-1729.html/</link><guid isPermaLink="false">6355a22b-27ba-47c6-90c2-c510bd56ee9c</guid><category><![CDATA[Kindle]]></category><category><![CDATA[电子书]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Mon, 12 Jun 2017 18:56:49 GMT</pubDate><content:encoded><![CDATA[<p>Kindle电子书的封面到底是多大呢？</p>

<p>这是个几乎无解的问题，无论如何，你找不到一个通用、有效的答案。但总的来说，视作用的不同，Kindle的封面为成四种：</p>

<ul>
<li>官方营销封面</li>
<li>收藏夹封面</li>
<li>首页列表封面</li>
<li>电子书封面</li>
</ul>

<h2 id="">一、官方营销封面</h2>

<p>这个封面设计见于官方文档（<a href="http://http://kindlegen.s3.amazonaws.com/AmazonKindlePublishingGuidelines.pdf">Amazon Kindle Publishing Guidelines</a>）。营销封面最好是2700×1688px，300ppi，图片大小不得超过5MB。</p>

<blockquote>
  <p>在稍早一些的文档中，这个大小被推荐为2560×1600，其比例是16:10。</p>
</blockquote>

<p>营销封面是用于亚马逊官方营销推广的，通常它是一本书“封面+书脊+封底”的完整样式。它不在书籍中直接使用，而是要求通过官方发布系统上传给亚马逊网站的。</p>

<p>营销封面如果没有达到指定大小，那么在上传的时候会有一个提示；如果图片最小边小于500px，那么在网站上根本就不显示了。</p>

<h2 id="">二、收藏夹封面</h2>

<p>这个封面是指从Kindle设备的首页进入“我的图书馆”或“收藏夹”时所看到的图书封面。</p>

<p>如果你直接从电脑放拷贝电子书到Kindle设备中，那么是不会显示这个封面的。它的大小并没有任何约定的规则，有文档称它总是被缩小到330px高度显示，并且宽高比为1:1.6。</p>

<p>事实上这个大小并不是个确数。这是因为这张封面图“按理说”应该是由亚马逊的线上系统向下推送到你的设备的，因此它会根据你的设备的大小而改变下推封面图片的宽高。从经验上说，这个值可能包括的大小有：305x458, 291x467, 305x461, 305x430 (a shorter, wider cover), 257x467 (a tall, narrow cover)等等。关于这一点，Calibre在它的源码中也有备注（<a href="https://github.com/kovidgoyal/calibre/commit/38bf9adba33a7a15b3aee5e6c99e13727a4afc46">kindle/driver.py</a>）：</p>

<pre><code># x330 on the PaperWhite
# x262 on the Touch. Doesn't choke on x330, though.
# x470 on the Voyage, checked that it works on PW, dont have Touch anymore
THUMBNAIL_HEIGHT = 470  
</code></pre>

<p>所以，如果你设计一张收藏夹封面缩略图，那么建议的大小可以是294x470px，或者上述列出的大小中最接近你的设备的值。</p>

<p>无论如何，假设你有这样一张收藏夹封面图，那么你可以用“发送到Kindle（参见后文）”这样的功能来上传它（而不是直接从电脑里复制文件到设备中），这样才能使它有效。</p>

<h2 id="">三、首页列表封面</h2>

<p>首页列表封面是当你按下“导航”栏中的“首页（Home）”按钮时，返回到首页——这时你的文档会出现在首页推荐（可能是前三个）——时出现的封面图。当然，这需要当前在“网格视图”模式下，因为列表模式是不显示封面的。</p>

<p>这个封面的特殊之处在于它其实与下面所说的“电子书封面”（第四种）是同一个，但是显示方式会不同。就目前来说，当可能显示成完整大小和1/2大小两种模式——在首页列表中。</p>

<p>因此你得考虑在这个模式下它让人比较舒适的大小——毕竟这是最常见的、第一视觉的。然而，同样不幸的是，它也没有官方文档支持。你在“电子书封面”（第四种）中设置了多大，它就在首页等比缩放然后显示出来，完全无视宽高比、清晰度等等任何东西。</p>

<p>而且，它还会在右上角占掉一个位置来显示“当前阅读进度”。通常，它可能还会遮挡一点你的书名。</p>

<p>总之是很崩溃的。</p>

<h2 id="">四、电子书封面（内容封面）</h2>

<p>这才是一本书“正式的”封面。所谓正式的，是因为它被写入到你的电子书(.mobi或.azw3等)文件内部，是不变的。</p>

<p>通常情况下，它是一本相应纸质书的封面。所以它事实上的大小，也不是亚马逊所能决定的。也因为同样的缘故，“如何很好地显示它”就变成了问题。</p>

<blockquote>
  <p>有文章推荐说这里的封面宽高比推荐是1:1.725。我尝试过，但这种封面过高，显得特别瘦窄。而且跟实体书比例差距过大，很难制作出一张比例协调的封面用图。</p>
</blockquote>

<p>如上一小节所说，它会在“首页列表封面”上显示，然而可能因为它的比例显示得不那么好看。另外一种“更正确地”找到它的方法，是打开这本书之后，进入目录，在最前面处找到“封面”并点击进入。</p>

<p>这样看到的封面才是“电子书封面”真正的样子。当然，也可能很不幸，因为它可能根本不是为你的设备而设计的，于是很可能底边是空白的，或左右两侧是空白的。</p>

<p>总而言之，你无法决定这张封面如何在设备上显示。</p>

<h2 id="">五、总结</h2>

<p>没有什么好方法确保第四种模式在“所有设备”上都能获得很好的阅读体验。建议你制作的封面能让它在第三种模式（首页列表封面）正确而友好的显示即可。</p>

<p>这种情况下，我一般建议封面是采用1200x860模式，它比较接近A4开本的封面，即使你在真实印刷中使用也不需要对版面布局明显修改。</p>

<p>如果你使用新的.azw3（KF8）格式，那么目前没有办法得到收藏夹封面。“发送”功能只能将新文档.azw3放在“Docs”分类中，因此会是一个没有封面的显示“个人文档”（也称为PDOC）。</p>

<blockquote>
  <p>这篇文章：<a href="http://aimingoo.github.io/1-1730.html">《如何将电子书发送到Kindle》</a>，会有关于这个问题的更详细解释。</p>
</blockquote>

<p>如果你有兴趣，可以进一步阅读这篇：<a href="http://www.inknet.com.tw/help/teach/page/2">作品版面尺寸的設定</a>，以及这篇<a href="https://www.epubble.com/kindle-book-cover-size">Kindle book cover size</a>。</p>]]></content:encoded></item><item><title><![CDATA[如何将电子书发送到Kindle]]></title><description><![CDATA[<p>前面我们讲到过“如果要在收藏夹模式下看到封面，需要将电子书‘发送’到设备”。</p>

<p>但这个“发送电子书”的功能其实有很多限制，下面我们来讲讲到底该如何做。</p>

<h2 id="1">1. 先说一个例外</h2>

<p>首先，这事实上有一个例外。在<a href="http://blog.sina.com.cn/s/blog_5374fceb0102v58q.html">seutfy的文章</a>中讲到，有以下几个条件：</p>

<ol>
<li>113(ASIN)值是真实的，与亚马逊上的值相同；  </li>
<li>504(ASIN)值与113相同，也是真实的；  </li>
<li>501(CDE type)值为EBOK。</li>
</ol>

<p>满足以上三个条件，此电子书会在联网的情况下自动从亚马逊服务器上下载封面。为什么呢？因为这意味着这是一本在亚马逊官方发布过的电子书，因此可以在它的服务器上搜索到。这也是有些电子书你能直接复制到Kindle设备中，并且显示它的封面的原因——他们“原本”是从官方下载的。</p>

<h2 id="2kindle">2. 找到你的Kindle所绑定的邮箱</h2>

<p>所以，继续回到正题。如果这是一本“自制的”——或者非官方网站下载来的电子书，那么你还是得用“将电子书发送到Kindle”的方法。这也是有开源的脚本代码的，</p>]]></description><link>http://aimingoo.github.io/1-1730.html/</link><guid isPermaLink="false">e69047cf-8e61-4488-8dfc-2399d339590f</guid><category><![CDATA[Kindle]]></category><category><![CDATA[电子书]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Mon, 12 Jun 2017 18:55:24 GMT</pubDate><content:encoded><![CDATA[<p>前面我们讲到过“如果要在收藏夹模式下看到封面，需要将电子书‘发送’到设备”。</p>

<p>但这个“发送电子书”的功能其实有很多限制，下面我们来讲讲到底该如何做。</p>

<h2 id="1">1. 先说一个例外</h2>

<p>首先，这事实上有一个例外。在<a href="http://blog.sina.com.cn/s/blog_5374fceb0102v58q.html">seutfy的文章</a>中讲到，有以下几个条件：</p>

<ol>
<li>113(ASIN)值是真实的，与亚马逊上的值相同；  </li>
<li>504(ASIN)值与113相同，也是真实的；  </li>
<li>501(CDE type)值为EBOK。</li>
</ol>

<p>满足以上三个条件，此电子书会在联网的情况下自动从亚马逊服务器上下载封面。为什么呢？因为这意味着这是一本在亚马逊官方发布过的电子书，因此可以在它的服务器上搜索到。这也是有些电子书你能直接复制到Kindle设备中，并且显示它的封面的原因——他们“原本”是从官方下载的。</p>

<h2 id="2kindle">2. 找到你的Kindle所绑定的邮箱</h2>

<p>所以，继续回到正题。如果这是一本“自制的”——或者非官方网站下载来的电子书，那么你还是得用“将电子书发送到Kindle”的方法。这也是有开源的脚本代码的，例如<a href="https://github.com/serzh/tokindle">tokindle</a>，或者
<a href="https://github.com/nicholaswilde/upload2Kindle">upload2Kindle</a>。原理上也完全一样：就是向与你的Kindle设备绑定的一个邮箱发电子书附件。</p>

<p>你得首先知道这个绑定的邮箱。这事实上有两个（注意，这两个并不一样），其一是你的amazon登录账号，另一个则是每个设备（例如你有多个kindle）都独有的一个邮箱。</p>

<p>我强烈建议你读一下这篇文章<a href="http://www.hangge.com/blog/cache/detail_1626.html">《将电子书发送到Kindle上的几种方法》</a>所讲，并且建议你先立即开始尝试一下其中的方法2，即“<strong>官方软件Send to kindle</strong>”，下载地址在<a href="https://www.amazon.com/gp/sendtokindle/pc">这里</a>，或<a href="https://www.amazon.com/gp/sendtokindle/mac">Mac版本</a>。</p>

<p>这个官方的“<strong>Send to Kindle</strong>”软件的好处是简单、安全可信：你填入你的amazon账号就可用了。并且，它会列出你可以发送到的Kindle设备列表。但是，它只支持向设备有限格式的电子书（DOC,DOCX,PDF,HTML,TXT and RTF），别的格式（例如你自制的.azw3）都不支持。</p>

<blockquote>
  <p>Kindle的.mobi格式没有在上述列表中，但是“<strong>Send to Kindle</strong>”是支持的。另外，你可以直接将.azw3更名为.mobi，也是可以用该软件发送的。但是，无论如何这都是跳不出后面讲到的关于封面的限制。</p>
</blockquote>

<p>但是因为其它软件的原理是一样的，所以我们知道，关键在于找到amazon账号下面的那个“可以发送到的Kindle设备列表（Deliver to list）”。如果你从网站上登录你的amazon账号，那么可以在“Manage Your Content and Devices”中找到它。</p>

<blockquote>
  <p>图：官方网站入口
  <img src="http://aimingoo.github.io/content/images/2017/06/-----2017-06-12-23.56.59.png" alt=""></p>
</blockquote>

<p>更快捷的方法是在上面的“<strong>Send to Kindle</strong>”软件中，在它的界面的最下边有“Manage your Kindle”，点击进入就可以了（这就是我建议你先尝试它的主要原因了）。</p>

<p>现在你应该在官方网站的“Manage Your Content and Devices”界面中，点击其中的“Your Devices”页，并在你的设备列表的左侧找到“…”按钮(Actions)，点击它会看到一个弹出框，上面就写着这个设备所绑定的email了，通常它是：xxxxx@kindle.com。</p>

<h2 id="3">3. 将发送邮箱添加到许可列表</h2>

<p>接下来我们再切换到“Settings”页，找到“Approved Personal Document E-mail List”选项，你会看到你的amazon登录邮箱已经默认地添加在这里——这就是“<strong>Send to Kindle</strong>”这个软件能工作的原因了。如果你打算用别的邮箱来发电子书，那么你可以将邮箱地址添加到这里，否则是不能用的——如果你没有添加，那么用其它邮箱发电子书的时候，会被拒绝并在你的amazon登录邮箱中收到一个提醒邮件。</p>

<blockquote>
  <p>这里提到这个细节的原因，是Calibre这个软件会推荐你使用gmx或hotmail邮箱。那么这时，就需要将这些邮箱地址添加到这个列表中去了。</p>
  
  <p>另外，gmx缺省不开放SMTP邮箱服务。因此如果你真在Calibre尝试这个邮箱，那么要先去开通它（我已经被坑过了）。</p>
</blockquote>

<h2 id="4calibre">4. 使用Calibre或其它发送工具</h2>

<p>接下来，当你知道：</p>

<ul>
<li>你的设备绑定的邮箱，例如xxxxx@kindle.com；且</li>
<li>你已经将打算发邮件的邮箱（例如你的登录账号或xxx@gmx.com等）添加到上述列表。</li>
</ul>

<p>那么你就可以使用Calibre或其它的什么工具来发送你的电子书到你的设备了。由于最终其实经过Kindle官方的邮件服务（因为最终绑定的是xxxxx@kindle.com）来处理，所以下发到你的Kindle设备时，就可以有一张“收藏夹封面”图了。</p>

<p>其它细节，仍推荐阅读：<a href="http://www.hangge.com/blog/cache/detail_1626.html">《将电子书发送到Kindle上的几种方法》</a>，或者这一篇<a href="https://kindlefere.com/post/11.html">《Calibre 使用教程之邮件一键推送电子书》</a>。</p>

<h2 id="5">5. 这个功能是有限制的</h2>

<p>本质上来说，这样通过“发送”来得到的并不是“电子书”，而是电子文档。所以你在官方网站的“Manage Your Content and Devices”界面中的“Your Content”页面下，只能通过“Docs”这个分类来找到它——而不是缺省的Books分类。这也是惟一能操作这些文档的方法，因为你不能在设备上直接删除它们。</p>

<p>在早期，Calibre可以制作一个.azw3格式的电子书并通过发送功能上传到设备（而且可以显示在Books分类中，并显示封面）。<strong>但现在这样的方法已经失效了。</strong>amazon严格控制了使用邮件分发的方法来上传电子书的类型（上面列举过的），并且它会返回给你的邮箱一封关于失败原因的通知邮件。</p>

<p>不过Calibre仍然是可以将一个使用官方KindleGen制作的.azw3文件发送到设备的。如上所述的，它在“Docs”分类中，并且没有封面——因为amazon认为它不是电子书。</p>

<h2 id="6azw3">6. 能使.azw3拥有封面的终极大招</h2>

<blockquote>
  <p>已失效。低版件固件可尝试。Comment @2017.06.13</p>
</blockquote>

<p>最后，我知道你和我一样是有着对阅读有着近乎洁癖的要求：我完全不能忍受一本没有封面，或没有目录的书！</p>

<p>好吧，如果这样，关于收藏夹封面的问题还是有解的：你可以使用<a href="https://github.com/quiris11/ExtractCoverThumbs">ExtractCoverThumbs</a>这个开源工具。作者发布了它的GUI和Console for Mac的版本（下载在上面地址的releases中）。如果你使用Windows，那么你可以自己下载一份源码（也可以编译成Window GUI的版本）来使用。</p>

<p>ExtractCoverThumbs这个工具的作用是直接在你的Kindle的<code>/Volumes/Kindle/system/thumbnails/</code>目录中生成封面的缩略图文件——因此绕开了从Kindle官方的下载过程。它可以操作很多类型的电子书或文档，并且可以帮助你从网上自动下载封面。不过，注意有一项限制：</p>

<blockquote>
  <p>如果你的Kindle固件版本在5.8.5之后，并且仅只针对“用Send功能发送，并同步到Kindle上的‘Docs’”，那么这个工具是不能帮你换封面的。</p>
</blockquote>

<p>其它所有情况下，它工作得很好。所以，如果是一个.azw3文件，那么你从电脑中复制到Kindle中去，并且用ExtractCoverThumbs处理一下，就OK了。</p>]]></content:encoded></item><item><title><![CDATA[在电子书中使用SVG]]></title><description><![CDATA[<blockquote>
  <p>在之前的文章中，我们讨论了《<a href="http://aimingoo.github.io/1-1726.html">Kindle电子书中该用多大的图片</a>》，以及《<a href="http://aimingoo.github.io/1-1727.html">详解ImageMagick中SVG的支持</a>》，本文可以看作它们的后续。</p>
</blockquote>

<p>在高版本的电子书格式中是可以支持使用.svg作为图片的，并且看起来与.png/.jpg的使用并没有什么不同。但是，如何制作合适大小的.svg却是一个相当烦恼的问题。</p>

<p>因为电子书在.svg文件上采用了与.png/.jpg不一样的排版规则。</p>

<h2 id="svg">一些.svg相关的基础知识</h2>

<p>与.pdf一样，事实上.svg文件中也是没有DPI信息的，因为它们都是以矢量格式为基础的。而且它们也都相同的使用Points（磅值/点）来记录图片大小，或称之为页面信息。</p>

<p>一般来说，.svg不支持多页。尽管多页格式已经发布（<a href="https://www.w3.org/TR/2004/WD-SVG12-20041027/multipage.html">SVG 1.2</a>），但多数系统并不支持它。</p>

<p>所谓『.svg文件有多大的精度，或多少DPI』其实是个伪命题。因为这其实是不同的处理软件的一个假设/约定——这一点与.pdf是一样的。但不同的是：</p>

<ul>
<li>.pdf约定默认的分辨率是72DPI；而</li>
<li>.svg通常约定的是90DPI。</li>
</ul>

<p>然而即使是同一个软件的不同版本，</p>]]></description><link>http://aimingoo.github.io/1-1728.html/</link><guid isPermaLink="false">d18ac6ba-a8ce-4b89-8f4e-57b5655612c7</guid><category><![CDATA[电子书]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[svg]]></category><category><![CDATA[ImageMagick]]></category><category><![CDATA[Kindle]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 07 Jun 2017 19:02:44 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>在之前的文章中，我们讨论了《<a href="http://aimingoo.github.io/1-1726.html">Kindle电子书中该用多大的图片</a>》，以及《<a href="http://aimingoo.github.io/1-1727.html">详解ImageMagick中SVG的支持</a>》，本文可以看作它们的后续。</p>
</blockquote>

<p>在高版本的电子书格式中是可以支持使用.svg作为图片的，并且看起来与.png/.jpg的使用并没有什么不同。但是，如何制作合适大小的.svg却是一个相当烦恼的问题。</p>

<p>因为电子书在.svg文件上采用了与.png/.jpg不一样的排版规则。</p>

<h2 id="svg">一些.svg相关的基础知识</h2>

<p>与.pdf一样，事实上.svg文件中也是没有DPI信息的，因为它们都是以矢量格式为基础的。而且它们也都相同的使用Points（磅值/点）来记录图片大小，或称之为页面信息。</p>

<p>一般来说，.svg不支持多页。尽管多页格式已经发布（<a href="https://www.w3.org/TR/2004/WD-SVG12-20041027/multipage.html">SVG 1.2</a>），但多数系统并不支持它。</p>

<p>所谓『.svg文件有多大的精度，或多少DPI』其实是个伪命题。因为这其实是不同的处理软件的一个假设/约定——这一点与.pdf是一样的。但不同的是：</p>

<ul>
<li>.pdf约定默认的分辨率是72DPI；而</li>
<li>.svg通常约定的是90DPI。</li>
</ul>

<p>然而即使是同一个软件的不同版本，也可能修改这个约定。例如Inkscape 从v0.92版本开始就默认使用96DPI的约定——而之前它是90DPI（<a href="http://wiki.inkscape.org/wiki/index.php/Release_notes/0.92#Important_changes">参见这里</a>，以及<a href="http://wiki.inkscape.org/wiki/index.php/Units_In_Inkscape">这里</a>）。</p>

<p>相对好一些的消息是：能够实现SVG处理的引擎并不太多——所以上述的一些不确定的限制条件也就相对来说容易穷举。这些引擎主要包括Cario、Inkscape、Apache Batik和一些浏览器上的Canvas。当然，此前讲过的ImageMagick内置的MSVG也算一个，不过它实在弱到没朋友，不提也罢。很多工具其实是以上述引擎为内核或库的，其中最常用的是Cario，包括rsvg在内的许多库/包都只是Cario上的一个封装。</p>

<blockquote>
  <p>注1：Cario库也支持PDF，所以Inkscape、Poppler等都使用它来输出PDF和PostScript文档（生成的.pdf文件元信息中Creator也是Cario）。但是Inkscape的SVG渲染引擎是自有的，相关信息可以参考<a href="https://en.wikipedia.org/wiki/Cairo_(graphics)">这里</a>。</p>
</blockquote>

<p>本文中提到的一些工具可以用如下方式安装：</p>

<pre><code class="language-bash">## rsvg, rsvg-convert, and cario ...
&gt; brew install libsvg librsvg libsvg-cairo cairo

## pdf2svg, mactex(pdfcrop), Inkscape, more...
&gt; brew install pdf2svg
&gt; brew cask install xquartz mactex inkscape

# ImageMagick(identify,convert,mogrify...), and pdfinfo or cpdf
&gt; brew install ghostscript imagemagick cpdf poppler

## cairosvg for python
&gt; pip3 install cairosvg

## svginfo
&gt; git clone http://github.com/aimingoo/svginfo
&gt; install svginfo/svginfo /usr/local/bin/
</code></pre>

<h2 id="pdfsvg">从PDF到SVG</h2>

<p>你可能已经习惯使用种种矢量图形工具并用来制作.svg，反正我不是。我通常是用PowerPoint或Keynote来制作它们（尤其是表格）并存储为PDF，然后由.pdf转为.svg。</p>

<p>这个过程看起来麻烦，但确实靠谱。</p>

<p>总的来说，从PDF到SVG的工具主要有两个（<a href="https://en.wikipedia.org/wiki/Wikipedia:Graphics_Lab/Resources/PDF_conversion_to_SVG#How_to_convert_a_PDF_to_SVG">Wiki上也是这么说的</a>）。其中最方便、快捷和安全的应该是cityinthesky的pdf2svg，他使用Poppler+Cario；另一个是inkscape，除了在字体处理上表现不稳定之外，它还需要XQuartz的支持（这就比较庞大了）。</p>

<p>pdf2svg可以直接使用brew安装，它的开源项目<a href="http://www.cityinthesky.co.uk/opensource/pdf2svg">在这里</a>，或<a href="https://github.com/indraniel/pdf2svg">这里</a>。采用相同技术实现的还有<a href="https://github.com/indraniel/pdf2svg">Perl</a>和<a href="https://github.com/jakobwesthoff/pdf2svg">Vala</a>的版本——因为使用的都是相同的库，因此效果应该没差。其它可选的方案包括<a href="https://github.com/ContentMine/pdf2svg">Java</a>、<a href="https://github.com/ststeiger/Pdf2Svg">C#</a>版的等等，但采用的是各自语言下的引擎，我没有一一试过。</p>

<p>使用pdf2svg的参数如下：</p>

<pre><code class="language-bash">&gt; pdf2svg --help
Usage: pdf2svg &lt;in file.pdf&gt; &lt;out file.svg&gt; [&lt;page no&gt;]  
</code></pre>

<p>其中<code>&lt;page no&gt;</code>可以使用字符串<code>all</code>。</p>

<p>注意pdf2svg并不能指定输出的.svg的大小、DPI等等。其实你使用inkscape来转换也一样没有这类参数——在转换目标格式为.svg时，inkscape仅会多出<code>--export-text-to-path</code>、<code>--export-id</code>两个参数可用。此外，inkscape只能处理单页的PDF：</p>

<pre><code class="language-bash">&gt; inkscape -z --export-plain-svg=&lt;out file.svg&gt; &lt;in file.pdf&gt;
</code></pre>

<p>最后，pdf2svg与inkscape转换出来的.svg文件的页面大小其实是一样，但是它们使用的单位并不相同。如下：</p>

<pre><code class="language-bash">## inkscape
&gt; svginfo by-inkscape.svg
width: 152.5  
height: 77.5  
viewBox: 0 0 152.5 77.5

## pdf2svg, and more...
&gt; svginfo by-cario.svg
width: 122pt  
height: 62pt  
viewBox: 0 0 122 62  
</code></pre>

<p>注意inkscape转出时使用了缺省单位，这通常是指px；而cario转出时使用的是pt。对于上例来说，原始的pdf文件信息如下：</p>

<pre><code class="language-bash">&gt; pdfinfo my.pdf | grep 'Page size'
Page size:      122 x 62 pts  
</code></pre>

<p>可见，两种引擎事实上都是直接以该页面大小的pt值作为.svg的宽高，只不过inkscape转换成了相应的px值。</p>

<blockquote>
  <p>注1：需要强调的是，上述版本的inkscape的采用的是90DPI的.svg设定，而PDF默认为72DPI。所以从<code>.PDF的Pts</code>到<code>.SVG的px</code>的转换系数是<code>90/72</code>，即<code>width = 122pt * 90/72 = 152.5px</code>。</p>
  
  <p>注2：就我的测试来说，Inkscape在处理<code>PDF -&gt; png</code>的转换时不能正确的识别中文字体，其它类型下的转换我并没有一一试过。</p>
</blockquote>

<h2 id="svginfoimagemagick">svginfo: 不要相信ImageMagick的显示</h2>

<p>如果你使用<code>identify -verbose your.svg</code>来查看svg的信息的话，那么由于ImageMagick可能工作在不同的SVG模式下，所以输出的信息也就不同。——这就是我的上一篇文章为什么叫《详解ImageMagick中SVG的支持》的原因。</p>

<p>我测试了一下上文中提到的4种模式，如下：</p>

<pre><code>## test information of 'identify -verbose your.svg'
===&gt; MODE: internal, use MSVG
  Geometry: 485x306+0+0
  Units: Undefined
===&gt; MODE: build-in, use RSVG/librsvg
  Geometry: 517x327+0+0
  Resolution: 37.8x37.8
  Print size: 13.6772x8.65079
  Units: PixelsPerCentimeter
===&gt; MODE: delegate(internal), use inkscape
  Geometry: 517x327+0+0
  Resolution: 37.8x37.8
  Print size: 13.6772x8.65079
  Units: PixelsPerCentimeter
===&gt; MODE: delegate, use rsvg-convert
  Geometry: 517x327+0+0
  Units: Undefined
</code></pre>

<p>这四种模式中，MSVG是唯一一个不转换成图片（因为内置xml解析和svg支持）的方式，也是它与别的模式看起来有差异的原因。此外，由于缺省使用了<code>PixelsPerCentimeter</code>单位，所以Resolution显示是<code>37.8x37.8</code>，换算成英寸则是96DPI。</p>

<p>那么这个<code>your.svg</code>的大小到底是多少呢？很不幸，它真实的数据是<code>388x245 pts</code>。</p>

<p>因为svg缺省是工作在90dpi模式下的，所以MSVG用90dpi来换算.svg的大小，就得到了<code>388 * 90/72 = 485px</code>的宽，而其它模式都是先转换成图片，并指定了参数96DPI，这时宽度就成了<code>388 * 96/72 = 517px</code>。</p>

<p>所以无论如何（除非你能确切指定使用某一种SVG引擎），对于.svg来说，ImageMagick显示的大小是作不得准的。更好的办法是直接显示.svg中的元信息，例如使用<code>svginfo</code>这个工具（<a href="https://github.com/aimingoo/svginfo">下载在这里</a>）：</p>

<pre><code class="language-bash">&gt; svginfo your.svg
width: 388pt  
height: 245pt  
viewBox: 0 0 388 245  
zoomAndPan: magnify  
preserveAspectRatio: none  
</code></pre>

<p>在.svg的元信息中保存的width/height值可能有很多种单位（<a href="http://www.sarasoueidan.com/blog/svg-coordinate-systems/#svg-viewport">参见这里</a>，或<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Positions">中文译本</a>，缺省是px，但与具体设备有关）。</p>

<h2 id="svg">电子书并其实不能『很正确』地显示.svg文件</h2>

<p>现在我们得到了.svg，并且我们确切地知道它的大小与.pdf的Page Size的Pts值存在<code>90:72</code>的关系（因为默认精度不同）。所以我们只需要控制.pdf的大小，就可以得到合适的.svg文件了。——不考虑.svg的工具的话，在.pdf的工具套件中还有cpdf，还有gs等等可用，很丰富。</p>

<p>但是，真正的一张520pts(或者是520px)大小的.svg，会如何显示在电子书上呢？</p>

<p>答案是：不一定。</p>

<p>如果你在电子书中用<code>&lt;img src="xxx.png"&gt;</code>来插入一张图片而没有指定它的宽高，那么几乎所有的排版引擎都能理解这个行为：</p>

<ul>
<li>将xxx.png图片信息中的宽高信息作为显示宽高；</li>
<li>如果这个宽高大于设备的可见区域，则缩小到合适的大小。</li>
</ul>

<p>——所以，在电子书中使用图片时只需要考虑图片的精度，其它方面几乎是完美的、自适应的。</p>

<p>然而如果你用同样的方法来插入一个.svg文件，那么由于pt这个单位的存在，所以设备如何显示就成了『谜之问题』了。首先我们要知道，</p>

<blockquote>
  <p>如果一个.svg是使用px作为单位（也包括没有单位而缺省的），那么将采用与图片一致的规则。</p>
</blockquote>

<p>这是一条重要的原则，也成为检测其它.svg单位的关键钥匙。</p>

<p>例如以前面的your.svg为例——它使用了pt作为单位，是388pt。由于.svg是缺省以90DPI为来计算pt值的，所以MSVG还原成px时，显示的是485px的宽。但是到了实际物理设备时，却不一定是以90DPI——这个假想值——来处理的了。例如在Macbook上的iBooks中显示时，iBooks的SVG渲染引擎采用了96DPI的预设值，所以就将显示成<code>388 * 96/72 = 517px</code>；又例如我是要在Kindle Paperwhite3上来显示它，那么由于Kindle使用它的PPI（300DPI）来作为预设值，所以显示出来就应该是惊人的<code>1616px</code>。——好吧，你知道Kindle显示不下了，而.svg是矢量缩放的，所以最终只是按可见区域的全宽来显示它。</p>

<p>电子书的这个处理方案正确不呢？答案是『正确』。因为这其实就是pt作为单位的原始用意。它看起来不是那么『很正确』的原因在于：这样一来，我们就不知道到底该做多大的.svg才能在不同的物理设备上适用了。</p>

<p>那么，最终只剩下了两条规则适用：</p>

<ul>
<li>在文件中明确使用px作为单位来指定大小的.svg；或者，</li>
<li>在使用<code>&lt;img ...&gt;</code>标签插入.svg时，指定它的宽高信息。</li>
</ul>

<h2 id="pxsvg">使用px作为单位来指定大小的.svg</h2>

<p>使用Inkscape转出的.svg是作用缺省单位px的。但是这个转换是采用.pdf的Points换算过来的，为此你必须将.pdf放大一些，才能在Inkscape中得到你预期的的px值大小。这个换算关系如下：</p>

<pre><code class="language-bash"># 步骤1：将.PDF的大小换算成300DPI下比例(放大300/90倍)
#    - 因为pdf转成svg时还要再放大90/72倍，所以这里不需要直接用300/72作系数
&gt; cpdf -scale-page "3.33333 3.33333" -scale-to-fit-scale 3.33333 -o new_300DPI.pdf my.pdf

# 步骤2：将新文件转换成.svg
&gt; inkscape -z --export-plain-svg=my.svg new_300DPI.pdf

# 查看原始的my.pdf的信息
&gt; pdfinfo my.pdf | grep 'Page size'
Page size:      122 x 62 pts

# 查看中间文件.pdf的大小
&gt; pdfinfo new_300DPI.pdf | grep 'Page size'
Page size:      406.666 x 206.666 pts

# 查看新的.svg的信息
&gt; svginfo my.svg
width: 508.33282  
height: 258.33307  
viewBox: 0 0 508.33282 258.33307  
zoomAndPan: magnify  
preserveAspectRatio: none  
</code></pre>

<p>验证方法：制作一张<code>508 x 258</code>的图片，与my.svg一起插入到电子书中，它们显示起来将是相同大小。</p>

<h2 id="svg">正确插入.svg的宽高信息</h2>

<p>我们也可以选择如下的途径（在这个过程中不需要对调整中间文件与.svg的大小）：</p>

<blockquote>
  <ul>
  <li>从.ppt/.key转换到.pdf，再</li>
  <li>从.pdf转换到.svg，最后</li>
  <li>在电子书中插入.svg的宽度信息。</li>
  </ul>
</blockquote>

<p>我们假设以.html作为生成电子书的中间格式（如果你真做过电子书的话，你应该知道我为什么这么假设），那么事实上我们就只需要扫描所有的.svg，通过svginfo来查看信息，经过计算并将正确的宽高信息写到.html就好了。</p>

<p>我们需要知道相应的.svg与最初预设的宽高上限（注意考虑到实际使用，我只预设了x方向上限，并不处理y方向）。我们之前说过：合理的预设是<code>520px</code>。所以，例如480px宽的.svg，那么我们就将<code>&lt;img …&gt;</code>中的width值回写成<code>92.3%</code>。</p>

<p>我想，你可能已经发现问题了：这个92.3%应该是指的图片相对于当前设备宽的比例啊，而不是图片自己的宽度值。——是的，我的确是这样考虑的，至于为什么，你得仔细去思考了。</p>

<p>其它（建议综合我最近的几篇文章来理解下述过程）：</p>

<ul>
<li>我们原始设计的宽是520px，在300DPI情况下的物理宽是1.73333inch；</li>
<li>当把上述文档输出成PDF时，物理宽（Print Size）不变；而精度变成了PDF默认的72，所以在转换成Points值时变成了124.8pt，即<code>1.73333inch * 72pt/inch</code>；</li>
<li>我们再从.pdf转到.svg时是pt by pt的，所以相应的.svg值是124.8pt；
<ul><li>如果使用Inkscape，则转换出的.svg是<code>width = 156</code>，使用了缺省单位px；</li></ul></li>
<li>使用<code>identify msvg:your.svg</code>取值最快，但要注意它总是以px为单位显示宽高信息；
<ul><li>在不支持MSVG的ImageMagick的低版本中，建议用svginfo取值并转换单位</li></ul></li>
</ul>

<p>相关操作如下（下载<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.pdf">standard_image_templet_520.pdf</a>）：</p>

<pre><code class="language-bash"># 步骤1：使用hires参数和高的resolution值可以使crop操作更精确
#    - 输出的.pdf的精度与该参数值是无关的
&gt; pdfcrop --hires --resolution 1200 standard_image_templet_520.pdf croped.pdf

# 步骤2：转换pdf到svg
&gt; pdf2svg croped.pdf standard_image_templet_520.svg 1

# 使用pdfinfo查看信息
&gt; pdfinfo croped.pdf | grep 'Page size'
Page size:      124.8 x 73.26 pts

# 使用svginfo查看信息
&gt; svginfo standard_image_templet_520.svg
width: 124.8pt  
height: 73.26pt  
viewBox: 0 0 124.8 73.26  
zoomAndPan: magnify  
preserveAspectRatio: none

# 使用identify查看信息(强制使用MSVG引擎)
&gt; identify msvg:standard_image_templet_520.svg | xargs -n1
msvg:standard_image_templet_520.svg=&gt;standard_image_templet_520.svg  
MSVG  
156x92  
156x92+0+0  
...
</code></pre>

<h2 id="">黑科技：最后一点补充</h2>

<p>如果：</p>

<ul>
<li>你确实想让.svg用px作为单位，以避免修改电子书中的width/height信息；并且，</li>
<li>你确实又憎恨Inkscape的巨大安装包和超慢速度，以及它只能处理单页的问题；并且，</li>
<li>你不太担心pdf2svg转换后的.svg文件较大的问题；并且，</li>
<li>……</li>
</ul>

<p>也许你只是纯粹的点处理爱好者（px fans?），那么好吧，我们讲一种最简单（目前看来也挺安全，但……我不做任何保证）的黑科技。下面仍然以<code>standard_image_templet_520.pdf</code>这个文件为例：</p>

<pre><code class="language-bash"># 步骤1：在300DPI下crop，以提高crop的计算精度
#    - 输出的croped.pdf的精度与该参数值是无关的
&gt; pdfcrop --hires --resolution 300 standard_image_templet_520.pdf croped.pdf

# 步骤1：将.PDF的大小假想成px单位，直接换算成300DPI下的大小
#    - 也就说无脑放大300/72倍就行啦
&gt; cpdf -scale-page "4.166667 4.166667" -scale-to-fit-scale 4.166667 -o scaled.pdf croped.pdf

# 步骤3：使用pdf2svg转换
#    - pdf2svg得到的.svg是使用pt为单位的, 无脑改成px就行啦
#    - pdf2svg可处理多页(会成批生成文件，所以不要用stdout；这里只做单页的示例)
#    - 使用sed时只替换了&lt;svg ...&gt;标签中的width/height，其它的不作处理
&gt; pdf2svg scaled.pdf /dev/stdout 1 |\
    sed -E '1,/^&lt;svg/s/(width|height)="([0-9.]*)pt"/\1="\2px"/g' &gt;\
    standard_image_templet_520.svg

# 查看最终的svg的大小
&gt; svginfo standard_image_templet_520.svg
width: 520.000042px  
height: 305.000024px  
viewBox: 0 0 520.000042 305.000024  
zoomAndPan: magnify  
preserveAspectRatio: none

# 使用ImageMagick的MSVG模式查看
&gt; identify msvg:standard_image_templet_520.svg | xargs -n2
msvg:standard_image_templet_520.svg=&gt;standard_image_templet_520.svg MSVG  
520x305 520x305+0+0  
16-bit sRGB  
...
</code></pre>

<p>为什么能这么做呢？</p>

<p>首先，我们知道.svg文件中其实并没有精度信息，所有的元素都是基于页面的大小来做换算的。而且，我们在这里用pdf2svg转换出的.svg还有两个特性：</p>

<ul>
<li>字体已经被转换成矢量信息，因此.svg中不包含字体及字体大小信息；</li>
<li>只有<code>&lt;svg …/&gt;</code>元素包含了页面宽高信息，其它元素是基于该信息的矢量。</li>
</ul>

<p>所以我们可以安全地将pt值直接替换成px。而这个方法，对于Inkscape生成的.svg就不适用，对比一下上面的两个特性你就明白了。反过来说，正是由于Cario引擎（pdf2svg使用的svg引擎）并不完整支持以px为单位的svg，所以使用该引擎——以及使用该引擎实现的工具来转换上述（修改后的）.svg到.png或其它格式的时候也是会出问题；而相对应的，Inkscape却能正确处理——它的引擎支持以px为单位的.svg。</p>

<p>最后，多啰嗦一句。由于pdf2svg转换时将字体转换成了矢量信息，这使得通过这种.svg转换成图片或其它格式时不会因为缺少字体而失真（相对应的，Inkscape就存在字体问题）。但是缺点也是有的，就是.svg文件会比较大一些，可能相应的处理速度也会略慢。</p>]]></content:encoded></item><item><title><![CDATA[详解ImageMagick中SVG的支持]]></title><description><![CDATA[<p>事实上ImageMagick是可以很好地支持svg的——当然，它只是将svg转成图片格式而不能反过来，毕竟它只是个图片处理工具。不论是在使用convert，identify还是mogrify等等时，只要操作的对象是一个.svg文件，那么ImageMagick就会启动这一机制。例如，当你使用identify查看一个.svg信息的时候，事实上你是在查看它转换后得到的一张.png图片：</p>

<pre><code class="language-bash">&gt; identify -verbose your.svg
Image: /var/folders/w9/fy0l4xgj3w73j4d71748v9nw0000gn/T/magick-481524PstlAlieWiB  
  Base filename: your.svg
  Format: PNG (Portable Network Graphics)
  Mime type: image/png
  Class: DirectClass
...
</code></pre>

<p>ImageMagick主要有三种支持SVG的方式，包括内置（Internal）、内建（Build-in）和委托（Delegate）。</p>

<p>在高版本的ImageMagick中MSVG总是内置的；而稍早些的版本中，</p>]]></description><link>http://aimingoo.github.io/1-1727.html/</link><guid isPermaLink="false">a849bf10-dbd6-4709-a2c2-dec2bc6c193c</guid><category><![CDATA[svg]]></category><category><![CDATA[ImageMagick]]></category><category><![CDATA[图形处理]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[电子书]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Mon, 05 Jun 2017 11:54:13 GMT</pubDate><content:encoded><![CDATA[<p>事实上ImageMagick是可以很好地支持svg的——当然，它只是将svg转成图片格式而不能反过来，毕竟它只是个图片处理工具。不论是在使用convert，identify还是mogrify等等时，只要操作的对象是一个.svg文件，那么ImageMagick就会启动这一机制。例如，当你使用identify查看一个.svg信息的时候，事实上你是在查看它转换后得到的一张.png图片：</p>

<pre><code class="language-bash">&gt; identify -verbose your.svg
Image: /var/folders/w9/fy0l4xgj3w73j4d71748v9nw0000gn/T/magick-481524PstlAlieWiB  
  Base filename: your.svg
  Format: PNG (Portable Network Graphics)
  Mime type: image/png
  Class: DirectClass
...
</code></pre>

<p>ImageMagick主要有三种支持SVG的方式，包括内置（Internal）、内建（Build-in）和委托（Delegate）。</p>

<p>在高版本的ImageMagick中MSVG总是内置的；而稍早些的版本中，ImageMagick是混合了『内建』和『委托』两种方式来提供SVG的支持的。<strong>需要强调的是</strong>：</p>

<blockquote>
  <p>请尽量不要直接使用内置的MSVG。</p>
</blockquote>

<h2 id="msvg">内置的MSVG</h2>

<p>ImageMagick的高版本内置了一个SVG渲染器。它有两种称谓，在代码中叫做<code>IMAGEMAGICK_SVG</code>，例如在编译中提供相应的开关参数；而在用户级别的配置或接口中，它称为MSVG（这里的M是Magick的首字母）。它完整的名称是<code>ImageMagick's own SVG internal renderer</code>，所以<code>自有SVG（Own SVG）</code>、<code>内部渲染器（internal renderer）</code>以及<code>MSVG</code>其实指的都是同一个东西：</p>

<pre><code class="language-bash">&gt; convert -list format | grep SVG
     MSVG  SVG       rw+   ImageMagick's own SVG internal renderer
      SVG  SVG       rw+   Scalable Vector Graphics (XML 2.9.4)
     SVGZ  SVG       rw+   Compressed Scalable Vector Graphics (XML 2.9.4)
</code></pre>

<p>注意这里的『XML 2.9.4』其实也是MSVG引擎的一部分，它实际上指的是<code>libxml2</code>这个库的版本，因为MSVG是基于xml解析并自行渲染的svg引擎。</p>

<p>由于MSVG存在很多限制，所以ImageMagick『千万百计』地隐藏了它的存在——哈哈，其实没有这么夸张，它们是承认这个东西的存在并且提供官方支持的（<a href="http://www.imagemagick.org/Usage/draw/#svg">在这里</a>）。</p>

<p>在ImageMagick <strong>6.6.7-10</strong>之后的版本中，MSVG总是缺省内置支持(<code>WITH_IMAGEMAGICK_SVG</code>参数缺省打开)，即使是在<code>WITHOUT_X11</code>状态下，编译过程也只是给出WARN级别的警告。</p>

<p>而在此前（ 但晚于v6.3.3-5之后的）版本中，如果<code>WITHOUT_X11</code>，那么编译时将不会内置支持SVG。</p>

<blockquote>
  <p>参考：<a href="https://www.freshports.org/graphics/ImageMagick/">https://www.freshports.org/graphics/ImageMagick/</a></p>
</blockquote>

<p>任何情况下，如果你只是想启用MSVG（以避开其它引擎的影响），那么你可以在input文件名上加上"msvg:"前缀（v6.3.4以后）。例如：</p>

<pre><code class="language-bash">&gt; identify -verbose 'msvg:your.svg'
Image: your.svg  
  Base filename: b2t_8-2.svg
  Format: MVG (Magick Vector Graphics)
  Class: DirectClass
  Geometry: 485x306+0+0
...
</code></pre>

<p>你也可以使用<code>-draw</code>参数来开启一个MSVG的画板并操作它。例如（将这块画板作为源，转换成PNG格式输出）：</p>

<pre><code class="language-bash"># http://www.imagemagick.org/Usage/draw/#svg
&gt; convert -size 10x6 xc:skyblue  -fill black \
          -draw 'color 6,3 point' -scale 100x60 draw_color_point.png
</code></pre>

<h2 id="">内建模式及其开启</h2>

<p>如果ImageMagick在安装时包含librsvg模块，那么就会启用内建模式（所以Build-in SVG也往往直接称为RSVG）。一旦包含这个模块，那么它的优先级比内置的MSVG要高。</p>

<p>如果你是使用brew来安装的ImageMagick，那么你可以用：</p>

<pre><code class="language-bash">&gt; brew info imagemagick
...
Optional: fontconfig ✔, little-cms ✘, little-cms2 ✔, libwmf ✘, librsvg ✔ ...  
</code></pre>

<p>来查看当前环境是否能支持rsvg。如上，<code>librsvg</code>已经安装了，那么就可以通过安装参数来开启它（或使用<code>brew reinstall</code>重新安装）：</p>

<pre><code class="language-bash"># 你可能需要先安装librsvg模块
#    - brew install librsvg
&gt; brew install imagemagick --with-librsvg
</code></pre>

<p>如果你不是使用brew，那么你可以使用如下命令来查看：</p>

<pre><code class="language-bash">&gt; convert -list configure | grep -Eoe '--with-rsvg(=[^\-]+)?'
--with-rsvg=no
</code></pre>

<p>如果没有rsvg的支持，那么你需要自己编译ImageMagick，相关的操作<a href="http://www.imagemagick.org/script/advanced-unix-installation.php">在这里</a>。</p>

<p>如果你成功安装了rsvg支持，那么可以看到如下信息：</p>

<pre><code class="language-bash"># build-in的delegate中包含了rsvg
&gt; identify -version | grep --color rsvg
Delegates (built-in): bzlib cairo fontconfig freetype jng jpeg ltdl lzma png rsvg tiff xml zlib

# 或format中使用了rsvg来支持svg
&gt; identify -list format | grep -i svg
convert -list format | grep -i svg  
     MSVG  SVG       rw+   ImageMagick's own SVG internal renderer
      SVG  SVG       rw+   Scalable Vector Graphics (RSVG 2.40.17)
     SVGZ  SVG       rw+   Compressed Scalable Vector Graphics (RSVG 2.40.17)
</code></pre>

<blockquote>
  <p>注1：一些资料中称需要使用<code>--use-rsvg</code>参数在编译中开启rsvg支持，这可能是一个被放弃的、早期的构建参数。</p>
  
  <p>注2：在brew中用的参数是<code>--with-librsvg</code>，而实际上编译时使用的是<code>--with-rsvg</code>参数。这个转换操作是在brew安装用的formula文件中完成的。</p>
</blockquote>

<h2 id="">委托模式的开启</h2>

<p>通常情况下，ImageMagick会在内置的MSVG和内建模式（RSVG）之间选择一个；如果二者都没有，那么它会选择第三种，也就是委托模式。</p>

<p>你总是可以通过如下命令查看ImageMagick委托（外部程序）来进行的图形转换，包括SVG：</p>

<pre><code>&gt; convert -list delegate | grep 'svg'
...
svg =&gt;          "rsvg-convert' -o '%o' '%i"  
</code></pre>

<blockquote>
  <p>注：严格来说，前面说的内建模式事实上也是一种委托。只不过它是在编译时build-in的，所以在<code>--help</code>参数显示的信息中就能直接看到，并且会影响<code>-format</code>显示的格式支持；而在<code>-list delegate</code> 所列举的委托关系中，却并不会出现。</p>
</blockquote>

<p>由于只有MSVG和rsvg都不生效时才会开启委托模式，但高版本中ImageMagick中总是内置MSVG，所以是很难触发委托模式的。因此，如果你做这个尝试，那么你需要一个不内置MSVG的低版本ImageMagick，并且在编译中关闭<code>--with-rsvg</code>选项。OK，这样你就可以看到ImageMagick调用了上述委托中的<code>rsvg-convert</code>来进行转换。</p>

<p>当然，也有例外，因为其实还是有一个后门来做这件事的，这就是所谓的内部委托。</p>

<h3 id="">内部委托</h3>

<p>准确地说法：MSVG这个内部渲染器提供了一个『内部委托（special internal delegates）』。这种内部委托与上面的<code>rsvg-convert</code>采用的是类似机制，但是通过<code>-list delegate</code>命令是无法查看到的——你得打开配置文件自己来找：</p>

<pre><code class="language-bash"># 查看你的ImageMagick将读取哪些配置文件
&gt; convert -debug all -list delegate 2&gt;&amp;1 | grep 'delegates.xml'
Searching for configure file: ...  
...
Path: /usr/local/Cellar/imagemagick/7.0.5-9/etc/ImageMagick-7/delegates.xml  
</code></pre>

<p>注意前面有一个搜索优先顺序的列表（你可能用得上），不过这里我们只需要关心最后这个<code>Path</code>就好了。打开这个文件，查找<code>svg:decode</code>，将<code>stealth="True"</code>删除掉。现在你就可以看到它了：</p>

<pre><code class="language-bash">&gt; convert -list delegate | grep -Ee 'svg(:decode)? ='
        svg =&gt;          "rsvg-convert' -o '%o' '%i"
 svg:decode =&gt;          "inkscape' '%s' --export-png='%s' --export-dpi='%s' --export-background='%s' --export-background-opacity='%s' &gt; '%s' 2&gt;&amp;1"
</code></pre>

<blockquote>
  <p>注：内部委托与一般的（外部程序的）委托模式处理逻辑是一样的，只是在高版本的ImageMagick用<code>svg:decode</code>替代了<code>svg</code>这个入口而已。</p>
</blockquote>

<p>是的，你应该已经注意到了，这个内部的委托指向了inkscape。你可以安装inkscape来支持这个委托。例如：</p>

<pre><code class="language-bash">&gt; brew cask install xquartz inkscape
</code></pre>

<h3 id="">接管内部委托</h3>

<p>你也可以自己写个脚本来将操作转发到你的处理程序（类似于代理）。例如：</p>

<pre><code class="language-bash">#!/bin/bash
DPI="${3##*=}"  
rsvg-convert --format=png --output="${2##*=}" --dpi-x="${DPI%%,*}" --dpi-y="${DPI##*,}" --background-color="${4##*=}" "$1"  
</code></pre>

<p>将这个脚本另存到搜索路径中，并命名为<code>inkscape</code>，加上可执行权限。OK，你就看到<code>svg:decode</code>的相关调用转发到你的脚本中，并交给rsvg-convert处理了。</p>

<blockquote>
  <p>注意：如果内部委托调用出错（程序退出代码大于0），那么ImageMagick将再次调用MSVG来完成处理。</p>
</blockquote>

<p>当然，我们也可以把这个接管的脚本程序写得通用一点。比如将delegates.xml中的<code>svg:decode</code>项修改到一个统一的模式（以后就可以不用改了，不过sv要注意其中的<code>YOUR_SCRIPT_NAME</code>应该修改得与后面的脚本名一致）：</p>

<pre><code class="language-xml">&lt;delegate decode="svg:decode" command="&amp;quot;YOUR_SCRIPT_NAME&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;gt; &amp;quot;%s&amp;quot; 2&amp;gt;&amp;amp;1"/&gt;  
</code></pre>

<p>然后安装自己的工具（下面以cairosvg这个工具为例，首先安装它）：</p>

<pre><code class="language-bash"># @see: http://cairosvg.org/
&gt; pip3 install cairosvg
</code></pre>

<p>然后写调用脚本（<code>YOUR_SCRIPT_NAME</code>）：</p>

<pre><code class="language-bash">#!/bin/bash

# in arguments:
#    inFile outFile dpi bgColor bgOpacity
DPIX="${3%%,*}"  # format - xRes,yRes  
BGCOLOR="$4" # format - string, #xxxxxx, or rgb(r%,g%,b%)  
cairosvg -f png -o "$2" -d "$DPIX" "$1"  
</code></pre>

<p>最后将这个脚本另存、更名、更改可执行权限。</p>

<p>在你使用identify、convert等等工具处理svg时，都将调用上述脚本。所以，现在你可以随意用新的转换工具来替换MSVG了。</p>

<p>我的开源项目<a href="https://github.com/aimingoo/svg-provider">svg-provider</a>是一个较完整的实现，其主要是在参数的处理上面进行了优化，并且可以适配更多的转换工具。</p>]]></content:encoded></item><item><title><![CDATA[Kindle电子书中该用多大的图片]]></title><description><![CDATA[<blockquote>
  <p>注1：本文所涉及的工具，可以采用如下方法安装：</p>
</blockquote>

<pre><code class="language-bash"># 含identify,convert,mogrify,pdfinfo,pdftoppm等
&gt; brew install ghostscript imagemagick cpdf poppler
# 含pdfcrop等
&gt; brew cask install xquartz mactex inkscape
</code></pre>

<blockquote>
  <p>注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。</p>
</blockquote>

<p>如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。</p>

<p>在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。</p>

<p>你最好的选择是：使用一个阅读器不会对它进行缩放的、</p>]]></description><link>http://aimingoo.github.io/1-1726.html/</link><guid isPermaLink="false">5655d162-8a13-48e2-8125-387c794db87a</guid><category><![CDATA[电子书]]></category><category><![CDATA[Kindle]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sat, 03 Jun 2017 10:54:54 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>注1：本文所涉及的工具，可以采用如下方法安装：</p>
</blockquote>

<pre><code class="language-bash"># 含identify,convert,mogrify,pdfinfo,pdftoppm等
&gt; brew install ghostscript imagemagick cpdf poppler
# 含pdfcrop等
&gt; brew cask install xquartz mactex inkscape
</code></pre>

<blockquote>
  <p>注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。</p>
</blockquote>

<p>如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。</p>

<p>在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。</p>

<p>你最好的选择是：使用一个阅读器不会对它进行缩放的、确定大小的图片。</p>

<p>那么这样一张图片应该是多大呢？</p>

<h2 id="">阅读器有多大，图片就有多大</h2>

<p>答案如标题所说。只要你确切知道阅读器（的可阅读区）的大小，那么制作相同大小的图片就好了。不过对于Kindle——当然也可能包括别的电子书阅读器来说，这个大小要打个折扣。这是因为Kindle设定图片最大宽高度不得超过大约80%的可阅读区。一旦超过这个大小——该值其实是一个不确定的魔法数值，这在后面会更讲到——那么阅读器就会主动缩小这个图片。</p>

<p>Kindle发行过的一些阅读器的规格主要包括（相关数据<a href="http://socialcompare.com/en/comparison/amazon-kindle-product-line-comparison">在这里</a>，最新近的一些<a href="http://www.toptenreviews.com/mobile/ebook-readers/best-kindle-comparisons/">在这里</a>）：</p>

<style type="text/css">  
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-yw4l{vertical-align:top}
</style>  

<table class="tg">  
  <tr>
    <th class="tg-yw4l">分辨率</th>
    <th class="tg-yw4l">类型</th>
    <th class="tg-yw4l">Pixel Per Inch</th>
  </tr>
  <tr>
    <td class="tg-yw4l">1024x600</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">169/171 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1280x800</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">149/189/216/252 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1920x1200</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">254/323 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">2560x1600</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">339 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">800x600</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">167 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1024x758</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">212 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1200x824</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">150 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1448x1072</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">300 PPI</td>
  </tr>
</table>

<p>不仅如此，Kindle还发行过一系列平板的版本（当然使用的是LCD屏而不是电子墨水屏），这些屏幕的规格就更复杂了，例如官方公布的一些规格（<a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/specifications/01-device-and-feature-specifications">在这里</a>）。</p>

<p>综合上面的数据，从实用性的角度来说，我们应该制作宽度小于600*80%左右大小的图片。这条规则在大多数设备上都是适用的——关于这个问题其实是有过广泛的讨论的（例如<a href="https://www.epubble.com/kindle-maximum-image-size/">在这里</a>，以及amazon开发者信息<a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/app-development/01--screen-layout-and-resolution">在这里</a>）。但这个值不但与设备有关，甚至还与不同的Kindle版本有关，以至于有人发布出测试用的电子书，用来确定在不同设备上的适配图片大小（<a href="https://www.epubble.com/wp-content/download/KindleMaximumImageSize.prc">Kindle Maximum Image Size (PRC)</a> ）。</p>

<p>好吧，总之我们是只看结论的对不。那么，这个结论如下：</p>

<blockquote>
  <p>建议你将图片的大小控制在<code>520*622px</code>以内。</p>
</blockquote>

<p>也就是说，图片宽度在520px以内（<code>640*0.8125</code> or <code>600*.87</code>）。</p>

<h2 id="">如何做这样大小的图片</h2>

<p>下面我们来讲『如何做』。</p>

<h3 id="">什么是『这样大小』</h3>

<p>首先确定一下『这样大小』到底是怎样大。</p>

<p>因为我们所谓520px的图片，其实要从像素点换算成印刷用的厘米(cm)、英寸(in)或磅值(pt)，这些看起来麻烦的东西，通常是平面设计师的基本功。</p>

<p>在显示器上的所谓520px，实际含义是『在一个72ppi的设备上显示520pixel』（注3）。这里的PPI是『像素/英寸(Pixel Per Inch)』，这通常用在显示输出类的设备上；更经常的，你可能看到的是用Dots来表示Pixel，就是DPI了（注4）。一般情况下，这两种说法并不需要区分，都称作分辨率(Resolution ratio)、质量/精度/密度(quality/density)——具体到不同场合则是打印分辨率、显示分辨率、图片精度等等，<a href="http://www.uigreat.com/article/131">参见这里</a>）。</p>

<blockquote>
  <p>注3: 对于PPI，Windows系统默认为96， Mac OS系统默认PPI 为72。在使用Macbook Pro的Retina屏时，它的默认值是110。</p>
  
  <p>注4: 注意，我们说宽520px时实际上是在讲一张图片的"Pixel Dimensions（点阵面积）"中x方向的大小，而72dpi/ppi却是指获得（例如扫描设备）或输出（例如显示设备）这个点阵图时的精度。</p>
</blockquote>

<p>我们前面列出Kindel的设备参数时，设备的PPI是很复杂的，从149到339有非常多种；而它们显示具体图像的分辨率，也有800x600 .. 2560x1600等非常多种模式。不考虑其具体映射和实现的细节的话，你可以认为：</p>

<blockquote>
  <p>我们使用300DPI的图片，在多数设备上总是可行的。</p>
</blockquote>

<p>那么：一张<code>520x320px</code>大小的<code>300dpi</code>的图片，到底是怎样大小呢？</p>

<blockquote>
  <p>高度320px是上面所说到的622px的一半略多。这是因为我们在电子书上通常不会把一张图做到全屏大小，而使用以半屏高为上限的图片有利于书籍的自动排版。</p>
</blockquote>

<h3 id="">面积计算</h3>

<p>想知道这个大小，那么只需要在图形制作软件中新建一张图片，设置像素大小（即是Pixel Dimensions）为520x320px，然后设置分辨率为300DPI，就一切OK了——通常这种情况下我们不需要去手工计算。然而如果你在PowerPoint或Keynote里去做类似的事情，就会发现：.ppt中设置页面是使用厘米(cm)，而.key中却是使用磅（pt）。我们的难题之一，便是要做这个转换（以宽520px为例）：</p>

<ul>
<li>520/300*2.54 = 4.4026（厘米）
<ul><li>1英寸 = 2.54厘米</li></ul></li>
</ul>

<p>或者为了避免你总是手工计算，那么查看上面创建的图片的信息也可以（设图片名为test.png）：</p>

<blockquote>
  <p>注意：identify是ImageMagick中的一个工具，在使用<code>brew install imagemagick</code>安装后会同时得到这个命令行工具。</p>
</blockquote>

<pre><code class="language-bash">&gt; identify -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 118.11x118.11
  Print size: 4.40268 x 2.70934
  Units: PixelsPerCentimeter
</code></pre>

<p>注意identify对图片来说缺省单位是厘米（Centimeter），而不是习惯上PPI/DPI中所说的英寸（Inch），所以Resolution显示是118.11（DPCM，Dots Per Centimeter）。如果你想要显示为DPI，那么应该这样：</p>

<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 300x300
  Print size: 1.73333 x 1.06667
  Units: PixelsPerInch
</code></pre>

<h2 id="pptkeynote">在ppt或keynote上实作</h2>

<p>我们具体使用ppt/key的时候，其实会比上面的520x320px要略大一点，然后使用参考线来辅助作图。这是为了在ppt/key中具体画图时边界上留一点余量，便于操作。具体来说，我推荐的是使用：</p>

<ul>
<li>在.ppt中设置页面大小为<code>4.8x3.5</code>cm，或</li>
<li>在.key中设置页面大小为<code>136x99</code>pt</li>
</ul>

<p>接下来在PPT中设置两三条辅助线（以PPT为例，你可以下载这个模板<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.ppt">PPT格式</a>或<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.key">Keynote格式</a>）：</p>

<ul>
<li>右、左侧2.14cm各一条</li>
<li>右侧2.26cm一条</li>
</ul>

<p>如下图所示：</p>

<p><img src="http://aimingoo.github.io/content/images/2017/06/standard_image_templet_520.png" alt="standard_image_templet_520"></p>

<p>我们通常作图时让内容保持在正中间的<code>2.14*2</code>的范围内即可，当右侧使用到极限时会是<code>2.14+2.26cm</code>，亦即是全宽520px。同时，如果是4磅大小的文字，单行可以容纳30~31个（如图）。我建议采用4磅文字，其下限是3.5磅。</p>

<p>最后，当你在上面的页面上完成图、表之后，如果你使用PPT，那么可以直接在图形上鼠标右键，选『另存为图片』，然后选PDF（注4）；如果你使用Keynote，请在文件菜单中选『导出』，仍然也是选PDF。</p>

<blockquote>
  <p>强烈说明：注意这里要用PDF！</p>
</blockquote>

<p>接下来，你在Macbook中的『预览（Preview）』工具中打开上述PDF文件，再选导出到PNG，并设置分辨率为300 dpi。即可。</p>

<p>我们验证一下这样得到的一个.png的信息（注5）：</p>

<pre><code class="language-bash">&gt; identify -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 118.11x118.11  ## 如果使用-units PixelsPerInch，则这里为300DPI
  Print size: 4.51274x1.61714
  Units: PixelsPerCentimeter
</code></pre>

<blockquote>
  <p>注4: 我们后面将使用在PPT中选中图形导出的这个PDF（命名为ppt533.pdf），以及转换后的图片（ppt533.png）。稍后我们会讲述Keynote中的处理方法。此外，如果你在PPT绘制了很多东西，那么建议你先建个组(Group)再导出它们。</p>
  
  <p>注5: 你会注意到这个宽度不是预期的520px。这是因为PPT选中图形导出时会默认添加边框，所以如果你只使用模板中间的安全部分，那么上述方法总是安全的；否则你需要使用crop工具去切掉周边的空白区。关于这个部分的内容，我们在下面还会讲到。</p>
</blockquote>

<h3 id="pdfpng">理解PDF与PNG文件大小之间的关系</h3>

<p>为了讨论这个问题，我们再检查一下上面生成的PDF文件：</p>

<pre><code class="language-bash">&gt; identify -verbose ./ppt533.pdf | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 128x46+0+0
  Resolution: 72x72
  Print size: 1.77778x0.638889
  Units: Undefined
</code></pre>

<p>你会注意到PDF文件中<code>Units</code>值是没有的。这是PDF格式特殊的地方，事实上在它的文件格式中并没有包含Resolution、Print size和Units的信息——上面由identify得到的信息是计算出来的，而不是文件中的元数据信息。更具体地说，PDF是约定了默认使用72x72DPI的分辨率（所以Identify也直接在默认时使用了Inch作为单位，与图片的默认值不同），而且它是使用Points（磅值/点）来表明大小。那么显而易见的，上述的Print Size是简单地通过<code>128/72</code>就可以得来了——PDF默认采用72x72的DPI原因，也正在于磅值与英寸的换算关系就是<code>72:1</code>（关于这一点，请参见<a href="http://www.cnblogs.com/stronghorse/p/4913346.html">老马的文章</a>）。</p>

<p>所以现在你可以得到两个与大小相关的信息，一个是宽高信息(Pts)，也称为页面大小(Page Size)，另一个是可推算出来的打印面积(inch)。而在从PDF转换到PNG图片的过程中，通常就以这个转换后的打印面积来作为图片物理大小。</p>

<p>接下来我们来逆推一下一张300DPI的PNG图片该是怎样的。如果这张图片是如上的1.77778宽度，并且由于DPI设定是300，那么显然图片在x方向的点阵大小（pixels）应该就是<code>300*1.77778=533px</code>。具体来看上面这张通过『预览』工具导出的<code>ppt533.png</code>，它的信息就是这样：</p>

<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 300x300
  Print size: 1.77667x0.636667
  Units: PixelsPerInch
</code></pre>

<p>也就是说：在转换过程中，通常是保证<code>Print size</code>大小不变。</p>

<h3 id="ghostscriptdpi">在GhostScript中对DPI的一点不同理解</h3>

<p>如果你不想直接使用『预览』工具来导出，那么你可以为它建立一个automator任务或服务——这样就可以在命令行上使用了。或者，你也可以尝试使用GhostScript（也就是gs）这个命令行工具。</p>

<p>但是如果你使用GhostScript来将PDF转换成PNG，那么缺省情况下它是将Points直接对应地转换为Pixels的——也就是将PDF中的一个打印点，转换为图片中的一个像素点。因此假使你不使用设置分辨率的<code>-r</code>参数，那么你就将直接转换得到一个<code>128x46 pixels, 72DPI</code>的图片。</p>

<pre><code class="language-bash"># (下面这个结果显然不是你想要的)
&gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -sOutputFile=128px.png ppt533.pdf
</code></pre>

<p>更进一步，如果使用<code>-r 300</code>来指定300DPI输出，那么图片要有533 px的宽度（这个我们上面已经计算过了），而原始的PDF只有128 pts的宽度。所以这时，你将会得到一个低质量的、从128放大到533的图片。</p>

<p>如果你需要用gs来转换pdf到png，那么你应该先放大这个pdf到合适的宽高大小，然后再输出。下面是其中一种可能的方案：</p>

<pre><code class="language-bash"># 先放大300/72=4.1667倍
#    - 也可以使用另一个开源工具pdfScale
#    - 目的是使pts与我们要得到的图片pixels点数对应，以确保图片质量足够
&gt; cpdf -scale-page "4.1667 4.1667" -scale-to-fit-scale 4.1667 -o 300dpi.pdf ppt533.pdf
# 再转换得到300DPI的图片
&gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -r300 -sOutputFile=300dpi.png 300dpi.pdf
# 再reszie图片
#    - 转换成png时Page Size大小将保持不变，因此需要按72/300为比例换回去
&gt; convert 300dpi.png -resize 24% ppt533.png
</code></pre>

<p>现在我们再来看看这张图片：</p>

<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x192+0+0
  Resolution: 300x300
  Print size: 1.77667x0.64
  Units: PixelsPerInch
</code></pre>

<p>虽然这个过程是能得到符合我们要求的图片，但的确过于复杂。我们后面将介绍一些其它不使用GhostScript的方法。</p>

<h2 id="pdf">使用导出PDF文件的方法来得到图片的一些问题</h2>

<h3 id="1pdf">1) 成批导出与转换PDF文件</h3>

<p>如果总是在PowerPoint中将图形对象选中然后右键导出成PDF，那么在成批处理时就会比较繁琐；另外，在Keynote中根本就没有这个操作。所以事实上我们一般还是会将整个的PPT/Keynote文件另存、导出为.PDF文件。这样的文件称为多页PDF——很显然地，因为我们见到的大多数PDF文件都是多页的，并且它们的页面大小是一致的。</p>

<p>然而事实上我们要处理的每张PNG图片都可能大小不同，因为在PPT/Keynote中实际作图的有效区并不一样大。你可以选择将PDF从多页转换成一批单页，或者寻找能直接处理多页PDF的工具。——不幸的是，一些情况下后面这类工具并不太容易得到。</p>

<p>所以如果你真的需要先转换成单页PDF，那么我建议你使用pdfseparate这个工具，它包含在poppler这个工具包中。用法如下：</p>

<pre><code class="language-bash"># 第二个参数是文件名模板，必须包含'%d'来作页码的占位符
#    - 目标文件的目录必须先创建(例如本例中的extract)
&gt; mkdir ./extract
&gt; pdfseparate your.pdf './extract/page%d.pdf'
</code></pre>

<h3 id="2">2) 要切掉空白</h3>

<p>在转换到图片之前，我们还得先留意一下这个.pdf外围的空白区。</p>

<p>在上例中，如果你在Keynote中导出.pdf，或者在PowerPoint中导出页面（而不是选中图形导出），那么你将导出的是整个页。我们上面说过，为了制作方便，我们的整个页其实要略大一些，而只有参考线中间部分的图形是在电子书中有效的。</p>

<p>那么我们其实需要的是自动切掉图形外围的空白区(trim/crop)——在不同的软件中，可能是这两种功能之一。你可以选择处理最终生成的.png图片，这可以仍然使用上述ImageMagick套件中的convert（你安装之后在命令行中就有了），也可以早先做一步，对.pdf进行trim/crop操作。</p>

<p>这可以使用一个非常著名（而且名实相符）的软件，叫pdfcrop。它是perl脚本，可以你可以直接从官方下载（<a href="https://sourceforge.net/projects/pdfcrop/files/">例如这里</a>），或者安装一个TeX套件包内含（使用<code>brew cask install mactex</code>）。使用起来也很简单：</p>

<pre><code class="language-bash"># Usage: pdfcrop &lt;input[.pdf]&gt; [output file]
&gt; pdfcrop xxx-300dpi.pdf croped.pdf
</code></pre>

<p>如果省略output参数，则它以input文件名自动生成<code>-crop.pdf</code>后缀的文件。</p>

<p>另一个相对来说也很可靠的工具叫pdfCropMargins，它可选的参数也更多。比如：</p>

<pre><code class="language-bash"># pdfCropMargins可选使用Ghostscript或pdftoppm作为将pdf渲染为图片的工具
#  - 参数-gsr表明使用Ghostscript（缺省是pdftoppm）, 参数-gsp表明gs可执行文件的路径
#  - 参数-p/-p4来指定relative original margin模式的边距
#   * 可以用-a/-a4指定边距的absolute offset值
#   * 参数-ap/-ap4是在剪切前计算最终页面大小时使用的(p是指preCrop)
#   * 参数-m/-mp是用在uniform模式下指定边距，并隐式地打开该模式(或显式使用-u参数)
&gt; pdf-crop-margins -p 0 -gsr -gsp /usr/local/bin/gs -o croped.pdf your.pdf
</code></pre>

<p>pdfCropMargins与pdfcrop都有resolution参数：</p>

<ul>
<li>在pdfcrop中是<code>--resolution</code></li>
<li>在pdfCropMargins中则是<code>-x/-y</code>，或<code>--xRes/--yRes</code></li>
</ul>

<p>这个参数是用在将PDF渲染成图片时提高图片精度的。因为这两个工具实际上都是先将PDF渲染成图片，然后根据图片来查找margins的，所以提高这一精度就意味着查找margins更准确。但这个参数并不会影响转换后的PDF的质量。</p>

<p>其它：</p>

<ul>
<li>在pdfcrop中建议打开<code>--hires</code>以提高crop的质量，这种情况下margin计算更精确
<ul><li>在pdfCropMargins中的参数<code>-ap/-ap4</code>正好相反，较不精确但速度更快</li></ul></li>
<li>使用较低的resolution值速度更快，这与内部将pdf转为图片时的速度效率有关
<ul><li>pdfcrop缺省的resolution值为72dpi，而pdfCropMargins缺省为150dpi</li></ul></li>
<li>在pdfCropMargins中缺省使用的pdftoppm会比gs引擎要慢一点</li>
<li>在pdfcrop中指定TeX引擎为<code>--xetex</code>时，crop运算的效果常常会出错</li>
</ul>

<h3 id="3pdfpng">3) PDF转换到PNG图片时的工具选择</h3>

<p>无论PDF是否经过crop，你最终都只是想得到图片，所以这最后一步尤其重要。</p>

<p>切记要给转换软件指定300dpi的输出精度——如上所述，我们是按这个精度来设计的图片大小。除了『预览』这个软件之外，能指定转换精度的软件看起来不少，但大多数并不合用（注意gs是可用的，但并不方便，这在之前我们已经专门讲过了）。例如下面这几个：</p>

<pre><code class="language-bash"># 使用inkscape
#   - 只能处理单页pdf，可能会因字体不匹配而出现字体异常；效果好于gs，且能将dpi置为300
&gt; inkscape --without-gui --export-dpi=300 --export-png='300dpi.png' croped-p1.pdf

# 使用ImageMagick中的convert
#   - convert的density用于指定源pdf为300dpi, 而输出的png其实总是72dpi
#   - 只能处理单页pdf，但视觉效果好于gs(也好于gs的DEVICE=pnggray)
&gt; convert -density 300 croped-p1.pdf -background white -flatten 'error-dpi.png'

# 使用pdf2png
#    - Github: https://github.com/kaorukobo/pdf2png-mac
#    - 能逐页处理，但输出png的精度受xcode中的组件影响(缺省是144dpi)
#    - 参数--dpi是用于指定源pdf的dpi值的
&gt; pdf2png --dpi 300 --page 1 --output '144dpi.png' croped.pdf
</code></pre>

<p>事实上所有这类软件都是将源PDF理解为72dpi，所以针对源来指定的Resolution值其实是用于建立一个缩放工厂（scaleFactor），以便得到等同于指定DPI大小的图像。而不同的软件的区别仅在于是否能在输出PNG时，有效的指定png图片的dpi——例如pdf2png是基于xcode的NSMakeRect()，而该组件默认精度在retina screens上就是144dpi。</p>

<p>所以请仔细review这个过程，其实完全等同于『在GhostScript中对DPI的一点不同理解』小节中所讲述的：1. 先放大PDF；2. 渲染成PNG到指定精度；3. 缩小PNG到指定大小。</p>

<h3 id="4">4) 一步到位</h3>

<p>如果你希望一步到位地解决上述问题，那么我目前只有一个工具推荐：</p>

<blockquote>
  <p>注：nconvert是<strong>xnview</strong>提供的一个非商用免费工具，<a href="http://www.xnview.com/en/nconvert/">下载在这里</a></p>
</blockquote>

<pre><code class="language-bash"># 用ncovert将croped.pdf转换到png
&gt; nconvert -xall -dpi 300 -out png -o pic croped.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
Conversion of croped.pdf into pic-1.png OK  
Conversion of croped.pdf into pic-2.png OK  
...

# 或者不对original.pdf做crop操作，而是直接在nconvert中转换并autocrop图像
#    - autocrop参数格式为"tol r g b"，其中tol是容错值，rgb为crop掉的颜色
&gt; nconvert -xall -dpi 300 -out png -o pic -autocrop 0 255 255 255 original.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
...
</code></pre>

<p>所以，本文中的模板所导出的PDF(<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.pdf">在这里</a>)转换成png所采用的方法就是如下：</p>

<pre><code class="language-bash"># 在PowerPoint/Keynote中将ppt导出成.pdf，然后
#    - nconvert是从0页开始对pdf计数的
&gt; nconvert -page 0 -dpi 300 -out png -autocrop 0 255 255 255 standard_image_templet_520.pdf 1&gt;/dev/null
Conversion of standard_image_templet_520.pdf into standard_image_templet_520.png OK

# 查看png文件的信息(现在就真的是520px宽+300DPI了)
&gt; identify -units PixelsPerInch -verbose standard_image_templet_520.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 520x306+0+0
  Resolution: 300x300
  Print size: 1.73333x1.02
  Units: PixelsPerInch
</code></pre>

<p>最后需要补充一点：就效果来说，基于图像autocrop与pdfcrop并没有太大的差别——反正我是分不出来。另外，你也可能想尝试使用imagemagick中的trim操作来替代autocrop：</p>

<pre><code class="language-bash"># 使用nconvert但不autocrop
&gt; nconvert -xall -dpi 300 -out png -o pic original.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
...

# 使用imagemagick中的mogrify工具, -fuzz 0%与autocrop中的tol参数类似
&gt; find . -name 'pic-*.png' | xargs -n1 mogrify -fuzz 0% -trim +repage
</code></pre>]]></content:encoded></item><item><title><![CDATA[手记6：改造Gitment]]></title><description><![CDATA[<blockquote>
  <p>本文所述的修改请参考我Fork的Gitment项目：<a href="https://github.com/aimingoo/gitment">Giment at aimingoo's project space</a></p>
</blockquote>

<p>接下来我们要大力修改Gitment，打造一个『好用那么一点点儿』的博客评论。</p>

<h2 id="11gitment">11. 改造Gitment</h2>

<p>折腾到现在，我们有了一个在Github pages上的博客，以及一个用来写本地博客的Ghost，以及一些相关的工具，例如<code>makesite.sh</code>（<a href="https://github.com/aimingoo/ghost-utils">在这里</a>）。</p>

<p>最后，我们还有了一个第三方提供的支持PHP+HTTPs的空间，这个空间只用来放Gitment的服务端，并且这个服务器事实上也只做一下API的CORS转发而已。</p>

<blockquote>
  <p>注：你可能已经留意到我并没有告诉大家『到底哪个免费主页空间支持PHP+HTTPS』啊。是的，我刻意隐藏了这个信息，以免文章公开后导致滥用。我最终使用的这个主页空间……老实说，是相当相当不错的了，能给的人家都给了。所以真不忍心被那些挂马的搞死。所以能藏着就藏着吧，如果你想要申请它的话，你直接在我的网站的源码中去找找就好了。</p>
</blockquote>

<p>所以接下来，我开始改造Gitment，再一次强调，Gitment真正是个相当NB的项目。我fork了一个版本出来，修改版的在这里：<a href="https://github.com/aimingoo/gitment">Giment updates</a></p>]]></description><link>http://aimingoo.github.io/1-1725.html/</link><guid isPermaLink="false">eaab0e82-64c5-4cbb-a31d-64ae617b936b</guid><category><![CDATA[博客]]></category><category><![CDATA[Gitment]]></category><category><![CDATA[Javascript]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Github]]></category><category><![CDATA[前端开发]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 31 May 2017 16:46:14 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>本文所述的修改请参考我Fork的Gitment项目：<a href="https://github.com/aimingoo/gitment">Giment at aimingoo's project space</a></p>
</blockquote>

<p>接下来我们要大力修改Gitment，打造一个『好用那么一点点儿』的博客评论。</p>

<h2 id="11gitment">11. 改造Gitment</h2>

<p>折腾到现在，我们有了一个在Github pages上的博客，以及一个用来写本地博客的Ghost，以及一些相关的工具，例如<code>makesite.sh</code>（<a href="https://github.com/aimingoo/ghost-utils">在这里</a>）。</p>

<p>最后，我们还有了一个第三方提供的支持PHP+HTTPs的空间，这个空间只用来放Gitment的服务端，并且这个服务器事实上也只做一下API的CORS转发而已。</p>

<blockquote>
  <p>注：你可能已经留意到我并没有告诉大家『到底哪个免费主页空间支持PHP+HTTPS』啊。是的，我刻意隐藏了这个信息，以免文章公开后导致滥用。我最终使用的这个主页空间……老实说，是相当相当不错的了，能给的人家都给了。所以真不忍心被那些挂马的搞死。所以能藏着就藏着吧，如果你想要申请它的话，你直接在我的网站的源码中去找找就好了。</p>
</blockquote>

<p>所以接下来，我开始改造Gitment，再一次强调，Gitment真正是个相当NB的项目。我fork了一个版本出来，修改版的在这里：<a href="https://github.com/aimingoo/gitment">Giment updates by aimingoo</a></p>

<h3 id="111httphttpsgithubpages">11.1 更有效地支持HTTP/HTTPS的Github Pages</h3>

<p>我们前面说过Github pages也分别支持HTTP和HTTPS两种协议，如果你有幸得到一个HTTP的Github pages site——真的很有幸了，得是以前创建的仓库，新仓库已经没有这个选择了——那么，你仍然可以将intersect（<a href="https://github.com/aimingoo/intersect">在这里</a>）部署在一个仅支持HTTP的Web站点上。</p>

<p>也就是说，只能选择Github pages和intersect同时支持HTTPS，或者反过来选择同时不支持。有趣的是，在Github pages使用HTTP的情况下，Github<strong>同时</strong>也允许访问者通过HTTPS协议来访问你的主页。这样一来就带来了一个问题：在你的Github oAuth Application后台配置中，你只能设置一个callback地址。</p>

<p>所以我在Gitment中加了一个名为<code>force_redirect_protocol</code>的选择，它会在调用</p>

<blockquote>
  <p><a href="https://github.com/login/oauth/authorize">https://github.com/login/oauth/authorize</a></p>
</blockquote>

<p>时强制redirect_uri参数使用与Github oAuth Application后台配置一致的值，这样才能在HTTPS/HTTP网站上同时通过authorize验证，并且最后总是使用redirect_uri所设置的协议下的地址。</p>

<pre><code class="language-javascript">// Update (Getment Proj)/src/gitment.js

// Github setting of 'Authorization callback URL' in your OAuth application
const force_redirect_protocol = 'https'  
...

class Gitment {  
  ...
  get loginLink() {
    const oauthUri = 'https://github.com/login/oauth/authorize'
    const redirect_uri = this.oauth.redirect_uri || window.location.href.replace(/^https?/i, force_redirect_protocol);
    ...
</code></pre>

<h3 id="112gitmentintersect">11.2 使Gitment支持intersect</h3>

<p>intersect这个PHP项目（<a href="https://github.com/aimingoo/intersect">在这里</a>）并没有完全地实现API Geteway特性。比如说，当它转发一个POST请求时，如果你需要添加新的数据到Request，那么就需要根据POST data的不同类型（Content-Type）来决定如何修改：在JSON中添加一个字段，或在不同的encode data中添加一个数据等等；并且还要正确的修改Content-Length。</p>

<p>所以考虑到简单，intersect只支持在GET请求中，或在使用form-urlencoded协议的POST请求中添加数据。例如我们要追加client_secret这个参数并传送到后端，那么就该选用POST协议。</p>

<p>考虑到Gitment实现XHR请求时的特殊性（它专门实现了一个ajaxFactory），我在修改Gitment项目时更要求：</p>

<blockquote>
  <p>如果使用POST方法，并强制要求使用form-urlencoded协议，那么应该在<code>http.post()</code>方法中传入字符串格式的data，而不能传入对象。</p>
</blockquote>

<p>接下来的实现就比较简单了（修改utils.js中的Ajax接口）：</p>

<pre><code class="language-javascript">// Update (Getment Proj)/src/utils.js, es6 syntax

function ajaxFactory(method) {  
  ...
  // 在accept头中加上form-urlencoded支持
  req.setRequestHeader('Accept', '..., application/x-www-form-urlencoded')

  // 在Response数据的解码中支持form-urlencoded
  req.addEventListener('load', () =&gt; {
    ...
    if (/urlencoded/.test(contentType)) {
       data = req.responseText ? Query.parse(res) : {}
       ...

  // 强制Requestr的POST协议对string data使用form-urlencoded
  if (method !== 'GET' &amp;&amp; method !== 'DELETE') {
    if (isString(data)) {
      body = data
      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    ...
</code></pre>

<p>第二步（修改Gitment.js）：</p>

<pre><code class="language-javascript">// Update (Getment Proj)/src/gitment.js, es6 syntax

class Gitment {  
  constructor(options = {}) {
    ...
    const { client_id, client_secret, proxy_gateway } = this.oauth

    ...
    var login = !proxy_gateway
      ? http.post('https://gh-oauth.imsun.net', {code, client_id, client_secret}, '')
      : http.post('/login/oauth/access_token', `code=${code}&amp;client_id=${client_id}`, proxy_gateway);

    login.then(data =&gt; {
      this.accessToken = data.access_token
      ...
</code></pre>

<p>第三步（Gitment创建时Options）：</p>

<pre><code class="language-javascript">// 现在在Gitment创建时的Options中就可以使用proxy_gateway选项了
//    - 保持了与旧的client_secert的兼容，二选一配置即可
const gitment = new Gitment({  
  id: 'Your page ID', // optional
  owner: 'Your GitHub ID',
  repo: 'The repo to store comments',
  oauth: {
    client_id: 'Your client ID',
    proxy_gateway: 'https://your_intersect_gateway'
    // client_secret: 'Your client secret, either this or proxy_gateway',
  },
  // ...
  // For more available options, check out the documentation below
})
</code></pre>

<h3 id="113">11.3 多语言支持</h3>

<p>Gitment的作者没有提供多语言支持是觉得『不必要』，因为Github的用户要是这几个单词也不认得大概就只能回家卖烤红薯了。但我的问题在于，我打算做一个多人博客，所以博客的读者还真有不少与Github无关。</p>

<p>所以，我得需要一个多语言支持。</p>

<p>简单的做法，就是写一个这样的translator：</p>

<pre><code class="language-javascript">// save as (Getment Proj)/src/translator.js
export function english(Text) {  
    return Text;
}

export function chinese(Text) {  
    return ({
        'Issue Page': '所有评论',
        'Initialize Comments': '初始化本文的评论页',
        ...
    }[Text]||Text);
}

export default english;  
</code></pre>

<p>这里用的都是ES6的语法。这几个简单的export说明当前模块导出了<code>english/chinese</code>等等名字，是用来作为提供多语言支持的翻译函数——在不同语言的函数中添加对照表来支持更多的内容。</p>

<p>使用的时候也挺简单的，在Gitment的<code>src/theme/default.js</code>模块中将它装载进来：</p>

<pre><code class="language-javascript">// 注：如果使用英文(不翻译)，那么以下两种导入方法是等效的
//    import { english as $ } from '../translator'
//  import $ from '../translator'
import { chinese as $ } from '../translator'  
...
</code></pre>

<p>然后在需要多语言的地方使用下面的代码即可：</p>

<pre><code class="language-javascript">// 例如，原始代码
//    issueLink.innerText = 'Issue Page'
// 改成：
issueLink.innerText = $('Issue Page')  
</code></pre>

<p>一处处地找到，改完就Ok啦。</p>

<blockquote>
  <p>注意：Gitment使用了ES6的语法，所以有些地方是用ES6的模板字符串的，这些地方要使用类似${$('english text')} 这样的方法来转换。</p>
</blockquote>]]></content:encoded></item><item><title><![CDATA[博客迁移手记之快速导航]]></title><description><![CDATA[<p>本来没想把《博客迁移手记》写得这么长这么多，所以写了这么久之后再来看，博客的标题感觉就很Low了。</p>

<p>于是决定给这一组《博客迁移手记（1~n）》写个导航，也算整理一下思路。</p>

<h2 id="">快速导航</h2>

<p>博客迁移手记（一）</p>

<ul>
<li>使用BlogToWordpress迁移你的博客</li>
<li>使用本地博客Ghost的快速指南与导入工具</li>
</ul>

<p>博客迁移手记（二）</p>

<ul>
<li>从本地博客到Github Pages的最佳指南</li>
<li>makesite.sh使用手册</li>
</ul>

<p>博客迁移手记（三）</p>

<ul>
<li>以kaldorei为例详解Ghost Theme的定制</li>
<li>Ghost中文章置顶的实现方法</li>
<li>如何最大程度地静态化Ghost博客</li>
</ul>

<p>博客迁移手记（四）</p>

<ul>
<li>Gitment大坑：谈谈secret泄露的前因后果</li>
</ul>

<p>博客迁移手记（五）</p>

<ul>
<li>如何获得一个支持HTTPS的免费空间</li>
</ul>

<p>博客迁移手记（六）</p>

<ul>
<li>用intersect来做Gitment的API网关</li>
<li>Gitment的一些Bug修复与补强</li>
<li>Gitment的简单多语言支持</li>
</ul>

<h2 id="">其它：</h2>

<blockquote>
  <ul>
  <li><p>我最终改掉了这组博客文章的标题。</p></li>
  <li><p>这充分说明使用短标题是正确的。</p></li>
  </ul>
</blockquote>]]></description><link>http://aimingoo.github.io/1-1724.html/</link><guid isPermaLink="false">b9502886-b86f-4f2e-b8c1-ee5f4a67f92e</guid><category><![CDATA[博客]]></category><category><![CDATA[Gitment]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 30 May 2017 07:48:53 GMT</pubDate><content:encoded><![CDATA[<p>本来没想把《博客迁移手记》写得这么长这么多，所以写了这么久之后再来看，博客的标题感觉就很Low了。</p>

<p>于是决定给这一组《博客迁移手记（1~n）》写个导航，也算整理一下思路。</p>

<h2 id="">快速导航</h2>

<p>博客迁移手记（一）</p>

<ul>
<li>使用BlogToWordpress迁移你的博客</li>
<li>使用本地博客Ghost的快速指南与导入工具</li>
</ul>

<p>博客迁移手记（二）</p>

<ul>
<li>从本地博客到Github Pages的最佳指南</li>
<li>makesite.sh使用手册</li>
</ul>

<p>博客迁移手记（三）</p>

<ul>
<li>以kaldorei为例详解Ghost Theme的定制</li>
<li>Ghost中文章置顶的实现方法</li>
<li>如何最大程度地静态化Ghost博客</li>
</ul>

<p>博客迁移手记（四）</p>

<ul>
<li>Gitment大坑：谈谈secret泄露的前因后果</li>
</ul>

<p>博客迁移手记（五）</p>

<ul>
<li>如何获得一个支持HTTPS的免费空间</li>
</ul>

<p>博客迁移手记（六）</p>

<ul>
<li>用intersect来做Gitment的API网关</li>
<li>Gitment的一些Bug修复与补强</li>
<li>Gitment的简单多语言支持</li>
</ul>

<h2 id="">其它：</h2>

<blockquote>
  <ul>
  <li><p>我最终改掉了这组博客文章的标题。</p></li>
  <li><p>这充分说明使用短标题是正确的。</p></li>
  </ul>
</blockquote>]]></content:encoded></item><item><title><![CDATA[手记5：如何获得一个支持HTTPS的免费空间]]></title><description><![CDATA[<p>下面我们讲的内容其实与Gitment没什么关系。如果你已经有了支持https的空间那就跳过去，如果没有的话，建议还是看看好的伐。</p>

<h2 id="10https">10. 让免费主页空间支持HTTPS</h2>

<blockquote>
  <p>好象我们把问题搞得复杂了：本来我是想做个静态主页的博客网站，现在我却需要找个支持PHP+SSL的动态主页空间？</p>
  
  <p>好吧。没关系。反正我闲着在养病，不做点啥岂不是辜负了时光。</p>
</blockquote>

<p>免费主页空间其实挺好找的，尽管要找到一个有长期信誉的并不太容易。即使如此，当你得到这样一个免费空间之后，它多数也是不支持https的。</p>

<h3 id="101https">10.1 你的主页空间是不是支持HTTPS？</h3>

<p>好吧，确实有很多免费空间『声称』它支持https了。这种情况下它通常会给你用通用工具生成一个自主颁发的ssl凭证——而这个凭证是不受主流浏览器信任的。也就是说，在访问这样的一个网站时，你的浏览器地址栏会是这样：</p>

<blockquote>
  <p>（我很好奇为什么12306到现在仍然是这样，难道他们也得不到一个有效的ssl凭证吗？）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/browser_12306_cn.png" alt="browser_12306_cn"></p>

<p>免费主页空间缺省情况下给你颁发的就是这样一种自主签名的SSL（能通过验证，却不被浏览器环境信任），又或者你的空间根本还不支持ssl/https。这个需要你到主页空间的后台去找一个名为SSL的管理功能，通常它会列举三个信息：</p>

<ul>
<li>Private Key，私钥，它通常与下面的CSR是成对的。
<ul><li>CSR，证书验证请求（Cerificate Signing Request）。</li></ul></li>
<li>Certificate，</li></ul>]]></description><link>http://aimingoo.github.io/1-1723.html/</link><guid isPermaLink="false">fa7313be-e458-4280-8739-ab40307afcd0</guid><category><![CDATA[博客]]></category><category><![CDATA[SSL]]></category><category><![CDATA[HTTPS]]></category><category><![CDATA[免费空间]]></category><category><![CDATA[证书]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 30 May 2017 07:25:00 GMT</pubDate><content:encoded><![CDATA[<p>下面我们讲的内容其实与Gitment没什么关系。如果你已经有了支持https的空间那就跳过去，如果没有的话，建议还是看看好的伐。</p>

<h2 id="10https">10. 让免费主页空间支持HTTPS</h2>

<blockquote>
  <p>好象我们把问题搞得复杂了：本来我是想做个静态主页的博客网站，现在我却需要找个支持PHP+SSL的动态主页空间？</p>
  
  <p>好吧。没关系。反正我闲着在养病，不做点啥岂不是辜负了时光。</p>
</blockquote>

<p>免费主页空间其实挺好找的，尽管要找到一个有长期信誉的并不太容易。即使如此，当你得到这样一个免费空间之后，它多数也是不支持https的。</p>

<h3 id="101https">10.1 你的主页空间是不是支持HTTPS？</h3>

<p>好吧，确实有很多免费空间『声称』它支持https了。这种情况下它通常会给你用通用工具生成一个自主颁发的ssl凭证——而这个凭证是不受主流浏览器信任的。也就是说，在访问这样的一个网站时，你的浏览器地址栏会是这样：</p>

<blockquote>
  <p>（我很好奇为什么12306到现在仍然是这样，难道他们也得不到一个有效的ssl凭证吗？）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/browser_12306_cn.png" alt="browser_12306_cn"></p>

<p>免费主页空间缺省情况下给你颁发的就是这样一种自主签名的SSL（能通过验证，却不被浏览器环境信任），又或者你的空间根本还不支持ssl/https。这个需要你到主页空间的后台去找一个名为SSL的管理功能，通常它会列举三个信息：</p>

<ul>
<li>Private Key，私钥，它通常与下面的CSR是成对的。
<ul><li>CSR，证书验证请求（Cerificate Signing Request）。</li></ul></li>
<li>Certificate，验证信息。</li>
</ul>

<p>简单的逻辑是：</p>

<ul>
<li>假设你先有了一个私钥（Private Key），然后</li>
<li>你用私钥对一些『要验证的信息』加密，生成了一个验证请求（CSR），最后</li>
<li>你要找一个有公信力的机构来证明CSR是你的；如果验证通过他就给你发一份Certificate。</li>
</ul>

<p>你最后从『公信力机构』拿到的这个Certificate就是SSL凭证。——找到你的免费空间后台管理中的Certificate填进去，OK，你的网站就支持<code>https</code>了。</p>

<blockquote>
  <p>当然这其中还有很多的细节，比如免费空间服务商怎么把你的Certificate装到Web服务器上面去等等等等。不过除非你是要搞台云主机自己来架服务器，这些就先不要了解了吧。</p>
</blockquote>

<h3 id="102certificate">10.2 两种获得Certificate的方法</h3>

<p>这三个信息有两种方式来获得。</p>

<ul>
<li>一种是你的免费空间提供商为你生成Private Key/CSR这一对信息，然后你将其中的CSR提交给『公信力机构』，后者给你发Certificate文本。</li>
</ul>

<p>所以这种情况下你看到免费空间后台管理的SSL配置中会有一个『Generate Key/CSR』按钮，按一下就得到了前面信息了——如果只能填入而不能Generate，那么你也可以自己做，例如在MacOSX中的工具keytool或OpenSSL（<a href="https://faq.xiaoz.me/archives/100.html">参考这里</a>，或<a href="https://onlinehelp.tableau.com/current/server/zh-cn/ssl_cert_create.htm">这里</a>）。与之对应的，在『公信力机构』的证书申请流程中会有一个类似这样的提示：</p>

<p><img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-provide_your_csr.png" alt="ssl_step-provide_your_csr"></p>

<ul>
<li>另一种是『公信力机构』一次性地为你把上述三步全做了——他不需要你提供CSR，而是为你生成一个Private Key，然后自己生成CSR、完成验证并最后把Private Key交还给你。例如阿里云为你提供的验证服务就是这样（它后台用的是Symantec的免费DV服务）。这种情况下，你就需要将其中的Private Key交给免费空间提供商了——所以你的免费空间后台管理的SSL配置中，通常在『Generate Key/CSR』按钮旁边，就还会有一个『Upload Key』的功能，这个Key，指的就是Private Key。</li>
</ul>

<p>好了。简单地汇总一下上面的信息：</p>

<ol>
<li>找一个『公信力机构』，让他证明你的网站是你的；  </li>
<li>如果他要CSR，你就给他；如果他不要CSR，那么他应该给你Private Key。</li>
</ol>

<p>当然，如果你的主页空间不给你提供ssl功能（没有地方让你提交『公信力机构』验证过的Certificate），那么——换一家吧。</p>

<h3 id="103">10.3 怎么证明『你的网站是你的』</h3>

<p>所谓的『公信力机构』要颁发SSL签证，其实是想说明『因为这个网站你是你的，所以我发了这个证明给你』。因此无论如何，这个机构也要有办法来证明『你的网站是你的』，而不仅仅是因为你提交了CSR申请。</p>

<p>所以一旦你申请了，那么你就要为接下来的验证工作做准备，而这取决于不同的『公信力机构』采用的验证方法。下面举三种例子。</p>

<h4 id="1031symantec">10.3.1 阿里云或Symantec的签证</h4>

<p>阿里云可以为你的网站提供1年的免费SSL签证，它的这项服务是通过Symantec签证机构来做的（所以腾讯云也是这样）。所以下面其实是在说Symantec的签证要求。</p>

<p>阿里云是允许你通过修改DNS或在指定的主页位置放一个名为<code>fileauth.txt</code>的文本文件（一个详细的过程可以<a href="https://yfdxs.com/ali-ssl-amh.html">看过里</a>，如果你能修改DNS的CNAME配置那么<a href="https://www.xiaoz.me/archives/7442">看这里</a>）。这样，你就必须要：</p>

<ol>
<li>有这个网站（或主页）的ftp账号；并且，  </li>
<li>可以创建名为<code>.well-known</code>这样以点字符开始的目录名（基于Windows系统的主机不能创建这样的名称）；并且，  </li>
<li>可以确保能通过<code>http://your-domain-name/.well-know/...</code>这样的url路径下载到上述文本文件（注意：如果你的网站已经开通了https，那么它会优先访问https开头的地址）。</li>
</ol>

<p>问题往往出在第3步。这是因为Symantec会优先去https开头的地址下载验证文件，而一般会提供ssl的主机/免费空间都会默认的给你装一个『自主签名的SSL证书』，这个证书事实上会被认为是无效的——因此Symantec就会验证不通过。</p>

<p>这种情况下你可以曲线救国：先去找别的机构签一个短期一些（通常是3个月）的证书，让这个https地址生效了，然后再回头过验证Symantec的签证（话说，我就是这么干的）。</p>

<p>不过，有些时候事情并不那么美妙，因为即使你的主页空间『信誓旦旦』地说他们开放了SSL，并且无论如何你都把文件传到了正确的地方，甚至你看起来也的确可以通过https/http来访问到上述的<code>fileauth.txt</code>文件的URL地址，但是——你就是通不过Symantec（或者阿里云、腾讯云等等）的验证——它们找不到上面的这个文件。</p>

<blockquote>
  <p>注意：我就是因为这个问题申请了又放弃了近二十个免费主页空间。相信我，如果你逐一去试，不会好到哪里去的。</p>
</blockquote>

<p>问题出在哪儿呢？</p>

<p>这是因为非常非常多的『免费主页』本质上都是要在你的主页上挂广告才能活下去的，他们挂广告的方法真的很纷纷多啊。其中一种常用的，就是串改你的url地址，它会把浏览器访问到的url改成带广告代码的，然后自己搞点弹窗啊什么的，最后才重定向到你真实的地址。——这个过程浏览器认得，而『公信力机构』的验证程序可认不得啊，后者在读取验证文件的时候并不支持为浏览器准备的重定向！</p>

<p>所以，一旦你申请到一个主页空间，先用curl去访问一下，如果是下面这种返回：</p>

<pre><code class="language-bash">&gt; curl 'http://your-domain-name/'
&lt;html&gt;  
&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;  
...
</code></pre>

<p>好吧，它的意思是说不支持curl这样的直接访问，一般来说就不能用了。不过如果你不死心，可以再试试伪装成浏览器：</p>

<pre><code class="language-bash">&gt; curl -H 'User-Agent:Mozilla/5.0' 'http://your-domain-name/'
&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript" ...  
</code></pre>

<p>那么你就真的不用想了：上面的就是挂广告的代码了，你还想什么呢。</p>

<p>所以你看，我申请了很多又很多个免费空间，都作废了。</p>

<h4 id="1032instantssl">10.3.2 试试别的验证方法，例如instantssl的</h4>

<p>这家『公信力机构』也非常棒，他提供3个月免费的签证。我们上面说过，你可以尝试『曲线救国』，或者干脆就每三个月签一回，都行。</p>

<p>重要的是，instantssl采用的是邮件验证，而不是验证ftp文件。</p>

<p>instantssl是科摩多（comodo）提供的一项SSL证书发放服务，所以你用<a href="http://www.comodo.cn/">comodo.cn</a>或<a href="http://www.instantssl.cn/">instantssl.cn</a>访问都是可以的。他要求你提供自己准备的CSR，之后会提示你会把证书邮寄给你的网站的admin邮箱账号。</p>

<p>所以，这就要求你的主页空间给你开通邮箱服务，并且你能自定义类似<code>admin@yourname.freespace.xyz</code>这样的邮箱名——这个instantssl可以让你选，不过总的来说就那几种特定的。</p>

<p>很好，如果你有这样的免费空间，或者你就是能得到这样的邮箱，那么试试instantssl的吧。我知道<a href="http://infinityfree.net">infinityfree</a>免费空间提供这样的邮箱服务，比如我其实申请了一个<code>.epizy.com</code>的二级域名。但很不幸我没有通过instantssl的验证——它提示我相应名字的签证已经发过了。</p>

<p>不知道为什么。反正，你也许可以试试。</p>

<h4 id="1033">10.3.3 还有一些别的不错的签证机构</h4>

<p>有个非常非常著名的、推动https的签证组织，叫<code>Let’s Encrypt</code>。这个签证非常好用，所以也常常有自己做虚拟主机的来用它（<a href="https://www.freehao123.com/lets-encrypt/">https://www.freehao123.com/lets-encrypt/</a>），很多介绍中也首推就是它（<a href="https://www.freehao123.com/top-8-free-ssl-cert/">例如这里</a>）。</p>

<p>然而它对web域名签证并不友好，所以就有人搞了网站来做这件事，最好用的就是这家了：<a href="https://www.sslforfree.com/">https://www.sslforfree.com/</a>，它发的也是3个月的免费签证。你可以先看看这个教学<a href="https://changken.biz/969">SSLforFree 免费SSL凭证</a>。</p>

<p>SSLforFree的验证过程与阿里云/Symantec的类似，也是要求你传一个文件到ftp上（或者改DNS CNAME），不过他不验证https，所以多数『提供了无效的https的免费空间』来说也能很好的通过验证——除了我上面说的挂广告代码的那种情况。</p>

<p>也许还有其它好的，有知道的不妨推荐给我。</p>

<h3 id="104">10.4 安装你得到的凭证</h3>

<p>『公信力机构』最终给你的是名为Certificate的凭证。并且，</p>

<ul>
<li>如果是他帮你生成的CSR，那么他会给你Private Key；</li>
<li>一般来说他会给你一个它作为签证机构的公钥，不过由于使用者（例如你的主页空间服务商）能直接从网站上搜到这个公钥，所以没有给你也是正常的。</li>
</ul>

<p>你需要在后台把Certificate凭证和Private Key给上传(Upload)或更新(Update)到你的管理后台——如果它有类似『SSL管理』这样的功能的话。例如：</p>

<blockquote>
  <p>（第1步先上传你的证书）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-update_ssl.png" alt="ssl_step-update_ssl"></p>

<blockquote>
  <p>（然后点下面的『管理SSL站点』）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-update_site-1.png" alt="ssl_step-update_site"></p>]]></content:encoded></item><item><title><![CDATA[手记4：谈谈Gitment中泄露secret的前因后果与解决方法]]></title><description><![CDATA[<p>本来我接下来只是想在博客中加上一个支持评论的功能（使用Gitment），然而诸多的尝试之后，我却发现我需要创建一个支持https的web站点……</p>

<p>这一切的目的，只是使得我们的Gitment有跨域访问的Api接口可用。</p>

<h2 id="8">8. 问题出在哪里</h2>

<p>Gitment（<a href="https://github.com/imsun/gitment">项目</a>）是极棒的一个利用Github Issues来实现博客评论功能的项目，作者（<a href="https://imsun.net/">https://imsun.net/</a>）在介绍中特别提到，这种对Issues功能的使用方法是Github团队支持许可的。这也意味着只要你能接受以下两点可能存在的限制/隐患，你就可以长期地使用它：</p>

<ul>
<li>Github真的可能被屏蔽，尽管这种可能性已经越来越小</li>
<li>要发表评论的话必须先注册Github的账号，不过浏览评论是不受限制的</li>
</ul>

<p>但是使用Gitment是有问题的。更准确地说，如果你直接在你的博客中部署Gitment这个项目，那么你将面临你的Github application client secret token丢失的风险。这个风险会带来两种可能，一种是你自己的Github账户下的application被假冒，另一种是在你的博客上发表评论的Github用户被冒名。</p>

<p>这个风险看起来很大。而这对于Gitment来说又难于避免，因为它要求你在使用时往博客模板中插入以下代码：</p>

<pre><code class="language-javascript">var gitment = new Gitment({  
  id: '页面 ID', // 可选。默认为 location.href</code></pre>]]></description><link>http://aimingoo.github.io/1-1722.html/</link><guid isPermaLink="false">bfa19ad7-3e78-4560-a7ff-f79104c7dd8d</guid><category><![CDATA[博客]]></category><category><![CDATA[Javascript]]></category><category><![CDATA[Github]]></category><category><![CDATA[Gitment]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 28 May 2017 18:17:49 GMT</pubDate><content:encoded><![CDATA[<p>本来我接下来只是想在博客中加上一个支持评论的功能（使用Gitment），然而诸多的尝试之后，我却发现我需要创建一个支持https的web站点……</p>

<p>这一切的目的，只是使得我们的Gitment有跨域访问的Api接口可用。</p>

<h2 id="8">8. 问题出在哪里</h2>

<p>Gitment（<a href="https://github.com/imsun/gitment">项目</a>）是极棒的一个利用Github Issues来实现博客评论功能的项目，作者（<a href="https://imsun.net/">https://imsun.net/</a>）在介绍中特别提到，这种对Issues功能的使用方法是Github团队支持许可的。这也意味着只要你能接受以下两点可能存在的限制/隐患，你就可以长期地使用它：</p>

<ul>
<li>Github真的可能被屏蔽，尽管这种可能性已经越来越小</li>
<li>要发表评论的话必须先注册Github的账号，不过浏览评论是不受限制的</li>
</ul>

<p>但是使用Gitment是有问题的。更准确地说，如果你直接在你的博客中部署Gitment这个项目，那么你将面临你的Github application client secret token丢失的风险。这个风险会带来两种可能，一种是你自己的Github账户下的application被假冒，另一种是在你的博客上发表评论的Github用户被冒名。</p>

<p>这个风险看起来很大。而这对于Gitment来说又难于避免，因为它要求你在使用时往博客模板中插入以下代码：</p>

<pre><code class="language-javascript">var gitment = new Gitment({  
  id: '页面 ID', // 可选。默认为 location.href
  owner: '你的 GitHub ID',
  repo: '存储评论的 repo',
  oauth: {
    client_id: '你的 client ID',
    client_secret: '你的 client secret',
    ...
</code></pre>

<p>这个<code>client_secret</code>来自于你在自己的Github个人配置<code>Settings -&gt; Developer Settings -&gt; OAuth applicatoins</code>中创建一个application时所生成的secret，这个secret提供了所谓的单点登录认证，以确保其它的Github用户在经过同意后使用你的博客中的Gitment模块来发评化——这种用法类似于新浪、微信、QQ等等的小应用。</p>

<p>通常你需要这个secret有访问者的repo级别的访问权限（因为添加评论其实上是向repo的issues中添加comments），而一旦有人劫持了访问者的access_token，那么它就可以仿冒访问者在任意的github仓库中添加comments、以及issues——看起来很可怕不是？而且事实上看起来这个权限还更大，可以操作访问者自己的仓库。</p>

<p>Gitment的作者为什么要留下这么一个漏洞呢？Github又为什么会允许这样一个漏洞存在呢？</p>

<h3 id="81gitment">8.1 Gitment干了什么？</h3>

<p>其实Gitment的作者是好心的。他在源代码中是这么写的：</p>

<pre><code class="language-javascript">this.state.user.isLoggingIn = true  
http.post('https://gh-oauth.imsun.net', {  
    code,
    client_id,
    client_secret
  }, '')
  .then(data =&gt; {
    this.accessToken = data.access_token;
    ...
</code></pre>

<p>这段代码的意思，是拿你在Github后台生成的一对<code>client_id/client_secret</code>验证信息，去<code>https://gh-oauth.imsun.net</code>上面换取access_token，而这个access_token才是当前登录的Github用户在你的博客用发评论时使用的验证信息。这个access_token会记录在cookies中，并且每次调用Github api时作为Authorization头信息提交给Github验证身份。</p>

<p>你把client_id和client_secret同时给了imsun.net，这是不对的；即使你信任imsun.net，然而把它公布在源代码中，也是不对的。——所以，事实上如果你在博客中部署了上述代码，你还会收到来自Github的一封邮件，提醒你不应该将token放在源代码中（是的，Github会扫描提交的源代码）。</p>

<p>Gitment的作者并不是不知道这个问题，他只是好心的想帮你解决一个问题——这个我们下面会讲到——然而他带来了更严重的问题。</p>

<h3 id="82github">8.2 深入了解Github的单点登录和应用授权</h3>

<p>如果你在Github站外使用它的单点登录（也就是提示你用Github账户登录以使用某种功能），那么在这个网页中——其实也可以不是前端的网页，而是后端应用——需要调用Github API，来将当前用户引导到下面的Github的登录和授权页面：</p>

<pre><code class="language-bash">GET https://github.com/login/oauth/authorize  
    ?scope=(权限范围, Gitment预设的是'public_repo')
    &amp;client_id=(验证应用的client_id)
    &amp;redirect_url=(验证成功后的返回url, Gitment预设的是当前页)
</code></pre>

<p>这时，（如果当前用户/访客没有登录过，那么）它看到的页面是下面这样的：</p>

<blockquote>
  <p>（界面1：跨站应用的单点登录界面）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/github_auth_step-1.png" alt="github_auth_step-1"></p>

<p>如果访客还没有为这个应用授权过（或者他已经是Github的登录用户），那么他之后还会看到下面这个界面：</p>

<blockquote>
  <p>（界面2：授权）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/github_auth_step-2.png" alt="github_auth_step-2"></p>

<p>这两步的目的就是让访客登录，并且让他确认你的应用（例如Gitment）能够使用他的账号中的哪些权限。一旦用户确认过这个授权，那么在他的Github账号后台<code>Settings -&gt; Authorized OAuth Apps</code>中就可以看到这个应用（也能Revoke掉它），并且下次就不用再确认授权了。</p>

<p>注意到上述'will redirect to'的地址——它在使用API提交时的配置细节在Github API的说明中有（<a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/#redirect-urls">在这里</a>），简单地说它必须以Application在后台的配置作为前缀。在我们这里讨论的Gitment中，作者将它设置为当前正在访问的网页——例如某篇博客文章（Post）。</p>

<p>接下来如果Github验证并授权了访问的账户，它就会通过HTTP调用来返回304并带上一个Location地址，这个地址就是上面的redirect_url，并且会在这个url后面多带一个<code>code</code>参数。以我的站点上的某个具体的post来说，返回的时候这个Header是下面这样的：</p>

<pre><code>Location:https://aimingoo.github.io/1-1718.html?code=40299d8475d3679c8c8c  
</code></pre>

<p>在静态页面（例如1-1718.html）中从url取参数的方法就不用细讲了。于是接下来Giment取到这个参数<code>code</code>，它还需要再做一次验证，才能真正的让当前用户能够使用Github API。这个验证操作需要调用：</p>

<pre><code class="language-bash">POST https://github.com/login/oauth/access_token  
    client_id: ...
    client_secret: ...
    code: ...
</code></pre>

<p>并且它使用POST请求的Accept header来决定以何种格式（xml/json/url-encode）来返回数据。显然地，这里需要在浏览器中使用AJAX请求来向<code>https://github.com/</code>调用这个API。</p>

<p>问题就出在这一步。</p>

<h3 id="83githuboauth">8.3 Github OAuth并不支持浏览器跨站访问</h3>

<p>如果你在命令行上或者其它代码中直接访问上述POST API，那么不错，你能拿到返回数据access_token，然而不幸的是：Gitment在浏览器上，只能使用Ajax。</p>

<p>事实上Gitment可以调用上述API并返回数据，但是注意发起这个API的地址（以上面的post为例）与调用的Github API地址分别是：</p>

<pre><code>https://aimingoo.github.io/1-1718.html  
https://github.com/login/oauth/access_token  
</code></pre>

<p>于是浏览器说：这是一个跨站访问！浏览器会把POST请求拆成两个，先发一枚OPTIONS请求问问github.com是否支持跨站，如果github.com接受了OPTIONS并正确返回，那么浏览器才接下来发POST请求。——OPTIONS请求是没有POST BODY区的，显然这是为了避免服务器接受大型的POST请求时浪费资源。关于这个过程的细节，可以参考阮一峰老师的文章『<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a>』。简单地说，服务器端对OPTIONS和POST请求都必须在返回头中包括<code>Access-Control-Allow-Origin</code>字段，并使该字段带有正确的来源Origin信息。——这样一来，浏览器就会认为服务器是接受跨站访问的了。</p>

<p>然而Github的access_token接口并不返回上述头。而且，可以预见的将来，它都不会有这个头。因为这是正确的——我们确实不应该在浏览器上直接使用这个接口，并且公开接口中的client_secret。从另一方面来说，这个access_token接口是应该在一个浏览器用户受信的后端应用中，亦即是我们称为Gitment模板的应用内部发起调用的，它可以持有client_secret而不必告诉任何人，这是Github确认『该应用合法』的唯一凭据。</p>

<p>Gitment没有办法同时做到两件事：</p>

<ul>
<li>既可以使用一个惟一、统一的Giment client_secret凭据，</li>
<li>又在redirect_url中指定某个非确定的博客返回地址。</li>
</ul>

<p>这使得作者无法公开发布一个公众使用的、不需要每个博主去Github后台配置OAuth Application服务的应用。而接下来，作者也有没办法在没有client_secret凭据的情况下，帮你调用Github's access_token接口。</p>

<p>所以，你看到了结果：Gitment的代码要求在网页中泄露你的client_secret，然后提交到<code>https://gh-oauth.imsun.net</code>去，作者会帮助你调用Github API，然后返回一个access_token。</p>

<p>只有这样，当前的访问才能用这个access_token为每一个XHR Request建立有效的Authorization头。</p>

<p>问题的根源，仅仅是出在Github OAuth并不支持浏览器跨站访问——它的返回头用没有Access-Control-Allow-Origin。</p>

<h3 id="84api">8.4 API网关</h3>

<p>显然，这绝壁了就是API网关要干的事情。如果我有一个API网关，那么我就只需要接受来自浏览器的Gitment请求，然后将API转发到Github，并且在返回头上塞上一个Access-Control-Allow-Origin就万事大吉了！</p>

<p>是的，这是对的。不幸的是，没有这么个东东——而且要开放可信的。</p>

<p>我尝试过阿里云的API网关！很牛x的产品，价格也不贵，而且配置操作一路极顺畅，Ding dong Ding dong分分钟就建好了网关，但是——不能定制返回的HTTP Header！</p>

<p>我尝试过微软Azure里的API网关！也很牛x产品，骗了我一块钱人民币，居然让我连配置都完不成——最最反程序员的产品就非它莫属了。</p>

<p>我尝试过很多很多云服务或云端微服务的API网关产品，要么是根本连页面都打不开的，要么就是不支持CORS跨站的。简单地说：你就算想花钱也是花不出去的。</p>

<p>不过真想花钱，还是有一个法子的。你可以租一台虚拟主机，然后在上面架一个Nginx，通过配置来代理这个POST请求并在返回中加上Access-Control-Allow-Origin头。是的，这相当不错，连代码也不用写。但是搞云主机啊，分分钟收钱的。——你的API能访问几次？一个小小小小得不得了的博客，一个月能用10来条评论就不错了，调用上面的登录接口，大概也就三五次吧！</p>

<p>不值当搞台云主机啊！</p>

<p>于是，我说：</p>

<h3 id="85sir">8.5 写点代码吧，Sir</h3>

<p>要写点代码就其实很好办了，用NodeJS也好、PHP/ASP也行，其实甚至BASH脚本都搞得定。只需响应前端（frontend）来的POST请求，然后去Github API接口（backend）上拿数据，在返回前端之前塞上个Header就行了。</p>

<p>不过具体要做起来，就麻烦一点了。我用PHP写了一个名为intersect的项目（<a href="https://github.com/aimingoo/intersect">在这里</a>），它修改自<a href="https://github.com/stamat/corsica">CORSica</a>，不过添加了不少的特性：</p>

<ul>
<li>HTTPS POST支持</li>
<li>添加可配置字段（例如为Github API添加client_secret）</li>
<li>处理前后端不同的Connection方法</li>
<li>处理Transfer-Encoding</li>
<li>处理Content-Length的变化</li>
<li>一些防止滥用的简单guard代码</li>
<li>...</li>
</ul>

<p>基本上，我的意思是说，它简单的配置下就可用了；而且稍作定制，也可以作为一个通用的CORS网关。所以，接下来，你就需要找一个能放PHP代码的免费主页，然后把intersect放上去，配置其中的<code>DOMAIN_ACCEPT</code>和<code>PRIVATE_CLIENT_SECRET</code>。这样这个网站就能拿来替代Gitment中对<code>https://gh-oauth.imsun.net</code>的访问了。</p>

<p>当然，Gitment还需要稍稍的改点代码。</p>

<p>这个我们回头再说，现在我们得搞一个提供免费主页的网站把这个代码放上去。</p>]]></content:encoded></item></channel></rss>
