<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Aimingoo's Blog]]></title><description><![CDATA[何不乐乐而有哉]]></description><link>http://aimingoo.github.io/</link><generator>Ghost 0.11</generator><lastBuildDate>Wed, 07 Jun 2017 19:04:10 GMT</lastBuildDate><atom:link href="http://aimingoo.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[在电子书中使用SVG]]></title><description><![CDATA[<blockquote>
  <p>在之前的文章中，我们讨论了《<a href="http://aimingoo.github.io/1-1726.html">Kindle电子书中该用多大的图片</a>》，以及《<a href="http://aimingoo.github.io/1-1727.html">详解ImageMagick中SVG的支持</a>》，本文可以看作它们的后续。</p>
</blockquote>

<p>在高版本的电子书格式中是可以支持使用.svg作为图片的，并且看起来与.png/.jpg的使用并没有什么不同。但是，如何制作合适大小的.svg却是一个相当烦恼的问题。</p>

<p>因为电子书在.svg文件上采用了与.png/.jpg不一样的排版规则。</p>

<h2 id="svg">一些.svg相关的基础知识</h2>

<p>与.pdf一样，事实上.svg文件中也是没有DPI信息的，因为它们都是以矢量格式为基础的。而且它们也都相同的使用Points（磅值/点）来记录图片大小，或称之为页面信息。</p>

<p>一般来说，.svg不支持多页。尽管多页格式已经发布（<a href="https://www.w3.org/TR/2004/WD-SVG12-20041027/multipage.html">SVG 1.2</a>），但多数系统并不支持它。</p>

<p>所谓『.svg文件有多大的精度，或多少DPI』其实是个伪命题。因为这其实是不同的处理软件的一个假设/约定——这一点与.pdf是一样的。但不同的是：</p>

<ul>
<li>.pdf约定默认的分辨率是72DPI；而</li>
<li>.svg通常约定的是90DPI。</li>
</ul>

<p>然而即使是同一个软件的不同版本，</p>]]></description><link>http://aimingoo.github.io/1-1728.html/</link><guid isPermaLink="false">d18ac6ba-a8ce-4b89-8f4e-57b5655612c7</guid><category><![CDATA[电子书]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[svg]]></category><category><![CDATA[ImageMagick]]></category><category><![CDATA[Kindle]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 07 Jun 2017 19:02:44 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>在之前的文章中，我们讨论了《<a href="http://aimingoo.github.io/1-1726.html">Kindle电子书中该用多大的图片</a>》，以及《<a href="http://aimingoo.github.io/1-1727.html">详解ImageMagick中SVG的支持</a>》，本文可以看作它们的后续。</p>
</blockquote>

<p>在高版本的电子书格式中是可以支持使用.svg作为图片的，并且看起来与.png/.jpg的使用并没有什么不同。但是，如何制作合适大小的.svg却是一个相当烦恼的问题。</p>

<p>因为电子书在.svg文件上采用了与.png/.jpg不一样的排版规则。</p>

<h2 id="svg">一些.svg相关的基础知识</h2>

<p>与.pdf一样，事实上.svg文件中也是没有DPI信息的，因为它们都是以矢量格式为基础的。而且它们也都相同的使用Points（磅值/点）来记录图片大小，或称之为页面信息。</p>

<p>一般来说，.svg不支持多页。尽管多页格式已经发布（<a href="https://www.w3.org/TR/2004/WD-SVG12-20041027/multipage.html">SVG 1.2</a>），但多数系统并不支持它。</p>

<p>所谓『.svg文件有多大的精度，或多少DPI』其实是个伪命题。因为这其实是不同的处理软件的一个假设/约定——这一点与.pdf是一样的。但不同的是：</p>

<ul>
<li>.pdf约定默认的分辨率是72DPI；而</li>
<li>.svg通常约定的是90DPI。</li>
</ul>

<p>然而即使是同一个软件的不同版本，也可能修改这个约定。例如Inkscape 从v0.92版本开始就默认使用96DPI的约定——而之前它是90DPI（<a href="http://wiki.inkscape.org/wiki/index.php/Release_notes/0.92#Important_changes">参见这里</a>，以及<a href="http://wiki.inkscape.org/wiki/index.php/Units_In_Inkscape">这里</a>）。</p>

<p>相对好一些的消息是：能够实现SVG处理的引擎并不太多——所以上述的一些不确定的限制条件也就相对来说容易穷举。这些引擎主要包括Cario、Inkscape、Apache Batik和一些浏览器上的Canvas。当然，此前讲过的ImageMagick内置的MSVG也算一个，不过它实在弱到没朋友，不提也罢。很多工具其实是以上述引擎为内核或库的，其中最常用的是Cario，包括rsvg在内的许多库/包都只是Cario上的一个封装。</p>

<blockquote>
  <p>注1：Cario库也支持PDF，所以Inkscape、Poppler等都使用它来输出PDF和PostScript文档（生成的.pdf文件元信息中Creator也是Cario）。但是Inkscape的SVG渲染引擎是自有的，相关信息可以参考<a href="https://en.wikipedia.org/wiki/Cairo_(graphics)">这里</a>。</p>
</blockquote>

<p>本文中提到的一些工具可以用如下方式安装：</p>

<pre><code class="language-bash">## rsvg, rsvg-convert, and cario ...
&gt; brew install libsvg librsvg libsvg-cairo cairo

## pdf2svg, mactex(pdfcrop), Inkscape, more...
&gt; brew install pdf2svg
&gt; brew cask install xquartz mactex inkscape

# ImageMagick(identify,convert,mogrify...), and pdfinfo or cpdf
&gt; brew install ghostscript imagemagick cpdf poppler

## cairosvg for python
&gt; pip3 install cairosvg

## svginfo
&gt; git clone http://github.com/aimingoo/svginfo
&gt; install svginfo/svginfo /usr/local/bin/
</code></pre>

<h2 id="pdfsvg">从PDF到SVG</h2>

<p>你可能已经习惯使用种种矢量图形工具并用来制作.svg，反正我不是。我通常是用PowerPoint或Keynote来制作它们（尤其是表格）并存储为PDF，然后由.pdf转为.svg。</p>

<p>这个过程看起来麻烦，但确实靠谱。</p>

<p>总的来说，从PDF到SVG的工具主要有两个（<a href="https://en.wikipedia.org/wiki/Wikipedia:Graphics_Lab/Resources/PDF_conversion_to_SVG#How_to_convert_a_PDF_to_SVG">Wiki上也是这么说的</a>）。其中最方便、快捷和安全的应该是cityinthesky的pdf2svg，他使用Poppler+Cario；另一个是inkscape，除了在字体处理上表现不稳定之外，它还需要XQuartz的支持（这就比较庞大了）。</p>

<p>pdf2svg可以直接使用brew安装，它的开源项目<a href="http://www.cityinthesky.co.uk/opensource/pdf2svg">在这里</a>，或<a href="https://github.com/indraniel/pdf2svg">这里</a>。采用相同技术实现的还有<a href="https://github.com/indraniel/pdf2svg">Perl</a>和<a href="https://github.com/jakobwesthoff/pdf2svg">Vala</a>的版本——因为使用的都是相同的库，因此效果应该没差。其它可选的方案包括<a href="https://github.com/ContentMine/pdf2svg">Java</a>、<a href="https://github.com/ststeiger/Pdf2Svg">C#</a>版的等等，但采用的是各自语言下的引擎，我没有一一试过。</p>

<p>使用pdf2svg的参数如下：</p>

<pre><code class="language-bash">&gt; pdf2svg --help
Usage: pdf2svg &lt;in file.pdf&gt; &lt;out file.svg&gt; [&lt;page no&gt;]  
</code></pre>

<p>其中<code>&lt;page no&gt;</code>可以使用字符串<code>all</code>。</p>

<p>注意pdf2svg并不能指定输出的.svg的大小、DPI等等。其实你使用inkscape来转换也一样没有这类参数——在转换目标格式为.svg时，inkscape仅会多出<code>--export-text-to-path</code>、<code>--export-id</code>两个参数可用。此外，inkscape只能处理单页的PDF：</p>

<pre><code class="language-bash">&gt; inkscape -z --export-plain-svg=&lt;out file.svg&gt; &lt;in file.pdf&gt;
</code></pre>

<p>最后，pdf2svg与inkscape转换出来的.svg文件的页面大小其实是一样，但是它们使用的单位并不相同。如下：</p>

<pre><code class="language-bash">## inkscape
&gt; svginfo by-inkscape.svg
width: 152.5  
height: 77.5  
viewBox: 0 0 152.5 77.5

## pdf2svg, and more...
&gt; svginfo by-cario.svg
width: 122pt  
height: 62pt  
viewBox: 0 0 122 62  
</code></pre>

<p>注意inkscape转出时使用了缺省单位，这通常是指px；而cario转出时使用的是pt。对于上例来说，原始的pdf文件信息如下：</p>

<pre><code class="language-bash">&gt; pdfinfo my.pdf | grep 'Page size'
Page size:      122 x 62 pts  
</code></pre>

<p>可见，两种引擎事实上都是直接以该页面大小的pt值作为.svg的宽高，只不过inkscape转换成了相应的px值。</p>

<blockquote>
  <p>注1：需要强调的是，上述版本的inkscape的采用的是90DPI的.svg设定，而PDF默认为72DPI。所以从<code>.PDF的Pts</code>到<code>.SVG的px</code>的转换系数是<code>90/72</code>，即<code>width = 122pt * 90/72 = 152.5px</code>。</p>
  
  <p>注2：就我的测试来说，Inkscape在处理<code>PDF -&gt; png</code>的转换时不能正确的识别中文字体，其它类型下的转换我并没有一一试过。</p>
</blockquote>

<h2 id="svginfoimagemagick">svginfo: 不要相信ImageMagick的显示</h2>

<p>如果你使用<code>identify -verbose your.svg</code>来查看svg的信息的话，那么由于ImageMagick可能工作在不同的SVG模式下，所以输出的信息也就不同。——这就是我的上一篇文章为什么叫《详解ImageMagick中SVG的支持》的原因。</p>

<p>我测试了一下上文中提到的4种模式，如下：</p>

<pre><code>## test information of 'identify -verbose your.svg'
===&gt; MODE: internal, use MSVG
  Geometry: 485x306+0+0
  Units: Undefined
===&gt; MODE: build-in, use RSVG/librsvg
  Geometry: 517x327+0+0
  Resolution: 37.8x37.8
  Print size: 13.6772x8.65079
  Units: PixelsPerCentimeter
===&gt; MODE: delegate(internal), use inkscape
  Geometry: 517x327+0+0
  Resolution: 37.8x37.8
  Print size: 13.6772x8.65079
  Units: PixelsPerCentimeter
===&gt; MODE: delegate, use rsvg-convert
  Geometry: 517x327+0+0
  Units: Undefined
</code></pre>

<p>这四种模式中，MSVG是唯一一个不转换成图片（因为内置xml解析和svg支持）的方式，也是它与别的模式看起来有差异的原因。此外，由于缺省使用了<code>PixelsPerCentimeter</code>单位，所以Resolution显示是<code>37.8x37.8</code>，换算成英寸则是96DPI。</p>

<p>那么这个<code>your.svg</code>的大小到底是多少呢？很不幸，它真实的数据是<code>388x245 pts</code>。</p>

<p>因为svg缺省是工作在90dpi模式下的，所以MSVG用90dpi来换算.svg的大小，就得到了<code>388 * 90/72 = 485px</code>的宽，而其它模式都是先转换成图片，并指定了参数96DPI，这时宽度就成了<code>388 * 96/72 = 517px</code>。</p>

<p>所以无论如何（除非你能确切指定使用某一种SVG引擎），对于.svg来说，ImageMagick显示的大小是作不得准的。更好的办法是直接显示.svg中的元信息，例如使用<code>svginfo</code>这个工具（<a href="https://github.com/aimingoo/svginfo">下载在这里</a>）：</p>

<pre><code class="language-bash">&gt; svginfo your.svg
width: 388pt  
height: 245pt  
viewBox: 0 0 388 245  
zoomAndPan: magnify  
preserveAspectRatio: none  
</code></pre>

<p>在.svg的元信息中保存的width/height值可能有很多种单位（<a href="http://www.sarasoueidan.com/blog/svg-coordinate-systems/#svg-viewport">参见这里</a>，或<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Positions">中文译本</a>，缺省是px，但与具体设备有关）。</p>

<h2 id="svg">电子书并其实不能『很正确』地显示.svg文件</h2>

<p>现在我们得到了.svg，并且我们确切地知道它的大小与.pdf的Page Size的Pts值存在<code>90:72</code>的关系（因为默认精度不同）。所以我们只需要控制.pdf的大小，就可以得到合适的.svg文件了。——不考虑.svg的工具的话，在.pdf的工具套件中还有cpdf，还有gs等等可用，很丰富。</p>

<p>但是，真正的一张520pts(或者是520px)大小的.svg，会如何显示在电子书上呢？</p>

<p>答案是：不一定。</p>

<p>如果你在电子书中用<code>&lt;img src="xxx.png"&gt;</code>来插入一张图片而没有指定它的宽高，那么几乎所有的排版引擎都能理解这个行为：</p>

<ul>
<li>将xxx.png图片信息中的宽高信息作为显示宽高；</li>
<li>如果这个宽高大于设备的可见区域，则缩小到合适的大小。</li>
</ul>

<p>——所以，在电子书中使用图片时只需要考虑图片的精度，其它方面几乎是完美的、自适应的。</p>

<p>然而如果你用同样的方法来插入一个.svg文件，那么由于pt这个单位的存在，所以设备如何显示就成了『谜之问题』了。首先我们要知道，</p>

<blockquote>
  <p>如果一个.svg是使用px作为单位（也包括没有单位而缺省的），那么将采用与图片一致的规则。</p>
</blockquote>

<p>这是一条重要的原则，也成为检测其它.svg单位的关键钥匙。</p>

<p>例如以前面的your.svg为例——它使用了pt作为单位，是388pt。由于.svg是缺省以90DPI为来计算pt值的，所以MSVG还原成px时，显示的是485px的宽。但是到了实际物理设备时，却不一定是以90DPI——这个假想值——来处理的了。例如在Macbook上的iBooks中显示时，iBooks的SVG渲染引擎采用了96DPI的预设值，所以就将显示成<code>388 * 96/72 = 517px</code>；又例如我是要在Kindle Paperwhite3上来显示它，那么由于Kindle使用它的PPI（300DPI）来作为预设值，所以显示出来就应该是惊人的<code>1616px</code>。——好吧，你知道Kindle显示不下了，而.svg是矢量缩放的，所以最终只是按可见区域的全宽来显示它。</p>

<p>电子书的这个处理方案正确不呢？答案是『正确』。因为这其实就是pt作为单位的原始用意。它看起来不是那么『很正确』的原因在于：这样一来，我们就不知道到底该做多大的.svg才能在不同的物理设备上适用了。</p>

<p>那么，最终只剩下了两条规则适用：</p>

<ul>
<li>在文件中明确使用px作为单位来指定大小的.svg；或者，</li>
<li>在使用<code>&lt;img ...&gt;</code>标签插入.svg时，指定它的宽高信息。</li>
</ul>

<h2 id="pxsvg">使用px作为单位来指定大小的.svg</h2>

<p>使用Inkscape转出的.svg是作用缺省单位px的。但是这个转换是采用.pdf的Points换算过来的，为此你必须将.pdf放大一些，才能在Inkscape中得到你预期的的px值大小。这个换算关系如下：</p>

<pre><code class="language-bash"># 步骤1：将.PDF的大小换算成300DPI下比例(放大300/90倍)
#    - 因为pdf转成svg时还要再放大90/72倍，所以这里不需要直接用300/72作系数
&gt; cpdf -scale-page "3.33333 3.33333" -scale-to-fit-scale 3.33333 -o new_300DPI.pdf my.pdf

# 步骤2：将新文件转换成.svg
&gt; inkscape -z --export-plain-svg=my.svg new_300DPI.pdf

# 查看原始的my.pdf的信息
&gt; pdfinfo my.pdf | grep 'Page size'
Page size:      122 x 62 pts

# 查看中间文件.pdf的大小
&gt; pdfinfo new_300DPI.pdf | grep 'Page size'
Page size:      406.666 x 206.666 pts

# 查看新的.svg的信息
&gt; svginfo my.svg
width: 508.33282  
height: 258.33307  
viewBox: 0 0 508.33282 258.33307  
zoomAndPan: magnify  
preserveAspectRatio: none  
</code></pre>

<p>验证方法：制作一张<code>508 x 258</code>的图片，与my.svg一起插入到电子书中，它们显示起来将是相同大小。</p>

<h2 id="svg">正确插入.svg的宽高信息</h2>

<p>我们也可以选择如下的途径（在这个过程中不需要对调整中间文件与.svg的大小）：</p>

<blockquote>
  <ul>
  <li>从.ppt/.key转换到.pdf，再</li>
  <li>从.pdf转换到.svg，最后</li>
  <li>在电子书中插入.svg的宽度信息。</li>
  </ul>
</blockquote>

<p>我们假设以.html作为生成电子书的中间格式（如果你真做过电子书的话，你应该知道我为什么这么假设），那么事实上我们就只需要扫描所有的.svg，通过svginfo来查看信息，经过计算并将正确的宽高信息写到.html就好了。</p>

<p>我们需要知道相应的.svg与最初预设的宽高上限（注意考虑到实际使用，我只预设了x方向上限，并不处理y方向）。我们之前说过：合理的预设是<code>520px</code>。所以，例如480px宽的.svg，那么我们就将<code>&lt;img …&gt;</code>中的width值回写成<code>92.3%</code>。</p>

<p>我想，你可能已经发现问题了：这个92.3%应该是指的图片相对于当前设备宽的比例啊，而不是图片自己的宽度值。——是的，我的确是这样考虑的，至于为什么，你得仔细去思考了。</p>

<p>其它（建议综合我最近的几篇文章来理解下述过程）：</p>

<ul>
<li>我们原始设计的宽是520px，在300DPI情况下的物理宽是1.73333inch；</li>
<li>当把上述文档输出成PDF时，物理宽（Print Size）不变；而精度变成了PDF默认的72，所以在转换成Points值时变成了124.8pt，即<code>1.73333inch * 72pt/inch</code>；</li>
<li>我们再从.pdf转到.svg时是pt by pt的，所以相应的.svg值是124.8pt；
<ul><li>如果使用pdf2svg，则转换出的.svg是<code>width = 156</code>，使用了缺省单位px；</li></ul></li>
<li>使用<code>identify msvg:your.svg</code>取值最快，但要注意它总是以px为单位显示宽高信息；
<ul><li>在不支持MSVG的ImageMagick的低版本中，建议用svginfo取值并转换单位</li></ul></li>
</ul>

<p>相关操作如下（下载<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.pdf">standard<em>image</em>templet_520.pdf</a>）：</p>

<pre><code class="language-bash"># 步骤1：使用hires参数和高的resolution值可以使crop操作更精确
#    - 输出的.pdf的精度与该参数值是无关的
&gt; pdfcrop --hires --resolution 1200 standard_image_templet_520.pdf croped.pdf

# 步骤2：转换pdf到svg
&gt; pdf2svg croped.pdf standard_image_templet_520.svg 1

# 使用pdfinfo查看信息
&gt; pdfinfo croped.pdf | grep 'Page size'
Page size:      124.8 x 73.26 pts

# 使用svginfo查看信息
&gt; svginfo standard_image_templet_520.svg
width: 124.8pt  
height: 73.26pt  
viewBox: 0 0 124.8 73.26  
zoomAndPan: magnify  
preserveAspectRatio: none

# 使用identify查看信息(强制使用MSVG引擎)
&gt; identify msvg:standard_image_templet_520.svg | xargs -n1
msvg:standard_image_templet_520.svg=&gt;standard_image_templet_520.svg  
MSVG  
156x92  
156x92+0+0  
...
</code></pre>

<h2 id="">黑科技：最后一点补充</h2>

<p>如果：</p>

<ul>
<li>你确实想让.svg用px作为单位，以避免修改电子书中的width/height信息；并且，</li>
<li>你确实又憎恨Inkscape的巨大安装包和超慢速度，以及它只能处理单页的问题；并且，</li>
<li>你不太担心pdf2svg转换后的.svg文件较大的问题；并且，</li>
<li>……</li>
</ul>

<p>也许你只是纯粹的点处理爱好者（px fans?），那么好吧，我们讲一种最简单（目前看来也挺安全，但……我不做任何保证）的黑科技。下面仍然以<code>standard_image_templet_520.pdf</code>这个文件为例：</p>

<pre><code class="language-bash"># 步骤1：在300DPI下crop，以提高crop的计算精度
#    - 输出的croped.pdf的精度与该参数值是无关的
&gt; pdfcrop --hires --resolution 300 standard_image_templet_520.pdf croped.pdf

# 步骤1：将.PDF的大小假想成px单位，直接换算成300DPI下的大小
#    - 也就说无脑放大300/72倍就行啦
&gt; cpdf -scale-page "4.166667 4.166667" -scale-to-fit-scale 4.166667 -o scaled.pdf croped.pdf

# 步骤3：使用pdf2svg转换
#    - pdf2svg得到的.svg是使用pt为单位的, 无脑改成px就行啦
#    - pdf2svg可处理多页(会成批生成文件，所以不要用stdout；这里只做单页的示例)
#    - 使用sed时只替换了&lt;svg ...&gt;标签中的width/height，其它的不作处理
&gt; pdf2svg scaled.pdf /dev/stdout 1 |\
    sed -E '1,/^&lt;svg/s/(width|height)="([0-9.]*)pt"/\1="\2px"/g' &gt;\
    standard_image_templet_520.svg

# 查看最终的svg的大小
&gt; svginfo standard_image_templet_520.svg
width: 520.000042px  
height: 305.000024px  
viewBox: 0 0 520.000042 305.000024  
zoomAndPan: magnify  
preserveAspectRatio: none

# 使用ImageMagick的MSVG模式查看
&gt; identify msvg:standard_image_templet_520.svg | xargs -n2
msvg:standard_image_templet_520.svg=&gt;standard_image_templet_520.svg MSVG  
520x305 520x305+0+0  
16-bit sRGB  
...
</code></pre>

<p>为什么能这么做呢？</p>

<p>首先，我们知道.svg文件中其实并没有精度信息，所有的元素都是基于页面的大小来做换算的。而且，我们在这里用pdf2svg转换出的.svg还有两个特性：</p>

<ul>
<li>字体已经被转换成矢量信息，因此.svg中不包含字体及字体大小信息；</li>
<li>只有\<svg …\="">元素包含了页面宽高信息，其它元素是基于该信息的矢量。</svg></li>
</ul>

<p>所以我们可以安全地将pt值直接替换成px。而这个方法，对于Inkscape生成的.svg就不适用，对比一下上面的两个特性你就明白了。反过来说，正是由于Cario引擎（pdf2svg使用的svg引擎）并不完整支持以px为单位的svg，所以使用该引擎——以及使用该引擎实现的工具来转换上述（修改后的）.svg到.png或其它格式的时候也是会出问题；而相对应的，Inkscape却能正确处理——它的引擎支持以px为单位的.svg。</p>

<p>最后，多啰嗦一句。由于pdf2svg转换时将字体转换成了矢量信息，这使得通过这种.svg转换成图片或其它格式时不会因为缺少字体而失真（相对应的，Inkscape就存在字体问题）。但是缺点也是有的，就是.svg文件会比较大一些，可能相应的处理速度也会略慢。</p>]]></content:encoded></item><item><title><![CDATA[详解ImageMagick中SVG的支持]]></title><description><![CDATA[<p>事实上ImageMagick是可以很好地支持svg的——当然，它只是将svg转成图片格式而不能反过来，毕竟它只是个图片处理工具。不论是在使用convert，identify还是mogrify等等时，只要操作的对象是一个.svg文件，那么ImageMagick就会启动这一机制。例如，当你使用identify查看一个.svg信息的时候，事实上你是在查看它转换后得到的一张.png图片：</p>

<pre><code class="language-bash">&gt; identify -verbose your.svg
Image: /var/folders/w9/fy0l4xgj3w73j4d71748v9nw0000gn/T/magick-481524PstlAlieWiB  
  Base filename: your.svg
  Format: PNG (Portable Network Graphics)
  Mime type: image/png
  Class: DirectClass
...
</code></pre>

<p>ImageMagick主要有三种支持SVG的方式，包括内置（Internal）、内建（Build-in）和委托（Delegate）。</p>

<p>在高版本的ImageMagick中MSVG总是内置的；而稍早些的版本中，</p>]]></description><link>http://aimingoo.github.io/1-1727.html/</link><guid isPermaLink="false">a849bf10-dbd6-4709-a2c2-dec2bc6c193c</guid><category><![CDATA[svg]]></category><category><![CDATA[ImageMagick]]></category><category><![CDATA[图形处理]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[电子书]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Mon, 05 Jun 2017 11:54:13 GMT</pubDate><content:encoded><![CDATA[<p>事实上ImageMagick是可以很好地支持svg的——当然，它只是将svg转成图片格式而不能反过来，毕竟它只是个图片处理工具。不论是在使用convert，identify还是mogrify等等时，只要操作的对象是一个.svg文件，那么ImageMagick就会启动这一机制。例如，当你使用identify查看一个.svg信息的时候，事实上你是在查看它转换后得到的一张.png图片：</p>

<pre><code class="language-bash">&gt; identify -verbose your.svg
Image: /var/folders/w9/fy0l4xgj3w73j4d71748v9nw0000gn/T/magick-481524PstlAlieWiB  
  Base filename: your.svg
  Format: PNG (Portable Network Graphics)
  Mime type: image/png
  Class: DirectClass
...
</code></pre>

<p>ImageMagick主要有三种支持SVG的方式，包括内置（Internal）、内建（Build-in）和委托（Delegate）。</p>

<p>在高版本的ImageMagick中MSVG总是内置的；而稍早些的版本中，ImageMagick是混合了『内建』和『委托』两种方式来提供SVG的支持的。<strong>需要强调的是</strong>：</p>

<blockquote>
  <p>请尽量不要直接使用内置的MSVG。</p>
</blockquote>

<h2 id="msvg">内置的MSVG</h2>

<p>ImageMagick的高版本内置了一个SVG渲染器。它有两种称谓，在代码中叫做<code>IMAGEMAGICK_SVG</code>，例如在编译中提供相应的开关参数；而在用户级别的配置或接口中，它称为MSVG（这里的M是Magick的首字母）。它完整的名称是<code>ImageMagick's own SVG internal renderer</code>，所以<code>自有SVG（Own SVG）</code>、<code>内部渲染器（internal renderer）</code>以及<code>MSVG</code>其实指的都是同一个东西：</p>

<pre><code class="language-bash">&gt; convert -list format | grep SVG
     MSVG  SVG       rw+   ImageMagick's own SVG internal renderer
      SVG  SVG       rw+   Scalable Vector Graphics (XML 2.9.4)
     SVGZ  SVG       rw+   Compressed Scalable Vector Graphics (XML 2.9.4)
</code></pre>

<p>注意这里的『XML 2.9.4』其实也是MSVG引擎的一部分，它实际上指的是<code>libxml2</code>这个库的版本，因为MSVG是基于xml解析并自行渲染的svg引擎。</p>

<p>由于MSVG存在很多限制，所以ImageMagick『千万百计』地隐藏了它的存在——哈哈，其实没有这么夸张，它们是承认这个东西的存在并且提供官方支持的（<a href="http://www.imagemagick.org/Usage/draw/#svg">在这里</a>）。</p>

<p>在ImageMagick <strong>6.6.7-10</strong>之后的版本中，MSVG总是缺省内置支持(<code>WITH_IMAGEMAGICK_SVG</code>参数缺省打开)，即使是在<code>WITHOUT_X11</code>状态下，编译过程也只是给出WARN级别的警告。</p>

<p>而在此前（ 但晚于v6.3.3-5之后的）版本中，如果<code>WITHOUT_X11</code>，那么编译时将不会内置支持SVG。</p>

<blockquote>
  <p>参考：<a href="https://www.freshports.org/graphics/ImageMagick/">https://www.freshports.org/graphics/ImageMagick/</a></p>
</blockquote>

<p>任何情况下，如果你只是想启用MSVG（以避开其它引擎的影响），那么你可以在input文件名上加上"msvg:"前缀（v6.3.4以后）。例如：</p>

<pre><code class="language-bash">&gt; identify -verbose 'msvg:your.svg'
Image: your.svg  
  Base filename: b2t_8-2.svg
  Format: MVG (Magick Vector Graphics)
  Class: DirectClass
  Geometry: 485x306+0+0
...
</code></pre>

<p>你也可以使用<code>-draw</code>参数来开启一个MSVG的画板并操作它。例如（将这块画板作为源，转换成PNG格式输出）：</p>

<pre><code class="language-bash"># http://www.imagemagick.org/Usage/draw/#svg
&gt; convert -size 10x6 xc:skyblue  -fill black \
          -draw 'color 6,3 point' -scale 100x60 draw_color_point.png
</code></pre>

<h2 id="">内建模式及其开启</h2>

<p>如果ImageMagick在安装时包含librsvg模块，那么就会启用内建模式（所以Build-in SVG也往往直接称为RSVG）。一旦包含这个模块，那么它的优先级比内置的MSVG要高。</p>

<p>如果你是使用brew来安装的ImageMagick，那么你可以用：</p>

<pre><code class="language-bash">&gt; brew info imagemagick
...
Optional: fontconfig ✔, little-cms ✘, little-cms2 ✔, libwmf ✘, librsvg ✔ ...  
</code></pre>

<p>来查看当前环境是否能支持rsvg。如上，<code>librsvg</code>已经安装了，那么就可以通过安装参数来开启它（或使用<code>brew reinstall</code>重新安装）：</p>

<pre><code class="language-bash"># 你可能需要先安装librsvg模块
#    - brew install librsvg
&gt; brew install imagemagick --with-librsvg
</code></pre>

<p>如果你不是使用brew，那么你可以使用如下命令来查看：</p>

<pre><code class="language-bash">&gt; convert -list configure | grep -Eoe '--with-rsvg(=[^\-]+)?'
--with-rsvg=no
</code></pre>

<p>如果没有rsvg的支持，那么你需要自己编译ImageMagick，相关的操作<a href="http://www.imagemagick.org/script/advanced-unix-installation.php">在这里</a>。</p>

<p>如果你成功安装了rsvg支持，那么可以看到如下信息：</p>

<pre><code class="language-bash"># build-in的delegate中包含了rsvg
&gt; identify -version | grep --color rsvg
Delegates (built-in): bzlib cairo fontconfig freetype jng jpeg ltdl lzma png rsvg tiff xml zlib

# 或format中使用了rsvg来支持svg
&gt; identify -list format | grep -i svg
convert -list format | grep -i svg  
     MSVG  SVG       rw+   ImageMagick's own SVG internal renderer
      SVG  SVG       rw+   Scalable Vector Graphics (RSVG 2.40.17)
     SVGZ  SVG       rw+   Compressed Scalable Vector Graphics (RSVG 2.40.17)
</code></pre>

<blockquote>
  <p>注1：一些资料中称需要使用<code>--use-rsvg</code>参数在编译中开启rsvg支持，这可能是一个被放弃的、早期的构建参数。</p>
  
  <p>注2：在brew中用的参数是<code>--with-librsvg</code>，而实际上编译时使用的是<code>--with-rsvg</code>参数。这个转换操作是在brew安装用的formula文件中完成的。</p>
</blockquote>

<h2 id="">委托模式的开启</h2>

<p>通常情况下，ImageMagick会在内置的MSVG和内建模式（RSVG）之间选择一个；如果二者都没有，那么它会选择第三种，也就是委托模式。</p>

<p>你总是可以通过如下命令查看ImageMagick委托（外部程序）来进行的图形转换，包括SVG：</p>

<pre><code>&gt; convert -list delegate | grep 'svg'
...
svg =&gt;          "rsvg-convert' -o '%o' '%i"  
</code></pre>

<blockquote>
  <p>注：严格来说，前面说的内建模式事实上也是一种委托。只不过它是在编译时build-in的，所以在<code>--help</code>参数显示的信息中就能直接看到，并且会影响<code>-format</code>显示的格式支持；而在<code>-list delegate</code> 所列举的委托关系中，却并不会出现。</p>
</blockquote>

<p>由于只有MSVG和rsvg都不生效时才会开启委托模式，但高版本中ImageMagick中总是内置MSVG，所以是很难触发委托模式的。因此，如果你做这个尝试，那么你需要一个不内置MSVG的低版本ImageMagick，并且在编译中关闭<code>--with-rsvg</code>选项。OK，这样你就可以看到ImageMagick调用了上述委托中的<code>rsvg-convert</code>来进行转换。</p>

<p>当然，也有例外，因为其实还是有一个后门来做这件事的，这就是所谓的内部委托。</p>

<h3 id="">内部委托</h3>

<p>准确地说法：MSVG这个内部渲染器提供了一个『内部委托（special internal delegates）』。这种内部委托与上面的<code>rsvg-convert</code>采用的是类似机制，但是通过<code>-list delegate</code>命令是无法查看到的——你得打开配置文件自己来找：</p>

<pre><code class="language-bash"># 查看你的ImageMagick将读取哪些配置文件
&gt; convert -debug all -list delegate 2&gt;&amp;1 | grep 'delegates.xml'
Searching for configure file: ...  
...
Path: /usr/local/Cellar/imagemagick/7.0.5-9/etc/ImageMagick-7/delegates.xml  
</code></pre>

<p>注意前面有一个搜索优先顺序的列表（你可能用得上），不过这里我们只需要关心最后这个<code>Path</code>就好了。打开这个文件，查找<code>svg:decode</code>，将<code>stealth="True"</code>删除掉。现在你就可以看到它了：</p>

<pre><code class="language-bash">&gt; convert -list delegate | grep -Ee 'svg(:decode)? ='
        svg =&gt;          "rsvg-convert' -o '%o' '%i"
 svg:decode =&gt;          "inkscape' '%s' --export-png='%s' --export-dpi='%s' --export-background='%s' --export-background-opacity='%s' &gt; '%s' 2&gt;&amp;1"
</code></pre>

<blockquote>
  <p>注：内部委托与一般的（外部程序的）委托模式处理逻辑是一样的，只是在高版本的ImageMagick用<code>svg:decode</code>替代了<code>svg</code>这个入口而已。</p>
</blockquote>

<p>是的，你应该已经注意到了，这个内部的委托指向了inkscape。你可以安装inkscape来支持这个委托。例如：</p>

<pre><code class="language-bash">&gt; brew cask install xquartz inkscape
</code></pre>

<h3 id="">接管内部委托</h3>

<p>你也可以自己写个脚本来将操作转发到你的处理程序（类似于代理）。例如：</p>

<pre><code class="language-bash">#!/bin/bash
DPI="${3##*=}"  
rsvg-convert --format=png --output="${2##*=}" --dpi-x="${DPI%%,*}" --dpi-y="${DPI##*,}" --background-color="${4##*=}" "$1"  
</code></pre>

<p>将这个脚本另存到搜索路径中，并命名为<code>inkscape</code>，加上可执行权限。OK，你就看到<code>svg:decode</code>的相关调用转发到你的脚本中，并交给rsvg-convert处理了。</p>

<blockquote>
  <p>注意：如果内部委托调用出错（程序退出代码大于0），那么ImageMagick将再次调用MSVG来完成处理。</p>
</blockquote>

<p>当然，我们也可以把这个接管的脚本程序写得通用一点。比如将delegates.xml中的<code>svg:decode</code>项修改到一个统一的模式（以后就可以不用改了，不过sv要注意其中的<code>YOUR_SCRIPT_NAME</code>应该修改得与后面的脚本名一致）：</p>

<pre><code class="language-xml">&lt;delegate decode="svg:decode" command="&amp;quot;YOUR_SCRIPT_NAME&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;quot;%s&amp;quot; &amp;gt; &amp;quot;%s&amp;quot; 2&amp;gt;&amp;amp;1"/&gt;  
</code></pre>

<p>然后安装自己的工具（下面以cairosvg这个工具为例，首先安装它）：</p>

<pre><code class="language-bash"># @see: http://cairosvg.org/
&gt; pip3 install cairosvg
</code></pre>

<p>然后写调用脚本（<code>YOUR_SCRIPT_NAME</code>）：</p>

<pre><code class="language-bash">#!/bin/bash

# in arguments:
#    inFile outFile dpi bgColor bgOpacity
DPIX="${3%%,*}"  # format - xRes,yRes  
BGCOLOR="$4" # format - string, #xxxxxx, or rgb(r%,g%,b%)  
cairosvg -f png -o "$2" -d "$DPIX" "$1"  
</code></pre>

<p>最后将这个脚本另存、更名、更改可执行权限。</p>

<p>在你使用identify、convert等等工具处理svg时，都将调用上述脚本。所以，现在你可以随意用新的转换工具来替换MSVG了。</p>

<p>我的开源项目<a href="https://github.com/aimingoo/svg-provider">svg-provider</a>是一个较完整的实现，其主要是在参数的处理上面进行了优化，并且可以适配更多的转换工具。</p>]]></content:encoded></item><item><title><![CDATA[Kindle电子书中该用多大的图片]]></title><description><![CDATA[<blockquote>
  <p>注1：本文所涉及的工具，可以采用如下方法安装：</p>
</blockquote>

<pre><code class="language-bash"># 含identify,convert,mogrify,pdfinfo,pdftoppm等
&gt; brew install ghostscript imagemagick cpdf poppler
# 含pdfcrop等
&gt; brew cask install xquartz mactex inkscape
</code></pre>

<blockquote>
  <p>注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。</p>
</blockquote>

<p>如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。</p>

<p>在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。</p>

<p>你最好的选择是：使用一个阅读器不会对它进行缩放的、</p>]]></description><link>http://aimingoo.github.io/1-1726.html/</link><guid isPermaLink="false">5655d162-8a13-48e2-8125-387c794db87a</guid><category><![CDATA[电子书]]></category><category><![CDATA[Kindle]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sat, 03 Jun 2017 10:54:54 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>注1：本文所涉及的工具，可以采用如下方法安装：</p>
</blockquote>

<pre><code class="language-bash"># 含identify,convert,mogrify,pdfinfo,pdftoppm等
&gt; brew install ghostscript imagemagick cpdf poppler
# 含pdfcrop等
&gt; brew cask install xquartz mactex inkscape
</code></pre>

<blockquote>
  <p>注2：本文缺省是使用PNG图片，使用JPG的方法是一致的（有极少数的转换工具不同）。</p>
</blockquote>

<p>如果你总是将一张『足够清晰』的图片缩小到适合Kindle电子书阅读的比例，那么本文中的问题就不是问题：缩小一张普通的图片时，图片质量通常并不会变得更糟。但如果图片中使用了文字，那么麻烦来了：你不知道一张图片中该用多大的文字才能确保图片缩小之后仍然清晰；另外，你也知道的，『线条和文字』在图片缩放操作中总是会有明显的变形。</p>

<p>在Kindle这类电子书中使用『表格』向来是一个巨大的麻烦，其原因就在这里：表格在HTML/Markdown中通常都不友好，而当你决定直接使用图片时，缩放操作对文字和线条又不友好。</p>

<p>你最好的选择是：使用一个阅读器不会对它进行缩放的、确定大小的图片。</p>

<p>那么这样一张图片应该是多大呢？</p>

<h2 id="">阅读器有多大，图片就有多大</h2>

<p>答案如标题所说。只要你确切知道阅读器（的可阅读区）的大小，那么制作相同大小的图片就好了。不过对于Kindle——当然也可能包括别的电子书阅读器来说，这个大小要打个折扣。这是因为Kindle设定图片最大宽高度不得超过大约80%的可阅读区。一旦超过这个大小——该值其实是一个不确定的魔法数值，这在后面会更讲到——那么阅读器就会主动缩小这个图片。</p>

<p>Kindle发行过的一些阅读器的规格主要包括（相关数据<a href="http://socialcompare.com/en/comparison/amazon-kindle-product-line-comparison">在这里</a>，最新近的一些<a href="http://www.toptenreviews.com/mobile/ebook-readers/best-kindle-comparisons/">在这里</a>）：</p>

<style type="text/css">  
.tg  {border-collapse:collapse;border-spacing:0;border-color:#ccc;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#fff;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#ccc;color:#333;background-color:#f0f0f0;}
.tg .tg-yw4l{vertical-align:top}
</style>  

<table class="tg">  
  <tr>
    <th class="tg-yw4l">分辨率</th>
    <th class="tg-yw4l">类型</th>
    <th class="tg-yw4l">Pixel Per Inch</th>
  </tr>
  <tr>
    <td class="tg-yw4l">1024x600</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">169/171 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1280x800</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">149/189/216/252 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1920x1200</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">254/323 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">2560x1600</td>
    <td class="tg-yw4l">ISP LCD</td>
    <td class="tg-yw4l">339 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">800x600</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">167 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1024x758</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">212 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1200x824</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">150 PPI</td>
  </tr>
  <tr>
    <td class="tg-yw4l">1448x1072</td>
    <td class="tg-yw4l">E Ink</td>
    <td class="tg-yw4l">300 PPI</td>
  </tr>
</table>

<p>不仅如此，Kindle还发行过一系列平板的版本（当然使用的是LCD屏而不是电子墨水屏），这些屏幕的规格就更复杂了，例如官方公布的一些规格（<a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/specifications/01-device-and-feature-specifications">在这里</a>）。</p>

<p>综合上面的数据，从实用性的角度来说，我们应该制作宽度小于600*80%左右大小的图片。这条规则在大多数设备上都是适用的——关于这个问题其实是有过广泛的讨论的（例如<a href="https://www.epubble.com/kindle-maximum-image-size/">在这里</a>，以及amazon开发者信息<a href="https://developer.amazon.com/public/solutions/devices/fire-tablets/app-development/01--screen-layout-and-resolution">在这里</a>）。但这个值不但与设备有关，甚至还与不同的Kindle版本有关，以至于有人发布出测试用的电子书，用来确定在不同设备上的适配图片大小（<a href="https://www.epubble.com/wp-content/download/KindleMaximumImageSize.prc">Kindle Maximum Image Size (PRC)</a> ）。</p>

<p>好吧，总之我们是只看结论的对不。那么，这个结论如下：</p>

<blockquote>
  <p>建议你将图片的大小控制在<code>520*622px</code>以内。</p>
</blockquote>

<p>也就是说，图片宽度在520px以内（<code>640*0.8125</code> or <code>600*.87</code>）。</p>

<h2 id="">如何做这样大小的图片</h2>

<p>下面我们来讲『如何做』。</p>

<h3 id="">什么是『这样大小』</h3>

<p>首先确定一下『这样大小』到底是怎样大。</p>

<p>因为我们所谓520px的图片，其实要从像素点换算成印刷用的厘米(cm)、英寸(in)或磅值(pt)，这些看起来麻烦的东西，通常是平面设计师的基本功。</p>

<p>在显示器上的所谓520px，实际含义是『在一个72ppi的设备上显示520pixel』（注3）。这里的PPI是『像素/英寸(Pixel Per Inch)』，这通常用在显示输出类的设备上；更经常的，你可能看到的是用Dots来表示Pixel，就是DPI了（注4）。一般情况下，这两种说法并不需要区分，都称作分辨率(Resolution ratio)、质量/精度/密度(quality/density)——具体到不同场合则是打印分辨率、显示分辨率、图片精度等等，<a href="http://www.uigreat.com/article/131">参见这里</a>）。</p>

<blockquote>
  <p>注3: 对于PPI，Windows系统默认为96， Mac OS系统默认PPI 为72。在使用Macbook Pro的Retina屏时，它的默认值是110。</p>
  
  <p>注4: 注意，我们说宽520px时实际上是在讲一张图片的"Pixel Dimensions（点阵面积）"中x方向的大小，而72dpi/ppi却是指获得（例如扫描设备）或输出（例如显示设备）这个点阵图时的精度。</p>
</blockquote>

<p>我们前面列出Kindel的设备参数时，设备的PPI是很复杂的，从149到339有非常多种；而它们显示具体图像的分辨率，也有800x600 .. 2560x1600等非常多种模式。不考虑其具体映射和实现的细节的话，你可以认为：</p>

<blockquote>
  <p>我们使用300DPI的图片，在多数设备上总是可行的。</p>
</blockquote>

<p>那么：一张<code>520x320px</code>大小的<code>300dpi</code>的图片，到底是怎样大小呢？</p>

<blockquote>
  <p>高度320px是上面所说到的622px的一半略多。这是因为我们在电子书上通常不会把一张图做到全屏大小，而使用以半屏高为上限的图片有利于书籍的自动排版。</p>
</blockquote>

<h3 id="">面积计算</h3>

<p>想知道这个大小，那么只需要在图形制作软件中新建一张图片，设置像素大小（即是Pixel Dimensions）为520x320px，然后设置分辨率为300DPI，就一切OK了——通常这种情况下我们不需要去手工计算。然而如果你在PowerPoint或Keynote里去做类似的事情，就会发现：.ppt中设置页面是使用厘米(cm)，而.key中却是使用磅（pt）。我们的难题之一，便是要做这个转换（以宽520px为例）：</p>

<ul>
<li>520/300*2.54 = 4.4026（厘米）
<ul><li>1英寸 = 2.54厘米</li></ul></li>
</ul>

<p>或者为了避免你总是手工计算，那么查看上面创建的图片的信息也可以（设图片名为test.png）：</p>

<blockquote>
  <p>注意：identify是ImageMagick中的一个工具，在使用<code>brew install imagemagick</code>安装后会同时得到这个命令行工具。</p>
</blockquote>

<pre><code class="language-bash">&gt; identify -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 118.11x118.11
  Print size: 4.40268 x 2.70934
  Units: PixelsPerCentimeter
</code></pre>

<p>注意identify对图片来说缺省单位是厘米（Centimeter），而不是习惯上PPI/DPI中所说的英寸（Inch），所以Resolution显示是118.11（DPCM，Dots Per Centimeter）。如果你想要显示为DPI，那么应该这样：</p>

<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ./test.png | grep -E 'Units:|Resolution|Print'
  Resolution: 300x300
  Print size: 1.73333 x 1.06667
  Units: PixelsPerInch
</code></pre>

<h2 id="pptkeynote">在ppt或keynote上实作</h2>

<p>我们具体使用ppt/key的时候，其实会比上面的520x320px要略大一点，然后使用参考线来辅助作图。这是为了在ppt/key中具体画图时边界上留一点余量，便于操作。具体来说，我推荐的是使用：</p>

<ul>
<li>在.ppt中设置页面大小为<code>4.8x3.5</code>cm，或</li>
<li>在.key中设置页面大小为<code>136x99</code>pt</li>
</ul>

<p>接下来在PPT中设置两三条辅助线（以PPT为例，你可以下载这个模板<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.ppt">PPT格式</a>或<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.key">Keynote格式</a>）：</p>

<ul>
<li>右、左侧2.14cm各一条</li>
<li>右侧2.26cm一条</li>
</ul>

<p>如下图所示：</p>

<p><img src="http://aimingoo.github.io/content/images/2017/06/standard_image_templet_520.png" alt="standard_image_templet_520"></p>

<p>我们通常作图时让内容保持在正中间的<code>2.14*2</code>的范围内即可，当右侧使用到极限时会是<code>2.14+2.26cm</code>，亦即是全宽520px。同时，如果是4磅大小的文字，单行可以容纳30~31个（如图）。我建议采用4磅文字，其下限是3.5磅。</p>

<p>最后，当你在上面的页面上完成图、表之后，如果你使用PPT，那么可以直接在图形上鼠标右键，选『另存为图片』，然后选PDF（注4）；如果你使用Keynote，请在文件菜单中选『导出』，仍然也是选PDF。</p>

<blockquote>
  <p>强烈说明：注意这里要用PDF！</p>
</blockquote>

<p>接下来，你在Macbook中的『预览（Preview）』工具中打开上述PDF文件，再选导出到PNG，并设置分辨率为300 dpi。即可。</p>

<p>我们验证一下这样得到的一个.png的信息（注5）：</p>

<pre><code class="language-bash">&gt; identify -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 118.11x118.11  ## 如果使用-units PixelsPerInch，则这里为300DPI
  Print size: 4.51274x1.61714
  Units: PixelsPerCentimeter
</code></pre>

<blockquote>
  <p>注4: 我们后面将使用在PPT中选中图形导出的这个PDF（命名为ppt533.pdf），以及转换后的图片（ppt533.png）。稍后我们会讲述Keynote中的处理方法。此外，如果你在PPT绘制了很多东西，那么建议你先建个组(Group)再导出它们。</p>
  
  <p>注5: 你会注意到这个宽度不是预期的520px。这是因为PPT选中图形导出时会默认添加边框，所以如果你只使用模板中间的安全部分，那么上述方法总是安全的；否则你需要使用crop工具去切掉周边的空白区。关于这个部分的内容，我们在下面还会讲到。</p>
</blockquote>

<h3 id="pdfpng">理解PDF与PNG文件大小之间的关系</h3>

<p>为了讨论这个问题，我们再检查一下上面生成的PDF文件：</p>

<pre><code class="language-bash">&gt; identify -verbose ./ppt533.pdf | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 128x46+0+0
  Resolution: 72x72
  Print size: 1.77778x0.638889
  Units: Undefined
</code></pre>

<p>你会注意到PDF文件中<code>Units</code>值是没有的。这是PDF格式特殊的地方，事实上在它的文件格式中并没有包含Resolution、Print size和Units的信息——上面由identify得到的信息是计算出来的，而不是文件中的元数据信息。更具体地说，PDF是约定了默认使用72x72DPI的分辨率（所以Identify也直接在默认时使用了Inch作为单位，与图片的默认值不同），而且它是使用Points（磅值/点）来表明大小。那么显而易见的，上述的Print Size是简单地通过<code>128/72</code>就可以得来了——PDF默认采用72x72的DPI原因，也正在于磅值与英寸的换算关系就是<code>72:1</code>（关于这一点，请参见<a href="http://www.cnblogs.com/stronghorse/p/4913346.html">老马的文章</a>）。</p>

<p>所以现在你可以得到两个与大小相关的信息，一个是宽高信息(Pts)，也称为页面大小(Page Size)，另一个是可推算出来的打印面积(inch)。而在从PDF转换到PNG图片的过程中，通常就以这个转换后的打印面积来作为图片物理大小。</p>

<p>接下来我们来逆推一下一张300DPI的PNG图片该是怎样的。如果这张图片是如上的1.77778宽度，并且由于DPI设定是300，那么显然图片在x方向的点阵大小（pixels）应该就是<code>300*1.77778=533px</code>。具体来看上面这张通过『预览』工具导出的<code>ppt533.png</code>，它的信息就是这样：</p>

<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ./ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x191+0+0
  Resolution: 300x300
  Print size: 1.77667x0.636667
  Units: PixelsPerInch
</code></pre>

<p>也就是说：在转换过程中，通常是保证<code>Print size</code>大小不变。</p>

<h3 id="ghostscriptdpi">在GhostScript中对DPI的一点不同理解</h3>

<p>如果你不想直接使用『预览』工具来导出，那么你可以为它建立一个automator任务或服务——这样就可以在命令行上使用了。或者，你也可以尝试使用GhostScript（也就是gs）这个命令行工具。</p>

<p>但是如果你使用GhostScript来将PDF转换成PNG，那么缺省情况下它是将Points直接对应地转换为Pixels的——也就是将PDF中的一个打印点，转换为图片中的一个像素点。因此假使你不使用设置分辨率的<code>-r</code>参数，那么你就将直接转换得到一个<code>128x46 pixels, 72DPI</code>的图片。</p>

<pre><code class="language-bash"># (下面这个结果显然不是你想要的)
&gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -sOutputFile=128px.png ppt533.pdf
</code></pre>

<p>更进一步，如果使用<code>-r 300</code>来指定300DPI输出，那么图片要有533 px的宽度（这个我们上面已经计算过了），而原始的PDF只有128 pts的宽度。所以这时，你将会得到一个低质量的、从128放大到533的图片。</p>

<p>如果你需要用gs来转换pdf到png，那么你应该先放大这个pdf到合适的宽高大小，然后再输出。下面是其中一种可能的方案：</p>

<pre><code class="language-bash"># 先放大300/72=4.1667倍
#    - 也可以使用另一个开源工具pdfScale
#    - 目的是使pts与我们要得到的图片pixels点数对应，以确保图片质量足够
&gt; cpdf -scale-page "4.1667 4.1667" -scale-to-fit-scale 4.1667 -o 300dpi.pdf ppt533.pdf
# 再转换得到300DPI的图片
&gt; gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=png16m -r300 -sOutputFile=300dpi.png 300dpi.pdf
# 再reszie图片
#    - 转换成png时Page Size大小将保持不变，因此需要按72/300为比例换回去
&gt; convert 300dpi.png -resize 24% ppt533.png
</code></pre>

<p>现在我们再来看看这张图片：</p>

<pre><code class="language-bash">&gt; identify -units PixelsPerInch -verbose ppt533.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 533x192+0+0
  Resolution: 300x300
  Print size: 1.77667x0.64
  Units: PixelsPerInch
</code></pre>

<p>虽然这个过程是能得到符合我们要求的图片，但的确过于复杂。我们后面将介绍一些其它不使用GhostScript的方法。</p>

<h2 id="pdf">使用导出PDF文件的方法来得到图片的一些问题</h2>

<h3 id="1pdf">1) 成批导出与转换PDF文件</h3>

<p>如果总是在PowerPoint中将图形对象选中然后右键导出成PDF，那么在成批处理时就会比较繁琐；另外，在Keynote中根本就没有这个操作。所以事实上我们一般还是会将整个的PPT/Keynote文件另存、导出为.PDF文件。这样的文件称为多页PDF——很显然地，因为我们见到的大多数PDF文件都是多页的，并且它们的页面大小是一致的。</p>

<p>然而事实上我们要处理的每张PNG图片都可能大小不同，因为在PPT/Keynote中实际作图的有效区并不一样大。你可以选择将PDF从多页转换成一批单页，或者寻找能直接处理多页PDF的工具。——不幸的是，一些情况下后面这类工具并不太容易得到。</p>

<p>所以如果你真的需要先转换成单页PDF，那么我建议你使用pdfseparate这个工具，它包含在poppler这个工具包中。用法如下：</p>

<pre><code class="language-bash"># 第二个参数是文件名模板，必须包含'%d'来作页码的占位符
#    - 目标文件的目录必须先创建(例如本例中的extract)
&gt; mkdir ./extract
&gt; pdfseparate your.pdf './extract/page%d.pdf'
</code></pre>

<h3 id="2">2) 要切掉空白</h3>

<p>在转换到图片之前，我们还得先留意一下这个.pdf外围的空白区。</p>

<p>在上例中，如果你在Keynote中导出.pdf，或者在PowerPoint中导出页面（而不是选中图形导出），那么你将导出的是整个页。我们上面说过，为了制作方便，我们的整个页其实要略大一些，而只有参考线中间部分的图形是在电子书中有效的。</p>

<p>那么我们其实需要的是自动切掉图形外围的空白区(trim/crop)——在不同的软件中，可能是这两种功能之一。你可以选择处理最终生成的.png图片，这可以仍然使用上述ImageMagick套件中的convert（你安装之后在命令行中就有了），也可以早先做一步，对.pdf进行trim/crop操作。</p>

<p>这可以使用一个非常著名（而且名实相符）的软件，叫pdfcrop。它是perl脚本，可以你可以直接从官方下载（<a href="https://sourceforge.net/projects/pdfcrop/files/">例如这里</a>），或者安装一个TeX套件包内含（使用<code>brew cask install mactex</code>）。使用起来也很简单：</p>

<pre><code class="language-bash"># Usage: pdfcrop &lt;input[.pdf]&gt; [output file]
&gt; pdfcrop xxx-300dpi.pdf croped.pdf
</code></pre>

<p>如果省略output参数，则它以input文件名自动生成<code>-crop.pdf</code>后缀的文件。</p>

<p>另一个相对来说也很可靠的工具叫pdfCropMargins，它可选的参数也更多。比如：</p>

<pre><code class="language-bash"># pdfCropMargins可选使用Ghostscript或pdftoppm作为将pdf渲染为图片的工具
#  - 参数-gsr表明使用Ghostscript（缺省是pdftoppm）, 参数-gsp表明gs可执行文件的路径
#  - 参数-p/-p4来指定relative original margin模式的边距
#   * 可以用-a/-a4指定边距的absolute offset值
#   * 参数-ap/-ap4是在剪切前计算最终页面大小时使用的(p是指preCrop)
#   * 参数-m/-mp是用在uniform模式下指定边距，并隐式地打开该模式(或显式使用-u参数)
&gt; pdf-crop-margins -p 0 -gsr -gsp /usr/local/bin/gs -o croped.pdf your.pdf
</code></pre>

<p>pdfCropMargins与pdfcrop都有resolution参数：</p>

<ul>
<li>在pdfcrop中是<code>--resolution</code></li>
<li>在pdfCropMargins中则是<code>-x/-y</code>，或<code>--xRes/--yRes</code></li>
</ul>

<p>这个参数是用在将PDF渲染成图片时提高图片精度的。因为这两个工具实际上都是先将PDF渲染成图片，然后根据图片来查找margins的，所以提高这一精度就意味着查找margins更准确。但这个参数并不会影响转换后的PDF的质量。</p>

<p>其它：</p>

<ul>
<li>在pdfcrop中建议打开<code>--hires</code>以提高crop的质量，这种情况下margin计算更精确
<ul><li>在pdfCropMargins中的参数<code>-ap/-ap4</code>正好相反，较不精确但速度更快</li></ul></li>
<li>使用较低的resolution值速度更快，这与内部将pdf转为图片时的速度效率有关
<ul><li>pdfcrop缺省的resolution值为72dpi，而pdfCropMargins缺省为150dpi</li></ul></li>
<li>在pdfCropMargins中缺省使用的pdftoppm会比gs引擎要慢一点</li>
<li>在pdfcrop中指定TeX引擎为<code>--xetex</code>时，crop运算的效果常常会出错</li>
</ul>

<h3 id="3pdfpng">3) PDF转换到PNG图片时的工具选择</h3>

<p>无论PDF是否经过crop，你最终都只是想得到图片，所以这最后一步尤其重要。</p>

<p>切记要给转换软件指定300dpi的输出精度——如上所述，我们是按这个精度来设计的图片大小。除了『预览』这个软件之外，能指定转换精度的软件看起来不少，但大多数并不合用（注意gs是可用的，但并不方便，这在之前我们已经专门讲过了）。例如下面这几个：</p>

<pre><code class="language-bash"># 使用inkscape
#   - 只能处理单页pdf，可能会因字体不匹配而出现字体异常；效果好于gs，且能将dpi置为300
&gt; inkscape --without-gui --export-dpi=300 --export-png='300dpi.png' croped-p1.pdf

# 使用ImageMagick中的convert
#   - convert的density用于指定源pdf为300dpi, 而输出的png其实总是72dpi
#   - 只能处理单页pdf，但视觉效果好于gs(也好于gs的DEVICE=pnggray)
&gt; convert -density 300 croped-p1.pdf -background white -flatten 'error-dpi.png'

# 使用pdf2png
#    - Github: https://github.com/kaorukobo/pdf2png-mac
#    - 能逐页处理，但输出png的精度受xcode中的组件影响(缺省是144dpi)
#    - 参数--dpi是用于指定源pdf的dpi值的
&gt; pdf2png --dpi 300 --page 1 --output '144dpi.png' croped.pdf
</code></pre>

<p>事实上所有这类软件都是将源PDF理解为72dpi，所以针对源来指定的Resolution值其实是用于建立一个缩放工厂（scaleFactor），以便得到等同于指定DPI大小的图像。而不同的软件的区别仅在于是否能在输出PNG时，有效的指定png图片的dpi——例如pdf2png是基于xcode的NSMakeRect()，而该组件默认精度在retina screens上就是144dpi。</p>

<p>所以请仔细review这个过程，其实完全等同于『在GhostScript中对DPI的一点不同理解』小节中所讲述的：1. 先放大PDF；2. 渲染成PNG到指定精度；3. 缩小PNG到指定大小。</p>

<h3 id="4">4) 一步到位</h3>

<p>如果你希望一步到位地解决上述问题，那么我目前只有一个工具推荐：</p>

<blockquote>
  <p>注：nconvert是<strong>xnview</strong>提供的一个非商用免费工具，<a href="http://www.xnview.com/en/nconvert/">下载在这里</a></p>
</blockquote>

<pre><code class="language-bash"># 用ncovert将croped.pdf转换到png
&gt; nconvert -xall -dpi 300 -out png -o pic croped.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
Conversion of croped.pdf into pic-1.png OK  
Conversion of croped.pdf into pic-2.png OK  
...

# 或者不对original.pdf做crop操作，而是直接在nconvert中转换并autocrop图像
#    - autocrop参数格式为"tol r g b"，其中tol是容错值，rgb为crop掉的颜色
&gt; nconvert -xall -dpi 300 -out png -o pic -autocrop 0 255 255 255 original.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
...
</code></pre>

<p>所以，本文中的模板所导出的PDF(<a href="http://aimingoo.github.io/content/images/attachments/standard_image_templet_520.pdf">在这里</a>)转换成png所采用的方法就是如下：</p>

<pre><code class="language-bash"># 在PowerPoint/Keynote中将ppt导出成.pdf，然后
#    - nconvert是从0页开始对pdf计数的
&gt; nconvert -page 0 -dpi 300 -out png -autocrop 0 255 255 255 standard_image_templet_520.pdf 1&gt;/dev/null
Conversion of standard_image_templet_520.pdf into standard_image_templet_520.png OK

# 查看png文件的信息(现在就真的是520px宽+300DPI了)
&gt; identify -units PixelsPerInch -verbose standard_image_templet_520.png | grep -E 'Units:|Resolution|Print|Geometry'
  Geometry: 520x306+0+0
  Resolution: 300x300
  Print size: 1.73333x1.02
  Units: PixelsPerInch
</code></pre>

<p>最后需要补充一点：就效果来说，基于图像autocrop与pdfcrop并没有太大的差别——反正我是分不出来。另外，你也可能想尝试使用imagemagick中的trim操作来替代autocrop：</p>

<pre><code class="language-bash"># 使用nconvert但不autocrop
&gt; nconvert -xall -dpi 300 -out png -o pic original.pdf 1&gt;/dev/null
Conversion of croped.pdf into pic-0.png OK  
...

# 使用imagemagick中的mogrify工具, -fuzz 0%与autocrop中的tol参数类似
&gt; find . -name 'pic-*.png' | xargs -n1 mogrify -fuzz 0% -trim +repage
</code></pre>]]></content:encoded></item><item><title><![CDATA[手记6：改造Gitment]]></title><description><![CDATA[<blockquote>
  <p>本文所述的修改请参考我Fork的Gitment项目：<a href="https://github.com/aimingoo/gitment">Giment at aimingoo's project space</a></p>
</blockquote>

<p>接下来我们要大力修改Gitment，打造一个『好用那么一点点儿』的博客评论。</p>

<h2 id="11gitment">11. 改造Gitment</h2>

<p>折腾到现在，我们有了一个在Github pages上的博客，以及一个用来写本地博客的Ghost，以及一些相关的工具，例如<code>makesite.sh</code>（<a href="https://github.com/aimingoo/ghost-utils">在这里</a>）。</p>

<p>最后，我们还有了一个第三方提供的支持PHP+HTTPs的空间，这个空间只用来放Gitment的服务端，并且这个服务器事实上也只做一下API的CORS转发而已。</p>

<blockquote>
  <p>注：你可能已经留意到我并没有告诉大家『到底哪个免费主页空间支持PHP+HTTPS』啊。是的，我刻意隐藏了这个信息，以免文章公开后导致滥用。我最终使用的这个主页空间……老实说，是相当相当不错的了，能给的人家都给了。所以真不忍心被那些挂马的搞死。所以能藏着就藏着吧，如果你想要申请它的话，你直接在我的网站的源码中去找找就好了。</p>
</blockquote>

<p>所以接下来，我开始改造Gitment，再一次强调，Gitment真正是个相当NB的项目。我fork了一个版本出来，修改版的在这里：<a href="https://github.com/aimingoo/gitment">Giment updates</a></p>]]></description><link>http://aimingoo.github.io/1-1725.html/</link><guid isPermaLink="false">eaab0e82-64c5-4cbb-a31d-64ae617b936b</guid><category><![CDATA[博客]]></category><category><![CDATA[Gitment]]></category><category><![CDATA[Javascript]]></category><category><![CDATA[OpenSource Project]]></category><category><![CDATA[Github]]></category><category><![CDATA[前端开发]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Wed, 31 May 2017 16:46:14 GMT</pubDate><content:encoded><![CDATA[<blockquote>
  <p>本文所述的修改请参考我Fork的Gitment项目：<a href="https://github.com/aimingoo/gitment">Giment at aimingoo's project space</a></p>
</blockquote>

<p>接下来我们要大力修改Gitment，打造一个『好用那么一点点儿』的博客评论。</p>

<h2 id="11gitment">11. 改造Gitment</h2>

<p>折腾到现在，我们有了一个在Github pages上的博客，以及一个用来写本地博客的Ghost，以及一些相关的工具，例如<code>makesite.sh</code>（<a href="https://github.com/aimingoo/ghost-utils">在这里</a>）。</p>

<p>最后，我们还有了一个第三方提供的支持PHP+HTTPs的空间，这个空间只用来放Gitment的服务端，并且这个服务器事实上也只做一下API的CORS转发而已。</p>

<blockquote>
  <p>注：你可能已经留意到我并没有告诉大家『到底哪个免费主页空间支持PHP+HTTPS』啊。是的，我刻意隐藏了这个信息，以免文章公开后导致滥用。我最终使用的这个主页空间……老实说，是相当相当不错的了，能给的人家都给了。所以真不忍心被那些挂马的搞死。所以能藏着就藏着吧，如果你想要申请它的话，你直接在我的网站的源码中去找找就好了。</p>
</blockquote>

<p>所以接下来，我开始改造Gitment，再一次强调，Gitment真正是个相当NB的项目。我fork了一个版本出来，修改版的在这里：<a href="https://github.com/aimingoo/gitment">Giment updates by aimingoo</a></p>

<h3 id="111httphttpsgithubpages">11.1 更有效地支持HTTP/HTTPS的Github Pages</h3>

<p>我们前面说过Github pages也分别支持HTTP和HTTPS两种协议，如果你有幸得到一个HTTP的Github pages site——真的很有幸了，得是以前创建的仓库，新仓库已经没有这个选择了——那么，你仍然可以将intersect（<a href="https://github.com/aimingoo/intersect">在这里</a>）部署在一个仅支持HTTP的Web站点上。</p>

<p>也就是说，只能选择Github pages和intersect同时支持HTTPS，或者反过来选择同时不支持。有趣的是，在Github pages使用HTTP的情况下，Github<strong>同时</strong>也允许访问者通过HTTPS协议来访问你的主页。这样一来就带来了一个问题：在你的Github oAuth Application后台配置中，你只能设置一个callback地址。</p>

<p>所以我在Gitment中加了一个名为<code>force_redirect_protocol</code>的选择，它会在调用</p>

<blockquote>
  <p><a href="https://github.com/login/oauth/authorize">https://github.com/login/oauth/authorize</a></p>
</blockquote>

<p>时强制redirect_uri参数使用与Github oAuth Application后台配置一致的值，这样才能在HTTPS/HTTP网站上同时通过authorize验证，并且最后总是使用redirect_uri所设置的协议下的地址。</p>

<pre><code class="language-javascript">// Update (Getment Proj)/src/gitment.js

// Github setting of 'Authorization callback URL' in your OAuth application
const force_redirect_protocol = 'https'  
...

class Gitment {  
  ...
  get loginLink() {
    const oauthUri = 'https://github.com/login/oauth/authorize'
    const redirect_uri = this.oauth.redirect_uri || window.location.href.replace(/^https?/i, force_redirect_protocol);
    ...
</code></pre>

<h3 id="112gitmentintersect">11.2 使Gitment支持intersect</h3>

<p>intersect这个PHP项目（<a href="https://github.com/aimingoo/intersect">在这里</a>）并没有完全地实现API Geteway特性。比如说，当它转发一个POST请求时，如果你需要添加新的数据到Request，那么就需要根据POST data的不同类型（Content-Type）来决定如何修改：在JSON中添加一个字段，或在不同的encode data中添加一个数据等等；并且还要正确的修改Content-Length。</p>

<p>所以考虑到简单，intersect只支持在GET请求中，或在使用form-urlencoded协议的POST请求中添加数据。例如我们要追加client_secret这个参数并传送到后端，那么就该选用POST协议。</p>

<p>考虑到Gitment实现XHR请求时的特殊性（它专门实现了一个ajaxFactory），我在修改Gitment项目时更要求：</p>

<blockquote>
  <p>如果使用POST方法，并强制要求使用form-urlencoded协议，那么应该在<code>http.post()</code>方法中传入字符串格式的data，而不能传入对象。</p>
</blockquote>

<p>接下来的实现就比较简单了（修改utils.js中的Ajax接口）：</p>

<pre><code class="language-javascript">// Update (Getment Proj)/src/utils.js, es6 syntax

function ajaxFactory(method) {  
  ...
  // 在accept头中加上form-urlencoded支持
  req.setRequestHeader('Accept', '..., application/x-www-form-urlencoded')

  // 在Response数据的解码中支持form-urlencoded
  req.addEventListener('load', () =&gt; {
    ...
    if (/urlencoded/.test(contentType)) {
       data = req.responseText ? Query.parse(res) : {}
       ...

  // 强制Requestr的POST协议对string data使用form-urlencoded
  if (method !== 'GET' &amp;&amp; method !== 'DELETE') {
    if (isString(data)) {
      body = data
      req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    ...
</code></pre>

<p>第二步（修改Gitment.js）：</p>

<pre><code class="language-javascript">// Update (Getment Proj)/src/gitment.js, es6 syntax

class Gitment {  
  constructor(options = {}) {
    ...
    const { client_id, client_secret, proxy_gateway } = this.oauth

    ...
    var login = !proxy_gateway
      ? http.post('https://gh-oauth.imsun.net', {code, client_id, client_secret}, '')
      : http.post('/login/oauth/access_token', `code=${code}&amp;client_id=${client_id}`, proxy_gateway);

    login.then(data =&gt; {
      this.accessToken = data.access_token
      ...
</code></pre>

<p>第三步（Gitment创建时Options）：</p>

<pre><code class="language-javascript">// 现在在Gitment创建时的Options中就可以使用proxy_gateway选项了
//    - 保持了与旧的client_secert的兼容，二选一配置即可
const gitment = new Gitment({  
  id: 'Your page ID', // optional
  owner: 'Your GitHub ID',
  repo: 'The repo to store comments',
  oauth: {
    client_id: 'Your client ID',
    proxy_gateway: 'https://your_intersect_gateway'
    // client_secret: 'Your client secret, either this or proxy_gateway',
  },
  // ...
  // For more available options, check out the documentation below
})
</code></pre>

<h3 id="113">11.3 多语言支持</h3>

<p>Gitment的作者没有提供多语言支持是觉得『不必要』，因为Github的用户要是这几个单词也不认得大概就只能回家卖烤红薯了。但我的问题在于，我打算做一个多人博客，所以博客的读者还真有不少与Github无关。</p>

<p>所以，我得需要一个多语言支持。</p>

<p>简单的做法，就是写一个这样的translator：</p>

<pre><code class="language-javascript">// save as (Getment Proj)/src/translator.js
export function english(Text) {  
    return Text;
}

export function chinese(Text) {  
    return ({
        'Issue Page': '所有评论',
        'Initialize Comments': '初始化本文的评论页',
        ...
    }[Text]||Text);
}

export default english;  
</code></pre>

<p>这里用的都是ES6的语法。这几个简单的export说明当前模块导出了<code>english/chinese</code>等等名字，是用来作为提供多语言支持的翻译函数——在不同语言的函数中添加对照表来支持更多的内容。</p>

<p>使用的时候也挺简单的，在Gitment的<code>src/theme/default.js</code>模块中将它装载进来：</p>

<pre><code class="language-javascript">// 注：如果使用英文(不翻译)，那么以下两种导入方法是等效的
//    import { english as $ } from '../translator'
//  import $ from '../translator'
import { chinese as $ } from '../translator'  
...
</code></pre>

<p>然后在需要多语言的地方使用下面的代码即可：</p>

<pre><code class="language-javascript">// 例如，原始代码
//    issueLink.innerText = 'Issue Page'
// 改成：
issueLink.innerText = $('Issue Page')  
</code></pre>

<p>一处处地找到，改完就Ok啦。</p>

<blockquote>
  <p>注意：Gitment使用了ES6的语法，所以有些地方是用ES6的模板字符串的，这些地方要使用类似${$('english text')} 这样的方法来转换。</p>
</blockquote>]]></content:encoded></item><item><title><![CDATA[博客迁移手记之快速导航]]></title><description><![CDATA[<p>本来没想把《博客迁移手记》写得这么长这么多，所以写了这么久之后再来看，博客的标题感觉就很Low了。</p>

<p>于是决定给这一组《博客迁移手记（1~n）》写个导航，也算整理一下思路。</p>

<h2 id="">快速导航</h2>

<p>博客迁移手记（一）</p>

<ul>
<li>使用BlogToWordpress迁移你的博客</li>
<li>使用本地博客Ghost的快速指南与导入工具</li>
</ul>

<p>博客迁移手记（二）</p>

<ul>
<li>从本地博客到Github Pages的最佳指南</li>
<li>makesite.sh使用手册</li>
</ul>

<p>博客迁移手记（三）</p>

<ul>
<li>以kaldorei为例详解Ghost Theme的定制</li>
<li>Ghost中文章置顶的实现方法</li>
<li>如何最大程度地静态化Ghost博客</li>
</ul>

<p>博客迁移手记（四）</p>

<ul>
<li>Gitment大坑：谈谈secret泄露的前因后果</li>
</ul>

<p>博客迁移手记（五）</p>

<ul>
<li>如何获得一个支持HTTPS的免费空间</li>
</ul>

<p>博客迁移手记（六）</p>

<ul>
<li>用intersect来做Gitment的API网关</li>
<li>Gitment的一些Bug修复与补强</li>
<li>Gitment的简单多语言支持</li>
</ul>

<h2 id="">其它：</h2>

<blockquote>
  <ul>
  <li><p>我最终改掉了这组博客文章的标题。</p></li>
  <li><p>这充分说明使用短标题是正确的。</p></li>
  </ul>
</blockquote>]]></description><link>http://aimingoo.github.io/1-1724.html/</link><guid isPermaLink="false">b9502886-b86f-4f2e-b8c1-ee5f4a67f92e</guid><category><![CDATA[博客]]></category><category><![CDATA[Gitment]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 30 May 2017 07:48:53 GMT</pubDate><content:encoded><![CDATA[<p>本来没想把《博客迁移手记》写得这么长这么多，所以写了这么久之后再来看，博客的标题感觉就很Low了。</p>

<p>于是决定给这一组《博客迁移手记（1~n）》写个导航，也算整理一下思路。</p>

<h2 id="">快速导航</h2>

<p>博客迁移手记（一）</p>

<ul>
<li>使用BlogToWordpress迁移你的博客</li>
<li>使用本地博客Ghost的快速指南与导入工具</li>
</ul>

<p>博客迁移手记（二）</p>

<ul>
<li>从本地博客到Github Pages的最佳指南</li>
<li>makesite.sh使用手册</li>
</ul>

<p>博客迁移手记（三）</p>

<ul>
<li>以kaldorei为例详解Ghost Theme的定制</li>
<li>Ghost中文章置顶的实现方法</li>
<li>如何最大程度地静态化Ghost博客</li>
</ul>

<p>博客迁移手记（四）</p>

<ul>
<li>Gitment大坑：谈谈secret泄露的前因后果</li>
</ul>

<p>博客迁移手记（五）</p>

<ul>
<li>如何获得一个支持HTTPS的免费空间</li>
</ul>

<p>博客迁移手记（六）</p>

<ul>
<li>用intersect来做Gitment的API网关</li>
<li>Gitment的一些Bug修复与补强</li>
<li>Gitment的简单多语言支持</li>
</ul>

<h2 id="">其它：</h2>

<blockquote>
  <ul>
  <li><p>我最终改掉了这组博客文章的标题。</p></li>
  <li><p>这充分说明使用短标题是正确的。</p></li>
  </ul>
</blockquote>]]></content:encoded></item><item><title><![CDATA[手记5：如何获得一个支持HTTPS的免费空间]]></title><description><![CDATA[<p>下面我们讲的内容其实与Gitment没什么关系。如果你已经有了支持https的空间那就跳过去，如果没有的话，建议还是看看好的伐。</p>

<h2 id="10https">10. 让免费主页空间支持HTTPS</h2>

<blockquote>
  <p>好象我们把问题搞得复杂了：本来我是想做个静态主页的博客网站，现在我却需要找个支持PHP+SSL的动态主页空间？</p>
  
  <p>好吧。没关系。反正我闲着在养病，不做点啥岂不是辜负了时光。</p>
</blockquote>

<p>免费主页空间其实挺好找的，尽管要找到一个有长期信誉的并不太容易。即使如此，当你得到这样一个免费空间之后，它多数也是不支持https的。</p>

<h3 id="101https">10.1 你的主页空间是不是支持HTTPS？</h3>

<p>好吧，确实有很多免费空间『声称』它支持https了。这种情况下它通常会给你用通用工具生成一个自主颁发的ssl凭证——而这个凭证是不受主流浏览器信任的。也就是说，在访问这样的一个网站时，你的浏览器地址栏会是这样：</p>

<blockquote>
  <p>（我很好奇为什么12306到现在仍然是这样，难道他们也得不到一个有效的ssl凭证吗？）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/browser_12306_cn.png" alt="browser_12306_cn"></p>

<p>免费主页空间缺省情况下给你颁发的就是这样一种自主签名的SSL（能通过验证，却不被浏览器环境信任），又或者你的空间根本还不支持ssl/https。这个需要你到主页空间的后台去找一个名为SSL的管理功能，通常它会列举三个信息：</p>

<ul>
<li>Private Key，私钥，它通常与下面的CSR是成对的。
<ul><li>CSR，证书验证请求（Cerificate Signing Request）。</li></ul></li>
<li>Certificate，</li></ul>]]></description><link>http://aimingoo.github.io/1-1723.html/</link><guid isPermaLink="false">fa7313be-e458-4280-8739-ab40307afcd0</guid><category><![CDATA[博客]]></category><category><![CDATA[SSL]]></category><category><![CDATA[HTTPS]]></category><category><![CDATA[免费空间]]></category><category><![CDATA[证书]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 30 May 2017 07:25:00 GMT</pubDate><content:encoded><![CDATA[<p>下面我们讲的内容其实与Gitment没什么关系。如果你已经有了支持https的空间那就跳过去，如果没有的话，建议还是看看好的伐。</p>

<h2 id="10https">10. 让免费主页空间支持HTTPS</h2>

<blockquote>
  <p>好象我们把问题搞得复杂了：本来我是想做个静态主页的博客网站，现在我却需要找个支持PHP+SSL的动态主页空间？</p>
  
  <p>好吧。没关系。反正我闲着在养病，不做点啥岂不是辜负了时光。</p>
</blockquote>

<p>免费主页空间其实挺好找的，尽管要找到一个有长期信誉的并不太容易。即使如此，当你得到这样一个免费空间之后，它多数也是不支持https的。</p>

<h3 id="101https">10.1 你的主页空间是不是支持HTTPS？</h3>

<p>好吧，确实有很多免费空间『声称』它支持https了。这种情况下它通常会给你用通用工具生成一个自主颁发的ssl凭证——而这个凭证是不受主流浏览器信任的。也就是说，在访问这样的一个网站时，你的浏览器地址栏会是这样：</p>

<blockquote>
  <p>（我很好奇为什么12306到现在仍然是这样，难道他们也得不到一个有效的ssl凭证吗？）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/browser_12306_cn.png" alt="browser_12306_cn"></p>

<p>免费主页空间缺省情况下给你颁发的就是这样一种自主签名的SSL（能通过验证，却不被浏览器环境信任），又或者你的空间根本还不支持ssl/https。这个需要你到主页空间的后台去找一个名为SSL的管理功能，通常它会列举三个信息：</p>

<ul>
<li>Private Key，私钥，它通常与下面的CSR是成对的。
<ul><li>CSR，证书验证请求（Cerificate Signing Request）。</li></ul></li>
<li>Certificate，验证信息。</li>
</ul>

<p>简单的逻辑是：</p>

<ul>
<li>假设你先有了一个私钥（Private Key），然后</li>
<li>你用私钥对一些『要验证的信息』加密，生成了一个验证请求（CSR），最后</li>
<li>你要找一个有公信力的机构来证明CSR是你的；如果验证通过他就给你发一份Certificate。</li>
</ul>

<p>你最后从『公信力机构』拿到的这个Certificate就是SSL凭证。——找到你的免费空间后台管理中的Certificate填进去，OK，你的网站就支持<code>https</code>了。</p>

<blockquote>
  <p>当然这其中还有很多的细节，比如免费空间服务商怎么把你的Certificate装到Web服务器上面去等等等等。不过除非你是要搞台云主机自己来架服务器，这些就先不要了解了吧。</p>
</blockquote>

<h3 id="102certificate">10.2 两种获得Certificate的方法</h3>

<p>这三个信息有两种方式来获得。</p>

<ul>
<li>一种是你的免费空间提供商为你生成Private Key/CSR这一对信息，然后你将其中的CSR提交给『公信力机构』，后者给你发Certificate文本。</li>
</ul>

<p>所以这种情况下你看到免费空间后台管理的SSL配置中会有一个『Generate Key/CSR』按钮，按一下就得到了前面信息了——如果只能填入而不能Generate，那么你也可以自己做，例如在MacOSX中的工具keytool或OpenSSL（<a href="https://faq.xiaoz.me/archives/100.html">参考这里</a>，或<a href="https://onlinehelp.tableau.com/current/server/zh-cn/ssl_cert_create.htm">这里</a>）。与之对应的，在『公信力机构』的证书申请流程中会有一个类似这样的提示：</p>

<p><img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-provide_your_csr.png" alt="ssl_step-provide_your_csr"></p>

<ul>
<li>另一种是『公信力机构』一次性地为你把上述三步全做了——他不需要你提供CSR，而是为你生成一个Private Key，然后自己生成CSR、完成验证并最后把Private Key交还给你。例如阿里云为你提供的验证服务就是这样（它后台用的是Symantec的免费DV服务）。这种情况下，你就需要将其中的Private Key交给免费空间提供商了——所以你的免费空间后台管理的SSL配置中，通常在『Generate Key/CSR』按钮旁边，就还会有一个『Upload Key』的功能，这个Key，指的就是Private Key。</li>
</ul>

<p>好了。简单地汇总一下上面的信息：</p>

<ol>
<li>找一个『公信力机构』，让他证明你的网站是你的；  </li>
<li>如果他要CSR，你就给他；如果他不要CSR，那么他应该给你Private Key。</li>
</ol>

<p>当然，如果你的主页空间不给你提供ssl功能（没有地方让你提交『公信力机构』验证过的Certificate），那么——换一家吧。</p>

<h3 id="103">10.3 怎么证明『你的网站是你的』</h3>

<p>所谓的『公信力机构』要颁发SSL签证，其实是想说明『因为这个网站你是你的，所以我发了这个证明给你』。因此无论如何，这个机构也要有办法来证明『你的网站是你的』，而不仅仅是因为你提交了CSR申请。</p>

<p>所以一旦你申请了，那么你就要为接下来的验证工作做准备，而这取决于不同的『公信力机构』采用的验证方法。下面举三种例子。</p>

<h4 id="1031symantec">10.3.1 阿里云或Symantec的签证</h4>

<p>阿里云可以为你的网站提供1年的免费SSL签证，它的这项服务是通过Symantec签证机构来做的（所以腾讯云也是这样）。所以下面其实是在说Symantec的签证要求。</p>

<p>阿里云是允许你通过修改DNS或在指定的主页位置放一个名为<code>fileauth.txt</code>的文本文件（一个详细的过程可以<a href="https://yfdxs.com/ali-ssl-amh.html">看过里</a>，如果你能修改DNS的CNAME配置那么<a href="https://www.xiaoz.me/archives/7442">看这里</a>）。这样，你就必须要：</p>

<ol>
<li>有这个网站（或主页）的ftp账号；并且，  </li>
<li>可以创建名为<code>.well-known</code>这样以点字符开始的目录名（基于Windows系统的主机不能创建这样的名称）；并且，  </li>
<li>可以确保能通过<code>http://your-domain-name/.well-know/...</code>这样的url路径下载到上述文本文件（注意：如果你的网站已经开通了https，那么它会优先访问https开头的地址）。</li>
</ol>

<p>问题往往出在第3步。这是因为Symantec会优先去https开头的地址下载验证文件，而一般会提供ssl的主机/免费空间都会默认的给你装一个『自主签名的SSL证书』，这个证书事实上会被认为是无效的——因此Symantec就会验证不通过。</p>

<p>这种情况下你可以曲线救国：先去找别的机构签一个短期一些（通常是3个月）的证书，让这个https地址生效了，然后再回头过验证Symantec的签证（话说，我就是这么干的）。</p>

<p>不过，有些时候事情并不那么美妙，因为即使你的主页空间『信誓旦旦』地说他们开放了SSL，并且无论如何你都把文件传到了正确的地方，甚至你看起来也的确可以通过https/http来访问到上述的<code>fileauth.txt</code>文件的URL地址，但是——你就是通不过Symantec（或者阿里云、腾讯云等等）的验证——它们找不到上面的这个文件。</p>

<blockquote>
  <p>注意：我就是因为这个问题申请了又放弃了近二十个免费主页空间。相信我，如果你逐一去试，不会好到哪里去的。</p>
</blockquote>

<p>问题出在哪儿呢？</p>

<p>这是因为非常非常多的『免费主页』本质上都是要在你的主页上挂广告才能活下去的，他们挂广告的方法真的很纷纷多啊。其中一种常用的，就是串改你的url地址，它会把浏览器访问到的url改成带广告代码的，然后自己搞点弹窗啊什么的，最后才重定向到你真实的地址。——这个过程浏览器认得，而『公信力机构』的验证程序可认不得啊，后者在读取验证文件的时候并不支持为浏览器准备的重定向！</p>

<p>所以，一旦你申请到一个主页空间，先用curl去访问一下，如果是下面这种返回：</p>

<pre><code class="language-bash">&gt; curl 'http://your-domain-name/'
&lt;html&gt;  
&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;  
...
</code></pre>

<p>好吧，它的意思是说不支持curl这样的直接访问，一般来说就不能用了。不过如果你不死心，可以再试试伪装成浏览器：</p>

<pre><code class="language-bash">&gt; curl -H 'User-Agent:Mozilla/5.0' 'http://your-domain-name/'
&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript" ...  
</code></pre>

<p>那么你就真的不用想了：上面的就是挂广告的代码了，你还想什么呢。</p>

<p>所以你看，我申请了很多又很多个免费空间，都作废了。</p>

<h4 id="1032instantssl">10.3.2 试试别的验证方法，例如instantssl的</h4>

<p>这家『公信力机构』也非常棒，他提供3个月免费的签证。我们上面说过，你可以尝试『曲线救国』，或者干脆就每三个月签一回，都行。</p>

<p>重要的是，instantssl采用的是邮件验证，而不是验证ftp文件。</p>

<p>instantssl是科摩多（comodo）提供的一项SSL证书发放服务，所以你用<a href="http://www.comodo.cn/">comodo.cn</a>或<a href="http://www.instantssl.cn/">instantssl.cn</a>访问都是可以的。他要求你提供自己准备的CSR，之后会提示你会把证书邮寄给你的网站的admin邮箱账号。</p>

<p>所以，这就要求你的主页空间给你开通邮箱服务，并且你能自定义类似<code>admin@yourname.freespace.xyz</code>这样的邮箱名——这个instantssl可以让你选，不过总的来说就那几种特定的。</p>

<p>很好，如果你有这样的免费空间，或者你就是能得到这样的邮箱，那么试试instantssl的吧。我知道<a href="http://infinityfree.net">infinityfree</a>免费空间提供这样的邮箱服务，比如我其实申请了一个<code>.epizy.com</code>的二级域名。但很不幸我没有通过instantssl的验证——它提示我相应名字的签证已经发过了。</p>

<p>不知道为什么。反正，你也许可以试试。</p>

<h4 id="1033">10.3.3 还有一些别的不错的签证机构</h4>

<p>有个非常非常著名的、推动https的签证组织，叫<code>Let’s Encrypt</code>。这个签证非常好用，所以也常常有自己做虚拟主机的来用它（<a href="https://www.freehao123.com/lets-encrypt/">https://www.freehao123.com/lets-encrypt/</a>），很多介绍中也首推就是它（<a href="https://www.freehao123.com/top-8-free-ssl-cert/">例如这里</a>）。</p>

<p>然而它对web域名签证并不友好，所以就有人搞了网站来做这件事，最好用的就是这家了：<a href="https://www.sslforfree.com/">https://www.sslforfree.com/</a>，它发的也是3个月的免费签证。你可以先看看这个教学<a href="https://changken.biz/969">SSLforFree 免费SSL凭证</a>。</p>

<p>SSLforFree的验证过程与阿里云/Symantec的类似，也是要求你传一个文件到ftp上（或者改DNS CNAME），不过他不验证https，所以多数『提供了无效的https的免费空间』来说也能很好的通过验证——除了我上面说的挂广告代码的那种情况。</p>

<p>也许还有其它好的，有知道的不妨推荐给我。</p>

<h3 id="104">10.4 安装你得到的凭证</h3>

<p>『公信力机构』最终给你的是名为Certificate的凭证。并且，</p>

<ul>
<li>如果是他帮你生成的CSR，那么他会给你Private Key；</li>
<li>一般来说他会给你一个它作为签证机构的公钥，不过由于使用者（例如你的主页空间服务商）能直接从网站上搜到这个公钥，所以没有给你也是正常的。</li>
</ul>

<p>你需要在后台把Certificate凭证和Private Key给上传(Upload)或更新(Update)到你的管理后台——如果它有类似『SSL管理』这样的功能的话。例如：</p>

<blockquote>
  <p>（第1步先上传你的证书）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-update_ssl.png" alt="ssl_step-update_ssl"></p>

<blockquote>
  <p>（然后点下面的『管理SSL站点』）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/ssl_step-update_site-1.png" alt="ssl_step-update_site"></p>]]></content:encoded></item><item><title><![CDATA[手记4：谈谈Gitment中泄露secret的前因后果与解决方法]]></title><description><![CDATA[<p>本来我接下来只是想在博客中加上一个支持评论的功能（使用Gitment），然而诸多的尝试之后，我却发现我需要创建一个支持https的web站点……</p>

<p>这一切的目的，只是使得我们的Gitment有跨域访问的Api接口可用。</p>

<h2 id="8">8. 问题出在哪里</h2>

<p>Gitment（<a href="https://github.com/imsun/gitment">项目</a>）是极棒的一个利用Github Issues来实现博客评论功能的项目，作者（<a href="https://imsun.net/">https://imsun.net/</a>）在介绍中特别提到，这种对Issues功能的使用方法是Github团队支持许可的。这也意味着只要你能接受以下两点可能存在的限制/隐患，你就可以长期地使用它：</p>

<ul>
<li>Github真的可能被屏蔽，尽管这种可能性已经越来越小</li>
<li>要发表评论的话必须先注册Github的账号，不过浏览评论是不受限制的</li>
</ul>

<p>但是使用Gitment是有问题的。更准确地说，如果你直接在你的博客中部署Gitment这个项目，那么你将面临你的Github application client secret token丢失的风险。这个风险会带来两种可能，一种是你自己的Github账户下的application被假冒，另一种是在你的博客上发表评论的Github用户被冒名。</p>

<p>这个风险看起来很大。而这对于Gitment来说又难于避免，因为它要求你在使用时往博客模板中插入以下代码：</p>

<pre><code class="language-javascript">var gitment = new Gitment({  
  id: '页面 ID', // 可选。默认为 location.href</code></pre>]]></description><link>http://aimingoo.github.io/1-1722.html/</link><guid isPermaLink="false">bfa19ad7-3e78-4560-a7ff-f79104c7dd8d</guid><category><![CDATA[博客]]></category><category><![CDATA[Javascript]]></category><category><![CDATA[Github]]></category><category><![CDATA[Gitment]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 28 May 2017 18:17:49 GMT</pubDate><content:encoded><![CDATA[<p>本来我接下来只是想在博客中加上一个支持评论的功能（使用Gitment），然而诸多的尝试之后，我却发现我需要创建一个支持https的web站点……</p>

<p>这一切的目的，只是使得我们的Gitment有跨域访问的Api接口可用。</p>

<h2 id="8">8. 问题出在哪里</h2>

<p>Gitment（<a href="https://github.com/imsun/gitment">项目</a>）是极棒的一个利用Github Issues来实现博客评论功能的项目，作者（<a href="https://imsun.net/">https://imsun.net/</a>）在介绍中特别提到，这种对Issues功能的使用方法是Github团队支持许可的。这也意味着只要你能接受以下两点可能存在的限制/隐患，你就可以长期地使用它：</p>

<ul>
<li>Github真的可能被屏蔽，尽管这种可能性已经越来越小</li>
<li>要发表评论的话必须先注册Github的账号，不过浏览评论是不受限制的</li>
</ul>

<p>但是使用Gitment是有问题的。更准确地说，如果你直接在你的博客中部署Gitment这个项目，那么你将面临你的Github application client secret token丢失的风险。这个风险会带来两种可能，一种是你自己的Github账户下的application被假冒，另一种是在你的博客上发表评论的Github用户被冒名。</p>

<p>这个风险看起来很大。而这对于Gitment来说又难于避免，因为它要求你在使用时往博客模板中插入以下代码：</p>

<pre><code class="language-javascript">var gitment = new Gitment({  
  id: '页面 ID', // 可选。默认为 location.href
  owner: '你的 GitHub ID',
  repo: '存储评论的 repo',
  oauth: {
    client_id: '你的 client ID',
    client_secret: '你的 client secret',
    ...
</code></pre>

<p>这个<code>client_secret</code>来自于你在自己的Github个人配置<code>Settings -&gt; Developer Settings -&gt; OAuth applicatoins</code>中创建一个application时所生成的secret，这个secret提供了所谓的单点登录认证，以确保其它的Github用户在经过同意后使用你的博客中的Gitment模块来发评化——这种用法类似于新浪、微信、QQ等等的小应用。</p>

<p>通常你需要这个secret有访问者的repo级别的访问权限（因为添加评论其实上是向repo的issues中添加comments），而一旦有人劫持了访问者的access_token，那么它就可以仿冒访问者在任意的github仓库中添加comments、以及issues——看起来很可怕不是？而且事实上看起来这个权限还更大，可以操作访问者自己的仓库。</p>

<p>Gitment的作者为什么要留下这么一个漏洞呢？Github又为什么会允许这样一个漏洞存在呢？</p>

<h3 id="81gitment">8.1 Gitment干了什么？</h3>

<p>其实Gitment的作者是好心的。他在源代码中是这么写的：</p>

<pre><code class="language-javascript">this.state.user.isLoggingIn = true  
http.post('https://gh-oauth.imsun.net', {  
    code,
    client_id,
    client_secret
  }, '')
  .then(data =&gt; {
    this.accessToken = data.access_token;
    ...
</code></pre>

<p>这段代码的意思，是拿你在Github后台生成的一对<code>client_id/client_secret</code>验证信息，去<code>https://gh-oauth.imsun.net</code>上面换取access_token，而这个access_token才是当前登录的Github用户在你的博客用发评论时使用的验证信息。这个access_token会记录在cookies中，并且每次调用Github api时作为Authorization头信息提交给Github验证身份。</p>

<p>你把client_id和client_secret同时给了imsun.net，这是不对的；即使你信任imsun.net，然而把它公布在源代码中，也是不对的。——所以，事实上如果你在博客中部署了上述代码，你还会收到来自Github的一封邮件，提醒你不应该将token放在源代码中（是的，Github会扫描提交的源代码）。</p>

<p>Gitment的作者并不是不知道这个问题，他只是好心的想帮你解决一个问题——这个我们下面会讲到——然而他带来了更严重的问题。</p>

<h3 id="82github">8.2 深入了解Github的单点登录和应用授权</h3>

<p>如果你在Github站外使用它的单点登录（也就是提示你用Github账户登录以使用某种功能），那么在这个网页中——其实也可以不是前端的网页，而是后端应用——需要调用Github API，来将当前用户引导到下面的Github的登录和授权页面：</p>

<pre><code class="language-bash">GET https://github.com/login/oauth/authorize  
    ?scope=(权限范围, Gitment预设的是'public_repo')
    &amp;client_id=(验证应用的client_id)
    &amp;redirect_url=(验证成功后的返回url, Gitment预设的是当前页)
</code></pre>

<p>这时，（如果当前用户/访客没有登录过，那么）它看到的页面是下面这样的：</p>

<blockquote>
  <p>（界面1：跨站应用的单点登录界面）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/github_auth_step-1.png" alt="github_auth_step-1"></p>

<p>如果访客还没有为这个应用授权过（或者他已经是Github的登录用户），那么他之后还会看到下面这个界面：</p>

<blockquote>
  <p>（界面2：授权）</p>
</blockquote>

<p><img src="http://aimingoo.github.io/content/images/2017/05/github_auth_step-2.png" alt="github_auth_step-2"></p>

<p>这两步的目的就是让访客登录，并且让他确认你的应用（例如Gitment）能够使用他的账号中的哪些权限。一旦用户确认过这个授权，那么在他的Github账号后台<code>Settings -&gt; Authorized OAuth Apps</code>中就可以看到这个应用（也能Revoke掉它），并且下次就不用再确认授权了。</p>

<p>注意到上述'will redirect to'的地址——它在使用API提交时的配置细节在Github API的说明中有（<a href="https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/#redirect-urls">在这里</a>），简单地说它必须以Application在后台的配置作为前缀。在我们这里讨论的Gitment中，作者将它设置为当前正在访问的网页——例如某篇博客文章（Post）。</p>

<p>接下来如果Github验证并授权了访问的账户，它就会通过HTTP调用来返回304并带上一个Location地址，这个地址就是上面的redirect_url，并且会在这个url后面多带一个<code>code</code>参数。以我的站点上的某个具体的post来说，返回的时候这个Header是下面这样的：</p>

<pre><code>Location:https://aimingoo.github.io/1-1718.html?code=40299d8475d3679c8c8c  
</code></pre>

<p>在静态页面（例如1-1718.html）中从url取参数的方法就不用细讲了。于是接下来Giment取到这个参数<code>code</code>，它还需要再做一次验证，才能真正的让当前用户能够使用Github API。这个验证操作需要调用：</p>

<pre><code class="language-bash">POST https://github.com/login/oauth/access_token  
    client_id: ...
    client_secret: ...
    code: ...
</code></pre>

<p>并且它使用POST请求的Accept header来决定以何种格式（xml/json/url-encode）来返回数据。显然地，这里需要在浏览器中使用AJAX请求来向<code>https://github.com/</code>调用这个API。</p>

<p>问题就出在这一步。</p>

<h3 id="83githuboauth">8.3 Github OAuth并不支持浏览器跨站访问</h3>

<p>如果你在命令行上或者其它代码中直接访问上述POST API，那么不错，你能拿到返回数据access_token，然而不幸的是：Gitment在浏览器上，只能使用Ajax。</p>

<p>事实上Gitment可以调用上述API并返回数据，但是注意发起这个API的地址（以上面的post为例）与调用的Github API地址分别是：</p>

<pre><code>https://aimingoo.github.io/1-1718.html  
https://github.com/login/oauth/access_token  
</code></pre>

<p>于是浏览器说：这是一个跨站访问！浏览器会把POST请求拆成两个，先发一枚OPTIONS请求问问github.com是否支持跨站，如果github.com接受了OPTIONS并正确返回，那么浏览器才接下来发POST请求。——OPTIONS请求是没有POST BODY区的，显示这是为了浪费服务器接受大型的POST请求时浪费资源。关于这个过程的细节，可以参考阮一峰老师的文章『<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a>』。简单地说，服务器端对OPTIONS和POST请求都必须在返回头中包括<code>Access-Control-Allow-Origin</code>字段，并使该字段带有正确的来源Origin信息。——这样一来，浏览器就会认为服务器是接受跨站访问的了。</p>

<p>然而Github的access_token接口并不返回上述头。而且，可以预见的将来，它都不会有这个头。因为这是正确的——我们确实不应该在浏览器上直接使用这个接口，并且公开接口中的client_secret。从另一方面来说，这个access_token接口是应该在一个浏览器用户受信的后端应用中，亦即是我们称为Gitment模板的应用内部发起调用的，它可以持有client_secret而不必告诉任何人，这是Github确认『该应用合法』的唯一凭据。</p>

<p>Gitment没有办法同时做到两件事：</p>

<ul>
<li>既可以使用一个惟一、统一的Giment client_secret凭据，</li>
<li>又在redirect_url中指定某个非确定的博客返回地址。</li>
</ul>

<p>这使得作者无法公开发布一个公众使用的、不需要每个博主去Github后台配置OAuth Application服务的应用。而接下来，作者也有没办法在没有client_secret凭据的情况下，帮你调用Github's access_token接口。</p>

<p>所以，你看到了结果：Gitment的代码要求在网页中泄露你的client_secret，然后提交到<code>https://gh-oauth.imsun.net</code>去，作者会帮助你调用Github API，然后返回一个access_token。</p>

<p>只有这样，当前的访问才能用这个access_token为每一个XHR Request建立有效的Authorization头。</p>

<p>问题的根源，仅仅是出在Github OAuth并不支持浏览器跨站访问——它的返回头用没有Access-Control-Allow-Origin。</p>

<h3 id="84api">8.4 API网关</h3>

<p>显然，这绝壁了就是API网关要干的事情。如果我有一个API网关，那么我就只需要接受来自浏览器的Gitment请求，然后将API转发到Github，并且在返回头上塞上一个Access-Control-Allow-Origin就万事大吉了！</p>

<p>是的，这是对的。不幸的是，没有这么个东东——而且要开放可信的。</p>

<p>我尝试过阿里云的API网关！很牛x的产品，价格也不贵，而且配置操作一路极顺畅，Ding dong Ding dong分分钟就建好了网关，但是——不能定制返回的HTTP Header！</p>

<p>我尝试过微软Azure里的API网关！也很牛x产品，骗了我一块钱人民币，居然让我连配置都完不成——最最反程序员的产品就非它莫属了。</p>

<p>我尝试过很多很多云服务或云端微服务的API网关产品，要么是根本连页面都打不开的，要么就是不支持CORS跨站的。简单地说：你就算想花钱也是花不出去的。</p>

<p>不过真想花钱，还是有一个法子的。你可以租一台虚拟主机，然后在上面架一个Nginx，通过配置来代理这个POST请求并在返回中加上Access-Control-Allow-Origin头。是的，这相当不错，连代码也不用写。但是搞云主机啊，分分钟收钱的。——你的API能访问几次？一个小小小小得不得了的博客，一个月能用10来条评论就不错了，调用上面的登录接口，大概也就三五次吧！</p>

<p>不值当搞台云主机啊！</p>

<p>于是，我说：</p>

<h3 id="85sir">8.5 写点代码吧，Sir</h3>

<p>要写点代码就其实很好办了，用NodeJS也好、PHP/ASP也行，其实甚至BASH脚本都搞得定。只需响应前端（frontend）来的POST请求，然后去Github API接口（backend）上拿数据，在返回前端之前塞上个Header就行了。</p>

<p>不过具体要做起来，就麻烦一点了。我用PHP写了一个名为intersect的项目（<a href="https://github.com/aimingoo/intersect">在这里</a>），它修改自<a href="https://github.com/stamat/corsica">CORSica</a>，不过添加了不少的特性：</p>

<ul>
<li>HTTPS POST支持</li>
<li>添加可配置字段（例如为Github API添加client_secret）</li>
<li>处理前后端不同的Connection方法</li>
<li>处理Transfer-Encoding</li>
<li>处理Content-Length的变化</li>
<li>一些防止滥用的简单guard代码</li>
<li>...</li>
</ul>

<p>基本上，我的意思是说，它简单的配置下就可用了；而且稍作定制，也可以作为一个通用的CORS网关。所以，接下来，你就需要找一个能放PHP代码的免费主页，然后把intersect放上去，配置其中的<code>DOMAIN_ACCEPT</code>和<code>PRIVATE_CLIENT_SECRET</code>。这样这个网站就能拿来替代Gitment中对<code>https://gh-oauth.imsun.net</code>的访问了。</p>

<p>当然，Gitment还需要稍稍的改点代码。</p>

<p>这个我们回头再说，现在我们得搞一个提供免费主页的网站把这个代码放上去。</p>]]></content:encoded></item><item><title><![CDATA[手记3：实例教学之Ghost模板定制]]></title><description><![CDATA[<p>接下来我们聊一下如何定制这个博客的风格。</p>

<h2 id="7themes">7. 定制Themes</h2>

<p>Ghost缺省使用的主题叫casper theme，你可以在博客管理界面<code>Settings -&gt; General -&gt; Themes</code>中找到你当前安装过的全部Themes，并任意激活/删除它们。</p>

<p>有两种方法来安装Themes。第一种是在这个管理界面中选最下面的『Upload A Theme』来上传你下载过的Theme .zip包，第二种是直接将.zip包解压到Ghost安装目录的<code>content/themes/</code>目录下。</p>

<p>我选择的是使用小蘿蔔丁(<a href="http://xlbd.me/">在这里</a>)发布的<code>kaldorei - 0.8.0</code>，你可以下载或阅读这个Theme相关的说明（<a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei">这里</a>）。我可能将来会将博客换成别的什么风格，不过现在kaldorei还是挺合用的。</p>

<p>但我还是做了一些修改（关于Themes的基础使用与修改改可以参考<a href="http://docs.ghost.org/zh/themes/">这里</a>）。</p>

<h3 id="71">7.1 一些基本和简单的使用</h3>

<p>Ghost的一个好处是可以随意定制并生成静态页，这些页可以用博客后台来发布或更新，或者仅仅只是一个普通的静态页面（无需通过后台来更新内容）</p>]]></description><link>http://aimingoo.github.io/1-1721.html/</link><guid isPermaLink="false">5e342c06-52cf-44de-b741-428859c06a61</guid><category><![CDATA[Ghost]]></category><category><![CDATA[博客]]></category><category><![CDATA[Javascript]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sat, 27 May 2017 19:28:21 GMT</pubDate><content:encoded><![CDATA[<p>接下来我们聊一下如何定制这个博客的风格。</p>

<h2 id="7themes">7. 定制Themes</h2>

<p>Ghost缺省使用的主题叫casper theme，你可以在博客管理界面<code>Settings -&gt; General -&gt; Themes</code>中找到你当前安装过的全部Themes，并任意激活/删除它们。</p>

<p>有两种方法来安装Themes。第一种是在这个管理界面中选最下面的『Upload A Theme』来上传你下载过的Theme .zip包，第二种是直接将.zip包解压到Ghost安装目录的<code>content/themes/</code>目录下。</p>

<p>我选择的是使用小蘿蔔丁(<a href="http://xlbd.me/">在这里</a>)发布的<code>kaldorei - 0.8.0</code>，你可以下载或阅读这个Theme相关的说明（<a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei">这里</a>）。我可能将来会将博客换成别的什么风格，不过现在kaldorei还是挺合用的。</p>

<p>但我还是做了一些修改（关于Themes的基础使用与修改改可以参考<a href="http://docs.ghost.org/zh/themes/">这里</a>）。</p>

<h3 id="71">7.1 一些基本和简单的使用</h3>

<p>Ghost的一个好处是可以随意定制并生成静态页，这些页可以用博客后台来发布或更新，或者仅仅只是一个普通的静态页面（无需通过后台来更新内容）。无论如果，Ghost提供很简单的方法来做这件事，并且允许你为每一个静态页定制自己的页面风格、主题或模板。</p>

<p>kaldorei主题是使用这个方式来实现『历史归档』的功能（<a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei#开启归档功能">参考这里</a>），这也相当于介绍了『定制静态页』功能的用法——所以我的博客的『关于』页面就是这样做的。</p>

<h4 id="711">7.1.1 处理背景色与背景图片</h4>

<p>需要两个操作。其一：</p>

<pre><code class="language-css">/* modify file at ./ghost-theme-kaldorei/assets/css/screen.css */
body {  
    margin: 0;
    background: #000;
}
</code></pre>

<p>其二，在default.hbs模板的body标签之后添加如下风格样式：</p>

<pre><code class="language-html">&lt;style&gt;  
body {  
    background-image: url(/assets/img/background.jpg);
    background-repeat: no-repeat;
    background-position: top center;
    background-attachment: fixed;
    background-size: auto;
}

.site-wrapper {
    background: none;
}

.main-header {
    background: none;
    border-bottom: none;
}

.main-nav a {
    color: #FFF;
}
&lt;/style&gt;  
</code></pre>

<p>注意这个风格中的背景图片是放在Ghost安装目录下的<code>content/themes/ghost-theme-kaldorei/assets/img</code>目录中的。makesite.sh脚本（或Buster工具）会搜索到这个文件，并下载这个文件到你的static目录中。</p>

<h4 id="712">7.1.2 为每篇博客添加『编辑』按钮</h4>

<p>当添加了这个按钮之后，我在本地博客中读博文的时就可以随时编辑它，而不必总是回到管理后台去找到这篇文章——Ghost后台没有搜索功能。</p>

<p>因为添加的这个按钮对线上的用户没有意义，所以在我的<code>makesite.sh</code>脚本中有一处代码会将它从<code>./static</code>中的静态页面中清理掉。</p>

<pre><code class="language-html">&lt;!-- modify file at ./ghost-theme-kaldorei/post.hbs --&gt;  
&lt;span class="post-meta-item pull-right"&gt;  
  &lt;!-- 在这个位置插入如下行 --&gt;
  &lt;a href="/ghost/editor/{{id}}/" target="_blank"&gt;编辑&lt;/a&gt;
&lt;/span&gt;  
</code></pre>

<h4 id="713">7.1.3 移除所有页脚</h4>

<p>纯粹只是个人不喜欢而已，因此除了保留版权说明之外，其它页脚本全部合并/删除掉了。基本上你在.hbs文件中搜索<code>-footer</code>然后自己斟情清理就行了。</p>

<pre><code class="language- bash">&gt; grep 'footer' *.hbs partials/*
</code></pre>

<h4 id="714">7.1.4 定制个人信息</h4>

<p>相关的信息页面在如下模板中，斟情修改（许多信息可以在博客后台的个人配置与网页配置中定制）：</p>

<pre><code>## 清理掉部分社交信息
ghost-theme-kaldorei/partials/social.hbs  
ghost-theme-kaldorei/partials/post_author.hbs  
## 我移除掉了标签数量的统计
ghost-theme-kaldorei/partials/site_stat.hbs  
</code></pre>

<h4 id="715">7.1.5 在博客文章中显示作者信息</h4>

<p>kaldorei主题并没有特别强调多作者博客的功能，所以它的文章（post）中只显示标签云，而不显示该文章的作者信息。因此我添加了这一功能，但需要做的修改极少：</p>

<pre><code class="language-html">&lt;!-- modify file at ./ghost-theme-kaldorei/partials/sidebar.hbs --&gt;  
&lt;!-- 注意在下面位置的is标签后面，多添加一个post参数，就可以了 --&gt;  
    {{! 作者：显示作者信息 }}
    {{#is "author, post"}}
</code></pre>

<p>关于多作者博客的支持，我打算另开一篇博文来讲。</p>

<p>^^.</p>

<h4 id="716">7.1.6 修改语法高亮</h4>

<p>在default.hbs中载入新的highlight style即可：</p>

<pre><code class="language-html">&lt;!-- kaldorei的缺省风格是monokai-sublime.css, 在styles目录下找个新的换上就Ok --&gt;  
&lt;!-- 可以先查看https://highlightjs.org/static/demo/来选择风格 --&gt;  
&lt;link rel="stylesheet" type="text/css" href="{{asset "plugins/highlight-9.1.0/styles/xcode.css"}}" /&gt;  
</code></pre>

<p>此外，你可能需要调整高亮代码左侧的行号背景（或其它），那么应修改如下样式表：</p>

<pre><code class="language-css">/* modify file at ./ghost-theme-kaldorei/assets/css/screen.css */
.pre-numbering {
    position: absolute;
    ...
}

.pre-numbering li {
    ...
}
</code></pre>

<h4 id="717">7.1.7 指定文章置顶</h4>

<p>置顶文章是常见的博客操作，你可以将一篇文章设置为<code>featured</code>，并且通过修改模板来使它们置顶。这会涉及到不少的修改。</p>

<p>好在所谓『置顶』操作其实只会发生在带有<code>（列表）list</code>性质的页面中，这类页面在Ghost中称为<code>paged</code>，它只出现在以下三类页面上：index, tag and author（<a href="https://themes.ghost.org/docs/paged-context#section-description">参见这里</a>）。在这三类页面中，可以用loop模板去列举所有页，但它们的<code>第1页</code>是paged为false的，而之后的<code>第2..n页</code>则是paged为true的。可以通过这种区别来将你需要的内容置顶，并在其它页面中筛除它们。</p>

<p>在具体实现中，由于<code>{{get}}</code>标记在<code>filter</code>设置时不能使用包含或查找操作（它能使用的运算支持<a href="https://api.ghost.org/docs/filter">在这里</a>），所以tag页不能用index/author页相同的方法来实现置顶。然而此外唯一可能做这个运算的<code>{{has}}</code>标记却不支持参数传入——所以，你已经知道结果了：在tag页中不支持（按标签分类过的）置顶。</p>

<pre><code class="language-html">&lt;!-- 在loop.hbs中用以下代码分别载入置顶风格的posts --&gt;  
{{^is "paged"}}
    {{! list all feated posts on top }}
    {{#is "index"}}
    {{#get "posts" filter="featured:true" limit="all" include="tags" as |featured|}}
    {{#foreach featured}}
        {{&gt; content_featured}}
    {{/foreach}}
    {{/get}}
    {{/is}}

    {{#is "author"}}
    {{#get "posts" filter="featured:true+author:{{author.slug}}" limit="all" include="tags" as |featured|}}
    {{#foreach featured}}
        {{&gt; content_featured}}
    {{/foreach}}
    {{/get}}
    {{/is}}
{{/is}}

&lt;!-- 紧接着载入普通风格的posts --&gt;  
    {{#foreach posts}}
    {{#is "tag"}}
        {{&gt; content_post}}
    {{else}}
        {{#unless featured}}
        {{&gt; content_post}}
        {{/unless}}
    {{/is}}
    {{/foreach}}
</code></pre>

<p>然后在<code>partials/content_featured.hbs</code>和<code>partials/content_post.hbs</code>中分别设置两种样式即可。——可以将原来在loop.hbs中<code>foreach posts</code>的代码块直接接到<code>partials/content_post.hbs</code>中。</p>

<p>最后，一些细节可以参考这里：<a href="https://www.ghostforbeginners.com/move-featured-posts-to-the-top-of-your-blog/">Move Featured Posts to the Top of your Blog</a>。</p>

<h3 id="72">7.2 将站点信息与云标签静态化</h3>

<p>Ghost博客静态化有一个小的问题，就是如果你加上了类似『站点状态(site_stat)』或『标签云(tag_cloud)』这样的功能的话，那么你几乎每添加或修改一篇文章，就要全部重新生成静态页，然后再重新Push到github仓库——每次都全站发布一回。</p>

<p>原因是这样，比如说你的site_stat里有一个『站点发表了多少篇文章』的计数，那么，显然你添加/删除一篇博客，就得让所有静态面这个位置的计数变一下；又例如标签名，你添加一个标签那么全站所有页的标签云都要动态生成一下。</p>

<p>而事实上——99%的博客文章或静态页面在内容上都没有什么变化 。所以，能不能将这些动态变化的信息静态化掉，不至于每次都要重新生成？</p>

<p>是能的。我采用的策略是：用js装载这些静态化的信息。</p>

<h4 id="721">7.2.1 为标签云添加一个静态页</h4>

<p>在博客后台添加一篇新的博客，将它的页面url设置成tag_cloud，并配配置它为静态页面（参见『历史归档』的做法，<a href="https://github.com/xiaoluoboding/ghost-theme-kaldorei#开启归档功能">在这里</a>）。这一篇博客的内容可以为空。</p>

<p>然后在<code>content/themes/ghost-theme-kaldorei/</code>目录下新添加一个名为<code>page-tag-cloud.hbs</code>的模板——它将是上面这篇文章的专用模板，Ghost是通过文件名来识别的。内容如下：</p>

<pre><code class="language-javascript">document.writeln(function cloudTagHtmlContext() {/*  
  {{&gt; "tag_cloud"}}
*/}.toString().replace(/^[^\*]+\*+|\*+[^\*]+$/g, ''));
</code></pre>

<p>注意，这是一段标准的JavaScript代码，并且事实上只有一行：</p>

<pre><code class="language-javascript">document.writeln(...);  
</code></pre>

<p>当Ghost将在后台把<code>page-tag-cloud.hbs</code>当成标准的模板文件来处理，所以它会填充其中的Ghost标志，并装载子模板页。而生成出来的静态页实际上是一个.js的文本文件，并且放在（我们在对应博客文章后台配置的）<code>/tag_cloud</code>这个位置上——不过没有扩展名而已。</p>

<p>这段脚本的作用仅仅是将cloudTagHtmlContext()这个函数（也可以是匿名函数）中的内容取出来，然后写在网页上。</p>

<p>这段代码总是通用的，可以用来将任意模板/网页转换成这样一个脚本文件，以便于动态装载。</p>

<h4 id="722">7.2.2 修改其它模板以装入上述脚本</h4>

<p>这很简单，在sitebar.hbs这个文件中找到<code>{{&gt; "tag_cloud"}}</code>，然后替换成下面的即可：</p>

<pre><code class="language-html">&lt;!-- modify file at ./ghost-theme-kaldorei/partials/sidebar.hbs --&gt;  
&lt;!-- 找到{{&gt; "tag_cloud"}}然后替换成下面的脚本 --&gt;  
&lt;script type="text/javascript" src="/tag-cloud"&gt;&lt;/script&gt;  
</code></pre>

<h4 id="723site_stat">7.2.3 关于site_stat</h4>

<p>与tag_cloud的处理类似，我添加了<code>/profile_site</code>静态页，并且添加模板如下：</p>

<pre><code class="language-javascript">// file at ghost-theme-kaldorei/page-profile-site.hbs
document.writeln(function cloudTagHtmlContext() {/*  
    &lt;hr&gt; {{&gt; "site_stat"}}
    &lt;hr&gt; {{&gt; "social"}}
*/}.toString().replace(/^[^\*]+\*+|\*+[^\*]+$/g, ''));
</code></pre>

<p>同样，最后你需要改一下<code>partials/profile.hbs</code>相应位置来装载<code>/profile_site</code>这个脚本文件。</p>

<h3 id="73">7.3 其它</h3>

<p>事实上我现在仍然是采用每次都全站生成静态页面来更新整个网站，因此上面的有关『静态化』的处理并不能带来直接的便利。但我的确打算发布一个『只更新最新内容』的小工具，这样网站Online就会变得快些了。</p>

<p>不同的主题的修改会略有区别，本文只供参考。</p>]]></content:encoded></item><item><title><![CDATA[手记2：从本地博客到Github Pages的最佳指南及工具]]></title><description><![CDATA[<p>现在你来到了Ghost的世界（或别的什么本地博客系统），怎么写博客以及格式等等问题都是这个博客系统的问题了，你应该去搜搜相关的教程。就我来说，Ghost挺好用的，偶尔还有些很便利使用的小惊喜。</p>

<p>如果你成功的导入了历史博客（或者你只是随手写了几篇），那么现在你面临的问题是：怎么把它放到网上去。当然可以是某个免费主页空间（只需要静态的就可以了），也可以是——比如我选择的就是Github Pages。这样一来，就可以有一个名为<code>xxxxxx.github.io</code>的博客地址了，而且博客文章和维护等等都使用Github的后台或Git命令行，又熟悉又自然，对吧。</p>

<h2 id="4github">4. Github开工</h2>

<p>你得先有Github账号。然后，创建一个名为<code>xxxxxx.github.io</code>的仓库。最后，你进入这个仓库，在仓库的Settings（注意不是你的帐户的Settings）中找到<code>GitHub Pages</code>，检查一下，他可能已经缺省写着：</p>

<blockquote>
  <p><code>Your site is published at https://xxxxxx.</code></p></blockquote>]]></description><link>http://aimingoo.github.io/1-1720.html/</link><guid isPermaLink="false">16433c0c-40f9-4978-9fe3-f56cb56b2102</guid><category><![CDATA[博客]]></category><category><![CDATA[Ghost]]></category><category><![CDATA[Github]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Fri, 26 May 2017 18:02:33 GMT</pubDate><content:encoded><![CDATA[<p>现在你来到了Ghost的世界（或别的什么本地博客系统），怎么写博客以及格式等等问题都是这个博客系统的问题了，你应该去搜搜相关的教程。就我来说，Ghost挺好用的，偶尔还有些很便利使用的小惊喜。</p>

<p>如果你成功的导入了历史博客（或者你只是随手写了几篇），那么现在你面临的问题是：怎么把它放到网上去。当然可以是某个免费主页空间（只需要静态的就可以了），也可以是——比如我选择的就是Github Pages。这样一来，就可以有一个名为<code>xxxxxx.github.io</code>的博客地址了，而且博客文章和维护等等都使用Github的后台或Git命令行，又熟悉又自然，对吧。</p>

<h2 id="4github">4. Github开工</h2>

<p>你得先有Github账号。然后，创建一个名为<code>xxxxxx.github.io</code>的仓库。最后，你进入这个仓库，在仓库的Settings（注意不是你的帐户的Settings）中找到<code>GitHub Pages</code>，检查一下，他可能已经缺省写着：</p>

<blockquote>
  <p><code>Your site is published at https://xxxxxx.github.io/</code></p>
</blockquote>

<p>OK。建议你将Features中的<code>Wikis</code>与<code>Restrict editing to collaborators only</code>设为关闭，而<code>Issues</code>建议开启——我相信你用得到它。</p>

<p>最后，你还可以在<code>Theme chooser</code>中选一个Theme。不过对我来说没什么意义，因为我将使用Ghost中的Theme。不过，如果你使用了Github的Theme，那么你的主页根目录——也就是<code>xxxxxx.github.io</code>这个仓库的根目录下就会多一个<code>_config.yml</code>文件。</p>

<p>此外，还总是会有一个<code>README.md</code>文件，知道Github的人都知道这个文件用来做什么，建议你留着——尽管删除掉也没什么影响。</p>

<p>除了上述两个文件，Github什么都没给你，一切都得自己来干。</p>

<p>当然，只要你创建了这个仓库，那么<code>https://xxxxxx.github.io</code>就已经可以访问了；如果你更新这个仓库，那么网站也就自动更新了。</p>

<p>很酷。</p>

<h2 id="5githubpages">5. 从本地博客到Github Pages</h2>

<p>尽管几乎所有的Ghost用户都被推荐使用Buster来生成静态页（generate static pages），但这个工具确实相当不好用，按某博主所说『<strong>是个大坑</strong>』，不过我也建议你看看他的博客文章（<a href="https://mrcotter.github.io/ghost-to-github-pages/">在这里</a>），写得很细致了。不过如果你不怎么用Python的话，我建议你不要安装pyenv和多版本的python，直接用MacOSX原装的就好——或者只用Brew安装Python 2.x。</p>

<p>参考上面这位博主（<a href="https://mrcotter.github.io/author/kris/">Kris Cotter</a>）的文章，我写了一个名为<code>makesite.sh</code>的脚本，它配合Buster使用，并主要用来填Buster的一些坑。下面说说这个工具。</p>

<h3 id="51makesitesh">5.1 使用makesite.sh的标准过程</h3>

<p>参考下面的控制台命令：</p>

<pre><code class="language-bash">## 取一份你的Github Pages仓库，例如(YOURNAME/YOURNAME.github.io)
&gt; git clone https://github.com/YOURNAME/YOURNAME.github.io
&gt; cd ./YOURNAME.github.io

## 定制一下git exclude files
&gt; echo -e '\nstatic/\nmakesite.sh\npatchme.sh\nbuster.log’ &gt;&gt; .git/info/exclude

## 下载makesite.sh文件到本地仓库
&gt; wget -nv 'https://github.com/aimingoo/ghost-utils/raw/master/makesite.sh'

## 使用帮助
&gt; bash makesite.sh --help
###########################################################################
 Usage:
  &gt; bash makesite.sh --generate --reset-domain --short-path --deploy-now
 ...
</code></pre>

<p>上面列举了makesite.sh对<code>Ghost -&gt; Github Pages</code>的一个标准过程的理解，亦即是分成四步：</p>

<ul>
<li>generate: 调用Buster生成静态页</li>
<li>reset-domain: 重置本地博客的domain到远端（YOURNAME.github.io）</li>
<li>short-path: 生成简短的网页路径</li>
<li>deploy-now: 部署到Github仓库</li>
</ul>

<p>你可以使用参数来开启或关闭任何一个步骤，或者从任何一个步骤开始（而无视于其它步骤）。缺省情况下所有的步骤都是关闭的，只检查一下当前目录下是否存在<code>./static</code>子目录。——注意这个目录是被保留，不被提交到Github仓库中去的（所以前面的脚本中我将它添加到了<code>.git/info/exclude</code>文件中）。</p>

<p>整个过程需要依赖<code>git</code>和<code>buster</code>两个工具，另外需要<code>wget</code>、<code>grep</code>和MacOSX版本的<code>sed</code>。如果你是在别的系统上运行这个脚本，你"可能"需要改一下sed的命令行参数。</p>

<p>如果你只是生成静态页而不部署它，那么你不需要使用<code>--deploy-now</code>参数，这种情况下没有安装git也是可以的。但我总是建议你先安装buster：</p>

<pre><code class="language-bash">## 使用Python的PIP安装buster
&gt; pip install buster

## 如果你没有wget或git
&gt; brew install wget git
</code></pre>

<h3 id="52makesitesh">5.2 makesite.sh的配置与参数</h3>

<p>如果你读makesite.sh的源代码，你会发现它处理参数的代码非常漂亮（嘿~嘿~）。</p>

<p>这些参数可以有两种格式：</p>

<ul>
<li><p><code>--reset-domain=false</code>：指定reset-domain参数值为false。</p></li>
<li><p><code>--reset-domain</code>：这种省略掉值的情况，等效于<code>--reset-domain=true</code>。</p></li>
</ul>

<p>也可以指定字符串值，例如设置你的domain（缺省值是我的"aimingoo.github.io"）：</p>

<blockquote>
  <p><code>--domain='YOURNAME.github.io'</code></p>
</blockquote>

<p>所有通过命令行参数传入的参数配置，都有相对应的bash变量（全大写字符），所以你也可以直接修改.sh脚本中的变量缺省值，以避免每次都要通过命令行指定（例如，尤其是<code>--domain</code>和<code>--generate-info</code>这样的参数）。</p>

<p>由于通常你都需要配置自己的domain参数，所以我没有将makesite.sh写成通用脚本，而是建议你每个Github本地仓库下载一份独立的，并修改其中DOMAIN变量的缺省值。</p>

<p>也正是因此，它也被加入了git的排除文件列表。</p>

<h2 id="6">6. 填了哪些坑？</h2>

<p>前面说过makesite.sh用来填Buster的一些坑的。但填了哪些坑呢？下面讲讲技术问题。</p>

<h3 id="61busterwget">6.1 Buster调用wget时的参数问题</h3>

<h4 id="611buster5pages">6.1.1 Buster其实只帮你抓5页Pages</h4>

<p>如果你的博客很多，有很多的分页（比如我的就有五十多页），那么你很容易就发现其实Buster只帮你抓了其中的5页——很郁闷吧。</p>

<p>这是因为Buster调用wget来抓取页面，而它在递归下载时默认搜索的递归尝试就是5层，这个需要修改<code>--level</code>参数。</p>

<h4 id="612">6.1.2 你可能需要忽略掉一些抓取页面</h4>

<p>Ghost默认会帮你生成很多东西，有SEO用的amp文件、sitemap文件或rss文件，又例如最新的ld+json数据。然而你不见得都需要用到，其中最严重的就是amp，因为这相当于你生成了两份博客，所以我们需要用<code>--reject-regex</code>来忽略掉它。</p>

<p>还有一种情况非常特殊。在Ghost博客里，tag页可能有两种url（事实上所有的页面都会有这两种页）：<code>/tags/XXX</code>和<code>tags/XXX/</code>。别小看多出来的这个斜杠<code>/</code>：当wget访问<code>/XXX</code>页时，它是将url理解为文件的，因此将要写入的是文件XXX（如果加上<code>--adjust-extension</code>参数那么就写入XXX.html）；而访问<code>/XXX/</code>时，wget认为它访问的是目录，所以也就会尝试创建XXX这个目录并写入<code>./XXX/index.html</code>。</p>

<p>然而我们设想一个问题：如果一个网站中既有<code>/tags/XXX</code>又有<code>tags/XXX/</code>，那么当wget先找到前者的时候，就会在当前目录下写一个XXX文件，而下一次它找到后一种的时候，会发生什么呢？</p>

<p>这有三种可能性：</p>

<ul>
<li>如果有XXX目录，而又要创建XXX文件的话，wget会创建一个名为XXX.1的文件；</li>
<li>如果反过来是有XXX文件的情况下，
<ul><li>需要再创建./XXX/目录，那么wget直接覆盖XXX文件，于是旧的XXX文件丢失，多出来一个新的XXX目录；</li>
<li>需要创建<code>./XXX/yyy/index.html</code>这样的子级目录中的文件的话，那么很不幸，wget抛出一个异常<code>./XXX/yyy : Not a directory</code>，写文件不成功。</li></ul></li>
</ul>

<p>所以，我们需要忽略掉一些抓取页面，因为他们可能先于一个目录创建之前要写入，又或者与已写入的文件冲突，再或者根本就是多余的、重复的页。</p>

<h4 id="613busterpy">6.1.3 不修改buster.py的做法</h4>

<p>为了不修改Buster的源代码，我在makesite.sh中定义了一个名为wget的函数，并且在当前进程中导出它。这样一来，由于Buster是由makesite.sh这个shell脚本launch起来的，那么当它调用wget下载的时候，就调用了我们在程序中修改过的版本。</p>

<p>——这是一种在当前脚本中打patch的方法（可以不修改buster.py的源代码）。基本的代码如下：</p>

<pre><code class="language-bash">##
## 参见makesite.sh源代码
##

## 声明函数并追加参数
function wget { $RAW_WGET --level=0 inf --reject-regex=... }

## 取原始的wget的路径并导出到当前环境中
export RAW_WGET=`which wget`

## 将wget函数导出到当前环境中
export -f wget

## 调用buster，这时buster将使用我们在代码中声明的wget函数来下载
buster ...  
</code></pre>

<h3 id="62">6.2 移除版本号</h3>

<p>在新近一些的前端技巧中，为JavaScript和CSS文件加上版本号已经是很流行的做法了。然而这意味着Buster抓取的文件会存成类似<code>shared/ghost-url.js?v=3edb33f1b1</code>这样的名字。</p>

<p>所以在makesite.sh中有两行代码来对<code>assets</code>和<code>shared</code>目录中的资源做更名，以移除这种版本号：</p>

<pre><code class="language-bash">## 移除assets目录中的资源版本号
&gt; find static/assets -name '*\?*' -type f -exec sh -c "echo '{}' | sed 's|\?.*$||' | xargs -I[] mv '{}' '[]'" \;

## 移除shared目录中的资源版本号(通常只有/ghost-url.js这个文件)
&gt; find static/shared -name '*\?*' -type f -exec sh -c "echo '{}' | sed 's|\?.*$||' | xargs -I[] mv '{}' '[]'" \;
</code></pre>

<h3 id="63resetdomainshortpath">6.3 从reset-domain到short-path</h3>

<p>reset-domain是<a href="https://mrcotter.github.io/author/kris/">Kris Cotter</a>最早版本代码中的功能，简单地说就是将Buster下载的网页文件中残留的<code>localhost:2368</code>再做一次替换，所以我将这个过程叫做reset-domain。</p>

<p>事实上wget的<code>--convert-links</code>参数做过一次高性能的链接转换，但这远远不够——这些转换基于wget的html parser中对"链接"的定义（可以参见tag<em>attr html</em>allow这个数据结构，位于wget源码html.c中）。而reset-domain针对的是可能存在的文本替换——而无论对象是否是.html，或者是否是真实的url链接。</p>

<p>经过这两轮的处理（generate和reset-domain）之后，事实上整个<code>./static</code>目录下的文件已经可以作为静态页发布了。确切地说，你已经可以使用下面的命令来部署本地git仓库，将它推到你的主页<code>YOURNAME.github.io</code>中去了：</p>

<pre><code class="language-bash">&gt; bash makesite.sh --deploy-now
</code></pre>

<p>然而makesite.sh脚本还在这个操作之前插入了一个<code>--short-path</code>——我想你已经注意到这一点了。</p>

<p>这个short-path的目的是将Ghost生成的类似于<code>/your--post-full-title----as-slug/index.html</code>这样长的“目录名+文件名”变得短一些。它基本的想法就是让主页根目录下不要太多的目录，因此将这些目录中的index.html上移到它们的父目录中——对于所有的posts来说，其实也就是根目录下。</p>

<p>这个过程其实有一个更好的解决方案，就是将所有这些文件移入到<code>/posts/your--post-full-title----as-slug.html</code>，这样一来主页根目录下就只有一个posts目录了。我尝试过，但之后放弃了，因为我写不出一个有效的正则表达式来替换所有“其它”页面中的url——到该页面的新位置。</p>

<p>好吧，总而言之，我们做了一点工作（尽管实际上这是效率最低的一个步骤）。所以你还是可以在部署之前尝试一下：</p>

<pre><code class="language-bash">&gt; bash makesite.sh --short-path
</code></pre>

<h4 id="631url">6.3.1 更短的url</h4>

<p>我的主页<code>aimingoo.github.io</code>中其实使用的是更短的url地址，而并不是Ghost中缺省地按照文章标题通过拼音转换而来——后面这种文件名生成得太长太难看了。这种『更短的url』其实是通过为每个post设置它独自的slug属性而得到的，这需要为每篇文章在Ghost后台管理界面去编辑Post的属性。</p>

<p>这也是上一篇博客中提到的<code>putrefy.js</code>这个工具（<a href="https://github.com/aimingoo/ghost-utils">在这里</a>）中会有一个<code>SLUG_FROMID</code>参数的原因。当配置这个参数为true时，你从旧博客中导入的文章就将自动地以<code>author_id</code>作为前缀，并加上post_id作为slug了——我的博客就是用这种方法来导入的。当然，你也可以将<code>SLUG_FROMID</code>配置为别的什么字符串来作为前缀。</p>

<p>但是，你在Ghost后台新添加的文章，就需要你手工地改slug了。这个今后我会发布个小工具来自动化的，这里暂且不提。</p>

<h3 id="64patchmesh">6.4 关于patchme.sh</h3>

<p>这是在makesite.sh中留下的一小处补丁程序。你可以编写一段shell代码（放在makesite.sh同目录中就可以了），让makesite.sh在正式地deploy-now操作之前，由你自己来对<code>./static</code>目录中的页面做些修补。这偶尔也是必要的，例如我现在这篇文章是在介绍Ghost，那就不可避免地会用到<code>localhost:2368</code>这样的url地址，而按照Buster和makesite.sh的规则，它们就可能被替换成线上Github仓库中的地址了——所以需要one by one地patch。</p>

<p>当然，你也可以写点别的什么代码。</p>

<p>尤其是……程序员总想干点什么黑活之类的啦。</p>

<p>你懂的。</p>]]></content:encoded></item><item><title><![CDATA[手记1：迁移博客之全程工具]]></title><description><![CDATA[<p>在这一系列的博客中，我将仔细地记录我搭建这个博客的全部过程、工具，以及诸多技巧。</p>

<h2 id="1blogtowordpress">1. 如何迁移你的博客 - 推荐BlogToWordpress</h2>

<p>确实有很多工具来帮助你将历史、陈旧的博客迁到某个地方，而相对来说比较新的做法，就是将博客全文导出，然后按某种格式生成成静态的页面——于是你就有了新的博客站点。</p>

<p>然而事实上并不那么容易——这些工具分种种流派以及不同的实现语言。有幸的是，综合这些尝试，我们可以找到一个较简单而又完整的工具链条：从旧博客转到markdown文件，然后再将markdown导入到新博客中去。</p>

<p>在从旧博客到markdown的转换过程中，还存在一种中间格式，就是标准的Wordpress导出文件格式，这是一种.xml文件。Wordpress是一种在国外受到广泛支持的博客系统，因此相关的工具集非常丰富。通过相当长时间的搜索、分析与比较，我得到了一个最终可用的工具集。如下：</p>

<ul>
<li>通过BlogToWordpress来将旧博客转到Wordpress导出文件
<ul><li>它支持sina、sohu、csdn、163、baidu、天涯博客等等很多种国内的博客。</li>
<li>它会抓取图片等文件作为附件保存到指定目录。</li>
<li>cnblogs或其它博客可以考虑先用工具转成markdown文件的方法，例如使用<a href="https://github.com/yanyingwang/cnblog2jekyll">cnblog2jekyll</a>中的generate<em>markdown</em>all。</li></ul></li>
<li>通过wp2md来将Wordpress导出的.xml转换到Markdown格式.md
<ul><li>我最终使用的是Ghost博客系统，</li></ul></li></ul>]]></description><link>http://aimingoo.github.io/1-1719.html/</link><guid isPermaLink="false">b3d847c3-85a6-489c-bfee-e8096c3c884c</guid><category><![CDATA[博客]]></category><category><![CDATA[Javascript]]></category><category><![CDATA[Ghost]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Tue, 23 May 2017 05:38:05 GMT</pubDate><content:encoded><![CDATA[<p>在这一系列的博客中，我将仔细地记录我搭建这个博客的全部过程、工具，以及诸多技巧。</p>

<h2 id="1blogtowordpress">1. 如何迁移你的博客 - 推荐BlogToWordpress</h2>

<p>确实有很多工具来帮助你将历史、陈旧的博客迁到某个地方，而相对来说比较新的做法，就是将博客全文导出，然后按某种格式生成成静态的页面——于是你就有了新的博客站点。</p>

<p>然而事实上并不那么容易——这些工具分种种流派以及不同的实现语言。有幸的是，综合这些尝试，我们可以找到一个较简单而又完整的工具链条：从旧博客转到markdown文件，然后再将markdown导入到新博客中去。</p>

<p>在从旧博客到markdown的转换过程中，还存在一种中间格式，就是标准的Wordpress导出文件格式，这是一种.xml文件。Wordpress是一种在国外受到广泛支持的博客系统，因此相关的工具集非常丰富。通过相当长时间的搜索、分析与比较，我得到了一个最终可用的工具集。如下：</p>

<ul>
<li>通过BlogToWordpress来将旧博客转到Wordpress导出文件
<ul><li>它支持sina、sohu、csdn、163、baidu、天涯博客等等很多种国内的博客。</li>
<li>它会抓取图片等文件作为附件保存到指定目录。</li>
<li>cnblogs或其它博客可以考虑先用工具转成markdown文件的方法，例如使用<a href="https://github.com/yanyingwang/cnblog2jekyll">cnblog2jekyll</a>中的generate<em>markdown</em>all。</li></ul></li>
<li>通过wp2md来将Wordpress导出的.xml转换到Markdown格式.md
<ul><li>我最终使用的是Ghost博客系统，所以我使用wp2ghost来直接转换成了Ghost支持的导入格式.json</li>
<li>Ghost也支持单篇或多篇.md格式文章的导入，后面会讲到使用.md的方法</li>
<li>你不必非得使用Ghost博客系统，多数新的博客系统都支持Wordpress的.xml导出文件或者独立的.md文件。</li></ul></li>
</ul>

<p>BlogToWordpress的支持站点在这里：<a href="http://www.crifan.com/crifan_released_all/website/python/blogstowordpress/">Crifan的BlogsToWordPress</a> ，但是下载是放在SourceForge上的：<a href="https://sourceforge.net/projects/blogstowordpress">https://sourceforge.net/projects/blogstowordpress</a>。</p>

<p>BlogToWordpress需要Python 2.7.2或2.x，并且需要以下依赖包/库：</p>

<ul>
<li>Python Imaging Library (PIL) </li>
<li>crifanLib</li>
<li>chardet，推荐chardet 1.0.1</li>
<li>BeautifulSoup，推荐BeautifulSoup-3.0.6.</li>
</ul>

<p>除了PIL之外其它三个包/库已经包含在BlogsToWordpress的发布包(v18.3)里了，而PIL是可选安装的（只是在极少数情况下才会用到）。所以，总的来说BlogsToWordpress也是即解压即用的。</p>

<p>我在mac上使用的命令如下（SourceForge上也有windows .exe版本，可以尝试）：</p>

<pre><code class="language-bash"># 1. 下载BlogsToWordPress
&gt; curl -L 'https://sourceforge.net/projects/blogstowordpress/files/v18.3/BlogsToWordpress_v18.3_2014-05-23.7z/download' -o BlogsToWordpress_v18.3_2014-05-23.7z
&gt; 7z x BlogsToWordpress_v18.3_2014-05-23.7z

# 2. 生成调用Stub shell script
&gt; echo 'python BlogsToWordpress.py --maxXmlSize 0 --googleTrans no --wpPicPath "/bkImages" -s "$1"' &gt; runner.sh

# 3. 运行脚本
&gt; bash runner.sh "http://blog.sina.com.cn/aimingoo" | tee BlogsToWordpress.log

# 4. 归并文件到目录中
#    - BlogsToWordPress根据url中的UserName部分来生成下载文件的目录，本例中是aimingoo
#    - 脚本中指定的wpPicPath参数会使.xml中的图片url修正，但下载文件仍然是在aimingoo/pic目录中，所以需要更名
&gt; mv WXR_*.xml aimingoo/
&gt; mv BlogsToWordpress.log aimingoo/
&gt; mv aimingoo/pic aimingoo/bkImages
&gt; mv aimingoo blog.sina.com.cn-aimingoo
</code></pre>

<p>如果你需要处理更多的博客网站，那么只需要重复第3~4步即可。</p>

<h2 id="2ghost">2. 用本地博客导入 - 例如Ghost</h2>

<p>如果你得到的是一批Markdown格式（.markdown或.md）的文件，以及用相对目录来保存的图片等附件——注意Ghost使用导入时也支持绝对路径，那么你可以直接将它们导入到支持该格式的本地博客中，例如Ghost。</p>

<h3 id="21">2.1 搭建本地博客</h3>

<p>所谓本地博客，就是一个你在的电脑上运行的，在浏览器中可以使用</p>

<blockquote>
  <p><code>http://localhost/ ...</code></p>
</blockquote>

<p>来浏览的博客系统。我们下面就用Ghost来搭一个。</p>

<p>我在mac上使用的命令如下（应该可以在Windows上安装nodejs并搭建Ghost，但我没有试过）：</p>

<pre><code class="language-bash"># 获取和解压Ghost
&gt; curl -L https://ghost.org/zip/ghost-latest.zip -o ghost.zip
&gt; unzip -uo ghost.zip -d ghost
&gt; cd ghost

# 使用npm来安装Ghost
#    - 如果你没有安装brew，那么参考下面的地址安装一份先
#    - https://brew.sh/index_zh-cn.html
&gt; brew install node
&gt; npm install --production

# 将Ghost运行在开发者模式上
&gt; npm start
Ghost is running in development...  
Listening on 127.0.0.1:2368  
Url configured as: http://aimingoo.github.io  
Ctrl+C to shut down  
</code></pre>

<h3 id="22">2.2 准备导入文件</h3>

<p>我们之前已经得到了从旧博客网站中导出的两类文件：</p>

<ul>
<li>Wordpress导出格式的*.xml，以及（有可能的）bkImages目录；或</li>
<li>一批Markdown格式的文件</li>
</ul>

<p>如果你直接使用Markdown文件，那么将它们打包在一个.zip文件中即可。如果你使用.xml，那么需要先用wp2ghost来做一下转换（你也可以考虑通过其它工具直接转换成.md）。</p>

<p>使用wp2ghost的好处是它生成的是.json文件，方便我们用其它工具或简单脚本来做进一步的检测、优化或其它处理。例如我写了一个脚本来做下面这些事：</p>

<ul>
<li>将url-encode的文本解码成可读格式：有些文章的标题或tags都使用了编码，直接导入Ghost是没法看的</li>
<li>移除多余的tags：有些博客的tags是parse文章得到的，茫茫多</li>
<li>修正author id：博客中的作者与Ghost中作者是没有对应关系的，需要修正</li>
<li>……</li>
</ul>

<p>等等。</p>

<p>下面的示例说明对.xml文件的处理：</p>

<pre><code class="language-bash"># 1. 安装wp2ghost
#    - 也可以直接使用git clone ...
&gt; svn export https://github.com/jonhoo/wp2ghost/trunk wp2ghost
&gt; cd wp2ghost
&gt; npm install

# 2. 从Wordpress转换到json文件
#    - 设文件位于~/blog.sina.com.cn-aimingoo中
#    - 注意wp2ghost.js一次只能转换一个文件，下面用*.xml是省掉写文件名
&gt; node bin/wp2ghost.js ~/blog.sina.com.cn-aimingoo/*.xml &gt; ghost-tmp.json

# 3. 切换工作目录
&gt; mv ghost-tmp.json ~/blog.sina.com.cn-aimingoo/
&gt; cd ~/blog.sina.com.cn-aimingoo/

# 4. 获取putrefy.js脚本
#    - 请直接修改putrefy.js源代码，注意它并不是通过命令行参数来配置的
&gt; curl -L https://github.com/aimingoo/ghost-utils/raw/master/putrefy.js -o putrefy.js
&gt; node putrefy.js ghost-tmp.json &gt; ghost.json
&gt; zip -r ghost_archive.zip ghost.json bkImages
</code></pre>

<p>建议你根据你的博客的需求来修改putrefy.js中的参数配置，某些情况下（例如你要合并多个博客），那么在转换中所需要的putrefy.js脚本会各个不同，因此需要为它们配置各自适用的putrefy.js脚本。</p>

<p>现在你所得到的<code>ghost_archive.zip</code>就是Ghost可用的导入文件了。</p>

<h3 id="23">2.3 导入到本地博客</h3>

<p>我们刚刚启动了本地Ghost博客：</p>

<pre><code class="language-bash"># 在你的Ghost安装目录中（例如~/ghost）执行如下命令
&gt; npm start
</code></pre>

<p>缺省情况下，在你用<code>http://aimingoo.github.io/</code>访问它时会看到了一个初始状态的博客。你需要为自己建立一个博客账号，登录并管理它。这时，你应该访问<code>http://aimingoo.github.io/ghost/</code>。</p>

<p>建立博客账号的过程中，在第二步（输入你的名字、邮箱和初始密码）时会要求你设置博客的标题，忘掉了也没关系，你可以随时在管理界面的<code>Settings -&gt; General</code>中去修改它。</p>

<p><img src="http://aimingoo.github.io/content/images/ghost_startup_step-1.png" alt="ghost_startup_step-1"></p>

<p>另外，在第三步时会提示你邀请你的博客团队成员（Ghost是一个多人博客平台），请直接跳过忽略。有关这个功能我们将来再讨论——你随时可以在管理界面的<code>Team</code>功能中发起邀请。</p>

<p><img src="http://aimingoo.github.io/content/images/ghost_startup_step-2.png" alt="ghost_startup_step-2"></p>

<p>初始化错了也没关系，来到你的Ghost安装目录，删除数据库文件，然后重启Ghost就可以了。</p>

<pre><code class="language-bash"># 你可能需要先用Ctrl + C键退出正在运行的Ghost
#    - 以开发版本模式运行的Ghost是没有驻留在后台的
&gt; rm content/data/ghost-dev.db
&gt; npm start
</code></pre>

<p>然后我们来到<code>Settings -&gt; Labs</code>中，使用<code>import</code>将我们此前准备好的.zip文件导入即可。如果一切顺利，你会在左下角看到导入成功的提示；如果失败，红色提示会出现在当前页面的顶端。</p>

<p>最后，建议你开启<code>Labs -&gt; Enable Beta Features</code>中的Public API选项，有许多第三方主题需要使用到这些博客功能。</p>

<h2 id="3ghost">3. 迁移与Ghost使用小结</h2>

<p>其它的一些注意事项包括：</p>

<ul>
<li><p>你创建的第一个博客账号（也就是作为管理员的这个）是不需要验证mail地址的，但使用邀请功能加入的其它账号就需要验证。</p></li>
<li><p>导入博客的过程中确实会出现一些意外，这是我写上面提到的<code>putrefy.js</code>工具的原因。如果你在导入过程中遇到问题，建议你尝试改写这份代码，或者将出问题的导入文件发给我——我尽量替你的博客内容保密，尽管它作为博客原本是公开的。呵呵</p></li>
<li><p>确实有非常多的途径来完成本文中描述的过程，但坦率地说，我尝试过很多了，目前这种算是最……可行的。</p></li>
<li><p>一旦你将.zip导入到Ghost，你就可以在Ghost管理和更新它们，发布或静态化等等。因此我在后续文章中提到的过程再与传统博客（例如下载、转换的那些文件）就没什么关系了。</p></li>
<li><p>如果你备份content整个目录（例如Ghost导入的图片位于<code>./content/images</code>目录中），那么你可以随时重装Ghost，或者更新至新的版本而不会丢失数据。</p></li>
<li><p>Ghost导入的博客文章是可能存在格式问题的，也可能导致你正在使用的Ghost博客主题（缺省是Casper主题，在<code>Settings -&gt; General</code>中设置）格式混乱或无法使用，请自行编辑它们。我事实上将所有历年文章逐一更新过，并尽量使用了markdown格式——这样以后管理起来就方便了。</p></li>
<li><p>Ghost的数据库在<code>./content/data</code>目录中，对应于开发版的是<code>content/data/ghost-dev.db</code>文件。如果你安装过sqlite，那么可以直接用命令行来操作它——或者e用你喜欢的GUI工具也行。例如：</p></li>
</ul>

<pre><code class="language-bash">  &gt; sqlite3 -header -column ghost-dev.db 'select id, name, email from users'
  id          name        email           
  ----------  ----------  ----------------
  1           aimingoo    aiming@gmail.com
</code></pre>

<p>记住这个<code>id = 1</code>，它是你的管理帐户id。在导入用的ghost.json文件中，它也被称为<code>author_id</code>，在将来做多账户操作时你可能需要了解它。</p>

<ul>
<li>对于程序员来说这绝对是个好消息，毕竟我们可以直接用SQL来操作所有的博客文章了。例如以前托管的下载地址更新了，但是在哪些文章中用到它们了呢？不错，用like操作去查找一下posts表中的markdown或html字段就可以了。例如：</li>
</ul>

<pre><code class="language-bash">  &gt; sqlite3 ghost-dev.db 'select id, title from posts where markdown like "%skydrive%"'
  1519|《大道至简》的幕后故事：终结篇、勘误和PDF下载
  1595|近期的公开资源汇总(已完整)~
  ...
</code></pre>

<ul>
<li><p>如果你得到上述的<code>id</code>值，那么可以直接在Ghost的管理界面中去编辑它——Ghost管理界面没有搜索功能。例如直接在浏览器上使用如下地址：</p>

<blockquote>
  <p><code>http://aimingoo.github.io/ghost/editor/1519/</code></p>
</blockquote></li>
</ul>]]></content:encoded></item><item><title><![CDATA[再一次开始更新博客]]></title><description><![CDATA[<h2 id="">新博客的开张</h2>

<p>最近在家养病，开始闲出了些工夫，于是决定把之前散落的博客整合起来，以后也有时间做些更新，有个能认真写写文字的地方。</p>

<p>于是就有了这个在github上的新站。这里把以前在</p>

<ul>
<li>新浪博客 - <a href="http://blog.sina.com.cn/aimingoo">http://blog.sina.com.cn/aimingoo</a></li>
<li>CSDN博客 - <a href="http://blog.csdn.net/aimingoo">http://blog.csdn.net/aimingoo</a></li>
</ul>

<p>上面分开写的内容全部放在了一起。并且接下来会把“麦秸的垛”也逐渐迁移过来。</p>

<p>新博客使用的是ghost博客系统，使用buster发布成静态网页，然后提交到github和ghpages来做托管。里面涉及到不少的技术细节，所以最近也会发一些文章来介绍这些。</p>

<p>在整个博客的内容开始稳定更新之前，近期会有一些小的更新会放在本篇文章最后。</p>

<h3 id="20170520">2017.05.20</h3>

<ul>
<li>全站交付。</li>
<li>2009年之后的博客文章全部进行了修订。</li>
</ul>]]></description><link>http://aimingoo.github.io/1-1718.html/</link><guid isPermaLink="false">30c15750-3f8f-423a-bf39-f305763c1425</guid><category><![CDATA[杂谈]]></category><category><![CDATA[博客]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sat, 20 May 2017 16:00:48 GMT</pubDate><content:encoded><![CDATA[<h2 id="">新博客的开张</h2>

<p>最近在家养病，开始闲出了些工夫，于是决定把之前散落的博客整合起来，以后也有时间做些更新，有个能认真写写文字的地方。</p>

<p>于是就有了这个在github上的新站。这里把以前在</p>

<ul>
<li>新浪博客 - <a href="http://blog.sina.com.cn/aimingoo">http://blog.sina.com.cn/aimingoo</a></li>
<li>CSDN博客 - <a href="http://blog.csdn.net/aimingoo">http://blog.csdn.net/aimingoo</a></li>
</ul>

<p>上面分开写的内容全部放在了一起。并且接下来会把“麦秸的垛”也逐渐迁移过来。</p>

<p>新博客使用的是ghost博客系统，使用buster发布成静态网页，然后提交到github和ghpages来做托管。里面涉及到不少的技术细节，所以最近也会发一些文章来介绍这些。</p>

<p>在整个博客的内容开始稳定更新之前，近期会有一些小的更新会放在本篇文章最后。</p>

<h3 id="20170520">2017.05.20</h3>

<ul>
<li>全站交付。</li>
<li>2009年之后的博客文章全部进行了修订。</li>
</ul>]]></content:encoded></item><item><title><![CDATA[确定的世界 - The Promise's World]]></title><description><![CDATA[<h1 id="thepromisesworld">确定的世界 - The Promise’s World</h1>

<p>—— Promise的逻辑以及在Lua中的实现  </p>

<blockquote>
  <p>本文基于如下项目(ES6 Promise in lua v1.0.1)：  </p>
  
  <blockquote>
    <p><a href="https://github.com/aimingoo/Promise">https://github.com/aimingoo/Promise</a>  </p>
  </blockquote>
</blockquote>

<h2 id="">有这样一个世界</h2>

<p>有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子：     </p>

<p><img src="http://img.blog.csdn.net/20150810174734751" alt="The Promise" title="">     </p>

<p>那么，这个世界是确定的么？  </p>

<p>首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。  </p>

<p>然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“</p>]]></description><link>http://aimingoo.github.io/1-196.html/</link><guid isPermaLink="false">c5aecbe8-bfd2-4086-998d-940262d8320b</guid><category><![CDATA[Javascript]]></category><category><![CDATA[Promise]]></category><category><![CDATA[OpenSource Project]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Mon, 10 Aug 2015 09:35:00 GMT</pubDate><content:encoded><![CDATA[<h1 id="thepromisesworld">确定的世界 - The Promise’s World</h1>

<p>—— Promise的逻辑以及在Lua中的实现  </p>

<blockquote>
  <p>本文基于如下项目(ES6 Promise in lua v1.0.1)：  </p>
  
  <blockquote>
    <p><a href="https://github.com/aimingoo/Promise">https://github.com/aimingoo/Promise</a>  </p>
  </blockquote>
</blockquote>

<h2 id="">有这样一个世界</h2>

<p>有这样的一个世界在持续地向前推进着，这个世界充满着无穷多个选择，也就是说有无穷多的可能；但对每一个选择来说，存在决定/未决两种状态，如果已经决定，则只能有yes/no两种结果之一。这个世界看起来就是下面这个样子：     </p>

<p><img src="http://img.blog.csdn.net/20150810174734751" alt="The Promise" title="">     </p>

<p>那么，这个世界是确定的么？  </p>

<p>首先，这个世界是有状态的，那些看起来存在y/n两个分支的节点，就存在于这种状态——选择还没有发生，就还有可能。  </p>

<p>然而无论某一个节点的选择是什么，这个的世界的结果（的规模）是确定的，它必然演进到世界最下层中的状态的某一个。只不过这个最下层的规模足够大，所以在世界中的“未决”因素足够多的情况下，这个世界就看起来“一切皆有可能”而已。  </p>

<p>而这也就是Promise’s World，确定的世界。  </p>

<h2 id="">什么是已决定的？</h2>

<p>到底什么是已“确定”的呢？当你举起手枪对着自己的头的时候，这个行为是“确定”的吗？  </p>

<p>答案是：这个行为是“确定”的，你只是没有“决定”而已。这个称为“用枪瞄准自己的头”的系统很确定：要么是死，要么是不死——死或不死都是确定的。在语言中，你可以理解为：布尔值是确定的值，它确定的是yes/no。  </p>

<p>布尔值被理解为一个“已决定（它的结果行为）的”系统。同理，所有值类型的数据，所有有已决定结果的数据，都是确定的。这在promise中被这样定义下来：  </p>

<pre><code class="language-lua">local function promised_y(self, onFulfilled)  
    -- ...
end

-- ...

-- promise for basetype
local number_promise = setmetatable({andThen = promised_y}, promise)  
local true_promise   = setmetatable({andThen = promised_y, true}, promise)  
local false_promise  = setmetatable({andThen = promised_y, false}, promise)  
number_promise.__index = number_promise  
nil_promise.andThen = promised_y  
</code></pre>

<p>Ok，这里的代码的意思是说，number/string/boolean，以及nil这些值的行为(andThen)都是已决定的，指向promised_y()。  </p>

<blockquote>
  <p>javascript的promise规范中，这里被称为.then()方法，而拥有这样一个方法的对象被称为thenable object。这个方法有确定的接口：  </p>
  
  <blockquote>
    <p>function (onFulfilled, onRejected)  </p>
  </blockquote>
  
  <p>但在lua中由于then是保留字，所以只好用andThen作为方法名（也有用next来作为方法名的）。  </p>
</blockquote>

<p>同样，一个对象(lua中的table)也是已决定的，在promise中它与一般的value并没有不同。因此，在lua中的Promise.resolve(value)实现为如下：  </p>

<pre><code>function Promise.resolve(value)  
    local valueType = type(value)
    if valueType == 'nil' then
        return nil_promise
    elseif valueType == 'boolean' then
        return value and true_promise or false_promise
    elseif valueType == 'number' then
        return setmetatable({(value)}, number_promise)
    elseif valueType == 'string' then
        return value
    elseif (valueType == 'table') and (value.andThen ~= nil) then
        return value.catch ~= nil and value -- or, we can direct return value
            or setmetatable({catch=promise.catch}, {__index=value})
    else
        return setmetatable({andThen=promised_y, value}, promise)
    end
end  
</code></pre>

<p>留意这里的string类型，它与其它value略有区别，是因为string类型在lua中正好是有meta type的，因此可以直接通过修改元表来让它“变得与promise object”行为一样。至于其它，就必须包装一下了。  </p>

<blockquote>
  <p>对于对象(object/table)来说，它可能有三种情况：  </p>
  
  <blockquote>
    <ul>
    <li>如果为thenable object（即，有.andThen而没有.catch方法），则给他一个catch()方法；  </li>
    <li>如果为promise object，则直接返回；  </li>
    <li>如果为普通object（即，其它样式的lua table），则包装成promise object并返回。  </li>
    </ul>
  </blockquote>
</blockquote>

<p>那么，什么是promise object呢？  </p>

<h2 id="promiseobjectandpromiseclass">promise object and Promise class</h2>

<p>按照协议，promise框架必须实现promise object和Promise class。参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">ECMAScript 2015(ES6)</a>，包括如下这些类方法：  </p>

<blockquote>
  <p>Promise.new(func)     </p>
  
  <p>Promise.resolve(value)     </p>
  
  <p>Promise.reject(reason)     </p>
  
  <p>Promise.all(arr)     </p>
  
  <p>Promise.race(arr)  </p>
</blockquote>

<p>以及对象方法：  </p>

<blockquote>
  <p>promise:andThen(onFulfilled, onRejected)     </p>
  
  <p>Promise:catch(onRejected)  </p>
</blockquote>

<p>五种类方法之任一都将得到一个promise object。确切地说，你也只能通过这五种方法来得到promise object，哪怕只是数字1，也应当这样来写：  </p>

<pre><code class="language- lua">local promise_number_1 = Promise.resolve(1)  
</code></pre>

<p>这些类方法有些“潜在的/隐式地”将值变成promise的能力，例如：  </p>

<blockquote>
  <p>Promise.all(arr)  </p>
</blockquote>

<p>严格地来说all()要处理的是一个promise object array，为了这个目的，事实上它会将arr中的每个成员都尝试转换(resolve)以得到promise object。因此下面两种方法：  </p>

<pre><code class="language- lua">Promise.all([1,2,3]):andThen(..)  
-- vs.
Promise.all([  
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.resolve(3)
]):andThen(..)
</code></pre>

<p>事实上是一样的效果。  </p>

<p>而具体到一个promise object，它在lua中描述的结构是一个table(array)。初始化时，它只有一个元素（我通常称之为p[1]）：  </p>

<blockquote>
  <p>a_promise_instance = { PENDING }  </p>
</blockquote>

<p>PENDING表明这个promise是未决的。如果已决定，例如上面提到过的“所有的”值，那么p[1]就存放的是那个具体的值。例如：  </p>

<pre><code class="language- lua">-- boolean promise object
{true}, {false}
-- number promise object
{1}, {1.23}, ..
-- object promise object
{{}}, {obj}, ..
-- userdata/function/coroutine/..
{userdata}, {func}, {co}, ..
-- nil promise object
{}
-- string is string, ^^.
'abcd'  
-- non-promised promise object
{PENDING}
</code></pre>

<p>在5种Promise类方法中，promise.resolve()和reject()得到的是一个已决定的、值的promise对象（或者，当传入promise object时，返回的是它自身，注1）。而其它三种方法，得到的都将是一个non-promised的对象——也就是说，这些情况下p[1]存放的是PENDING。  </p>

<blockquote>
  <p>注1: 在JavaScript中，这种情况仍将得到一个新的promise，而lua中得到传的的promise object。这并不会带来使用效果上的差异。  </p>
</blockquote>

<h2 id="lazyresolver">推迟决策：lazy resolver</h2>

<p>到目前为止，在我们具体讨论PENDING之前，所谓的promise object，以及整个的promise’s world其实都很简单。但仔细看去，这也不过是最开始所描绘的世界中左边的那一半而已——这一半都是promised，是确知的，已决定的。  </p>

<p>整个Promise世界的秘密(或魔法、活力)都在右边那一部分。也就是p[1]中写着PENDING的未决的那些结点。这些结点是推迟决策的，它什么时候到来是未知的，由于状态未决，所以也有不可确知的结果。仍然以那把瞄着你的头的枪为例，板机并不是你在扣着，而是在1公里以外的一个狙击手的手上。现在（当下）的问题是，你处于PENDING状态，既不知道那个狙击手是不是已经被第三者干掉了，还是已经扣下了板机而子弹是在飞过来的路上。PENDING这个状态是未决的，它未决的是你的生死，直到p[1]被填上一个值——如同子弹真正地射入你的头脑，或者邦德站在你的面前告诉你说“他死了”。  </p>

<p>p[1]将被填入“射击”这个行为发生的结果(value/result)，或这个行为没有发生的原因(reson)。无论二者之一为何，这个p[1]都是你现在（当下）所不确知的，所以尽管我们有千般主意，也只能等待value/reson两种结果被确认。这“千般主意”我们都可以一一想好，并且用promise:andThen()关联给这个promise，但……我们就是得等着结果发生。所以，Promise in lua为此设计了lazy对象，每一个用andThen添加进来的“主意”都是一个lazy，被追加到promise object数组的末尾——好的，我想你已经知道了，就是p[2]..p[n]，或称之p[2..n]。  </p>

<p>p[2..n]是一个个独立的lazy object。每个lazy表达为三个元素的数组：  </p>

<blockquote>
  <p>{promise, onFulfilled, onRejected}  </p>
</blockquote>

<p>由于一个PENDING promise是未决的，所以当它决定时至少要做的（第一个） 行为就是将真正的结果填入p[1]。所以由new/all/race这三种方法来创建的（未决的）promise的内部都会调用resolver()来实施这一决策：  </p>

<pre><code class="language- lua">function Promise.all(arr)  
    local this, result, count = setmetatable({PENDING}, promise), {}, #arr

    -- ...
    resolver(this, result, sure)
    -- ...
end

function Promise.race(arr)  
    local this, result, count = setmetatable({PENDING}, promise), {}, #arr

    -- ...
    resolver(this, result, sure)
    -- ...
end

function Promise.new(func)  
    local this = setmetatable({PENDING}, promise)
    pcall(func,
        function(value) return resolver(this, value, true) end,
        function(reason) return resolver(this, reason, false) end)
    -- ...
end  
</code></pre>

<p>而这里的“决策（resolver）”，不过是对确定的结果(value)采用确定的行为——将p[1]赋值，并重置andThen()方法：  </p>

<pre><code class="language- lua">local function resolver(this, resolved, sure)  
    -- ...
        this[1], this.andThen = resolved, sure and promised_y or promised_n
    -- ...
end  
</code></pre>

<p>以及推进所有p[2..n]中的行为：  </p>

<pre><code class="language- lua">local function resolver(this, resolved, sure)  
    -- ...
        for i, lazy in next, this, 1 do     -- 2..n
            pcall(resolver, lazy[1], promised(resolved, (sure and lazy[2] or lazy[3])), sure)
            this[i] = nil
        end
    -- ...
</code></pre>

<p>而已。然而考虑到promise规范中允许andThen()返回一个non-promised的promise object，因此resolver()将检测这种状态，并将与这个promise object对应的lazy添加到尾部。  </p>

<h2 id="promised">最后的promised</h2>

<p>现在，promise’s world中的结点要么是已决的(promised promise)。这种情况下它可能是一个一般值转换过来(Promise.resolve)的，因而只有左侧的边(promise<em>y)，也可能是一个promised promise object，因此具有两条边之一。无论如何，这样的一个promise object的p[1]存放着确定的值(value)，而andThen()指向一个确定有结果的行为：promised</em>y、promised<em>n，或promised</em>s。而这三个行为都必然是最终确定的：promised()  </p>

<pre><code class="language- lua">local function promised(value, action)  
    local ok, result = pcall(action, value)
    return ok and Promise.resolve(result) or Promise.reject(result)
end

local function promised_s(self, onFulfilled)  
    return onFulfilled and promised(self, onFulfilled) or self
end

local function promised_y(self, onFulfilled)  
    return onFulfilled and promised(self[1], onFulfilled) or self
end

local function promised_n(self, _, onRejected)  
    return onRejected and promised(self[1], onRejected) or self
end  
</code></pre>

<p>要么，就是还未决定的(non-promised promise)。因此它的p[1]中写着PENDING，andThen()指向一个将一切未知塞到p[2..n]的函数——既不是左边的y，也不是右边的n。  </p>

<p>而这，就是promise’s world的全部了：  </p>

<blockquote>
  <p>做你所决定的，为那些你所不能决定的做准备。  </p>
</blockquote>

<p>这一切，要等到PENDING发生变化，推迟决策生效（resolver过程启动）时才会有结果——所以resolver()函数是唯一在yes/no之外，你能看到有promised()调用的地方，那是未来将会发生的一次promised。一旦发生，non-promised was promised。  </p>

<h2 id="">示例</h2>

<p>有一个简单的示例，然而绝大多数lua promise框架都run不过。试试看吧：  </p>

<pre><code class="language-lua">---
-- A完成后，根据a做BCD三件事，再根据BCD的结果做E。
---

Promise = require('Promise')

A = function() return 10 end  
B = function(a) print(a * 2) end  
C = function(a)  
    print(a * 4)
    return Promise.resolve('ok')
end  
D = function(a) print(a * 3) end  
E = function(result)  
    local b, c, d = unpack(result)
    print(b, c, d)
    return Promise.reject('FIRE')
end

-- promise_A = Promise.resolve(A())
promise_A = Promise.new(function(resolve, reject)  
    local ok, result = pcall(A)
    return (ok and resolve or reject)(result)
end)  
promise_B = promise_A:andThen(B)  
promise_C = promise_A:andThen(C)  
promise_D = promise_A:andThen(D)

promises = {promise_B, promise_C, promise_D}  
Promise.all(promises)  
    :andThen(E)
    :catch(function(reson)
        print(reson)
    end)
</code></pre>]]></content:encoded></item><item><title><![CDATA[前端要给力之：红绿灯大战中的火星生命-Promise]]></title><description><![CDATA[<h1 id="">传说的开始</h1>

<p>前些日子看了三集的《浪客剑心》的电影版，它的最后一集是叫“传说的终结”。这几个字让我很感概：我不是剑心迷，我的一些80、90后朋友却是看着剑心漫画长大的，因此他们常讲的一些梗在我看来便如同究极深奥的科学谜题；然而当我有一天终于要看这“传说中的剑心”的时候，它却“终结”了。  </p>

<p>我看这个片子纯粹是因为打得好看，看完也就知道“剑心是个在脸上画叉叉的高颜值冷男（好吧我承认为了显示我还算个跟得上时代的人我把最近听到的几乎所有的流行词以及流行的文字写法全用上了）”。然而面对这样的尴尬，究其根源却在于我是个不知道“传说的开始”的家伙。  </p>

<p>所以，今次讲Promise，请容我从这场“红绿灯大战”的起源讲起，更早的，再讲讲我与Promise的故事。至于这样做会不会让读者对Promise这个东西有更深入或更新颖的了解，我实在不知，我只是觉得：当一个传说已经过去，而去看这个故事的人既然不知道它的起始，真是悲剧。  </p>

<h2 id="winterpromise">看到winter的代码，我的第一反应是：全无promise的精髓</h2>

<p>公历年2015年4月10日，这天中午，天气晴好，时间是正正经的12:00的时候，裕波同学在微博上@我跟hax：  </p>

<blockquote>
  <p>谁来当裁判？  </p>
</blockquote>

<p>这要裁判的便是@</p>]]></description><link>http://aimingoo.github.io/1-195.html/</link><guid isPermaLink="false">fa384c49-09e6-4ac8-8140-b53d9d436ea2</guid><category><![CDATA[Javascript]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Sun, 12 Apr 2015 13:35:00 GMT</pubDate><content:encoded><![CDATA[<h1 id="">传说的开始</h1>

<p>前些日子看了三集的《浪客剑心》的电影版，它的最后一集是叫“传说的终结”。这几个字让我很感概：我不是剑心迷，我的一些80、90后朋友却是看着剑心漫画长大的，因此他们常讲的一些梗在我看来便如同究极深奥的科学谜题；然而当我有一天终于要看这“传说中的剑心”的时候，它却“终结”了。  </p>

<p>我看这个片子纯粹是因为打得好看，看完也就知道“剑心是个在脸上画叉叉的高颜值冷男（好吧我承认为了显示我还算个跟得上时代的人我把最近听到的几乎所有的流行词以及流行的文字写法全用上了）”。然而面对这样的尴尬，究其根源却在于我是个不知道“传说的开始”的家伙。  </p>

<p>所以，今次讲Promise，请容我从这场“红绿灯大战”的起源讲起，更早的，再讲讲我与Promise的故事。至于这样做会不会让读者对Promise这个东西有更深入或更新颖的了解，我实在不知，我只是觉得：当一个传说已经过去，而去看这个故事的人既然不知道它的起始，真是悲剧。  </p>

<h2 id="winterpromise">看到winter的代码，我的第一反应是：全无promise的精髓</h2>

<p>公历年2015年4月10日，这天中午，天气晴好，时间是正正经的12:00的时候，裕波同学在微博上@我跟hax：  </p>

<blockquote>
  <p>谁来当裁判？  </p>
</blockquote>

<p>这要裁判的便是@寒冬winter 的一段代码（winter的代码#31，<a href="http://code.w3ctech.com/detail/31" title="代码在这里">在这里</a>）。这段代码是winter向@十年踪迹 同学宣战的，原文是：  </p>

<blockquote>
  <p>我表示不服！来PK呀！  </p>
</blockquote>

<p>代码在code.w3ctech上的标题也是两个字母：pk。  </p>

<p>这就是后来史书家所称的“红绿灯大战”了。我随后回复winter的微博，写到：  </p>

<blockquote>
  <p>老实说，你写得不怎么样。全无promise的精髓。  </p>
</blockquote>

<p>我一开始就把自己搅进了战局，这样不好。  </p>

<p>不过也正是这样，才有了后面的好故事。至于现在，看客们请耐点心，请容我再讲讲更早一点的故事。  </p>

<h2 id="promise">其实我了解Promise也是新近的事情</h2>

<p>hax总是跟近最新的ECMAScript规范以及JavaScript圈子的新近话题。相反的，我则不同，我不是太追新，在JS/前端的圈子中也总是伪前端自居。所以，请原谅我这么迟才了解到Promise这个东西，甚至于我对nodejs的callback hell有深切的感受也还是新近的事情。  </p>

<p>这是在今年元旦前后，我因为一个项目要写RESTApi接口，而选用了nodejs来写一个test case。因此，大家可以想见的，我一定会面临callback，并显而易见地会痛恨之。所以，我就就写了一个名为Continuer的项目，源代码中还写着“Callback Must Die!”。  </p>

<p>所以，我最初想用来搞掉callback的方法，其实是表现在Continuer这个项目中的（<a href="https://github.com/aimingoo/continuer">continuer@github</a>）。  </p>

<p>这个项目开源了并在微博上引起了一些前端同学的兴趣。这个时候便有人提到了Promise，质疑为什么在有了Promise的情况下还要做Continuer这样的东西。随后我就在翻读微博的时候，看到了hax与@孢子响马 同学的吵架贴，<a href="http://weibo.com/2041028560/BDFy7hcIT">在这里在这里，快来看呀，打架好好看</a>。hax向来被我称为吵架王的（有没有周星星电影的即视感），所以他在回复时言辞激烈那是再正常不过了——所以你看我就说“hax这10年来风格依旧，奥柏伦亲王真是大爱啊（这个梗要到“冰与火之歌”中去找）”，这完全符合他“认为正确就要誓死悍卫（或称为死性不改）”的风格。  </p>

<p>hax跟孢子响马讨论的是fibjs中解决异步的方式问题，hax的主要观点是  </p>

<blockquote>
  <p>“fib的问题并不是说他用的人少所以不好，而是说你选的不兼容道路导致工程上要采纳这个方案有很多障碍。而这障碍来自于一个没有明显优势（如果不是劣势）的编程模型。”  </p>
</blockquote>

<p>在讨论其中关于“用的人多人少”的问题时，hax批评一种“（你得）用了才知道好不好”的观点时，说了一段我非常非常在意的话：  </p>

<blockquote>
  <p>第一，你不可能所有东西都尝试一遍。第二，有些东西你抓住重点看一下就可以推导出结果了。当然我的具体意见可能是错的，可能是出于误解，可能是某些我的基本前提不对，但是希望看到针对性的反驳而不是简单来一句“爱用不用”。  </p>
</blockquote>

<p>hax的意思是说：有些正确性是可以推论出来的，并不因为实用经验多寡的而改变。这是我这么些年来对hax的了解中，他讲过的最哲学而又最逻辑的话（其它的大多数时候，他的哲学正确与逻辑正确是分离的，^^.）。  </p>

<p>好了，这也就是我了解Promise的源起，它来自于另一场战争。那场战争比今次所讨论的要激烈得多。许多猛士在那场地战争中倒下了。这也包括我。我后来因为这个缘故写了一篇《关于Continuer的What与Why》来解释我为什么写Continuer这个项目（<a href="https://github.com/aimingoo/continuer/wiki/%E5%85%B3%E4%BA%8EContinuer%E7%9A%84What%E4%B8%8EWhy">在这里</a>），这篇文字把我面临的问题锁定在“需要一个顺序执行的序列（以用于run testcases）”。在这个问题下面，写一个轻量的Continuer模块，并不算得“一件多么不正确”的事。  </p>

<p>hax后来接受了我的观点，一半是给我面子，另一半大概是懒得跟我吵架（我是吵架王的那个时代已经一去不返了，hax同学请继续坚持，我们这代人就靠你了）。因为，我在上面这篇文章里说Promise“在概念上仍然是基于事件触发的”，在我如今看来，这句话是大大的错了。  </p>

<p>我相信这样的问题hax是看得到的。  </p>

<h2 id="promise">我与Promise后来发生的故事</h2>

<p>我原本打算春节期间用点时间来讨论一下javascript中关于异步的几种解决方案的，但当时忙于ngx_cc项目的开源所以耽误了。而春节之后，公司的项目追得又特别紧，所以一直拖着。  </p>

<p>到了3月初的时候，公司项目中有一个地方需要设计一种编程模型。这种编程模型是什么样的呢？它将所有的东西都理解为“一个带有服务能力的数据”，这在scala里，就是一个actor。Ok，当任何东西都变成这样一个“独立存在的actor”时，我们该怎么编程呢？  </p>

<p>这个时候我想到了Promise。Promise编程的核心思想其实是：  </p>

<blockquote>
  <p>如果数据就绪(promised)，那么(then)做点什么。  </p>
</blockquote>

<p>假定我们设定：  </p>

<blockquote>
  <p>对于“独立存在的actor”来说，这个actor（以及actor中的部分或全部成员）是否ready，是驱动后续逻辑的唯一方式。  </p>
</blockquote>

<p>那么这种方式实现的框架，就是纯异步模式的框架了。因为它从逻辑上是纯异步的，而在数据上，也是原生的、自然的分布式的。  </p>

<p>我立即开始着手这个框架了，一方面Continuer被我抛得远远的（在实用中也发现了不少的问题），另一方面我打算写的文字也被继续搁置了。而我在这个框架上要解决的第一个问题，其实是：Lua不支持Promise。  </p>

<p>呵呵，我是要在ngx_cc这个项目上（这个项目是nginx集群通讯的，<a href="https://github.com/aimingoo/ngx_cc">在这里</a>）继续做些事情，当然得考虑到语言问题。于是就着手写了一个真正实现Promise的Lua库（你能找到的所有所有lua-promise库都达不到真正ECMAScript兼容）。做这件事的时候是在三亚。话说这次三亚的“F100技术领袖峰会（3月20-22）”到底有多么“技术领袖”呢？主要的表征之一，就是所有人中就只剩下我一个还在写代码的了。我一边开着会跟大家讨论软件工程、设计艺术、技术领导的风格与公司组织架构之间的关系以及传统企业的互联网转型过程中技术决策者的价值……等等，另一面写着这样一个Promise for Lua的库。  </p>

<p>离开三亚的时候，我跟麦子同学说：Promise库写完了。麦子同学一脸茫然和无限深情地看着我：老公，你潜水的时候像条鱼。  </p>

<h1 id="">红绿灯大战的亲历实录</h1>

<p>红绿灯大战中，我join进去的时候已经是winter的挑战了，这事实上应该是@winter 对@十年踪迹 一次还击。十年踪迹同学最早是写了这样一个例子（十年踪迹的代码#30，<a href="http://code.w3ctech.com/detail/30">在这里</a>）：  </p>

<pre><code class="language-javascript">function promiseDef(async, i, j){  
  return function(){
    var args = [].slice.call(arguments);
    var self = this;
    return new Promise(function(resolve, reject) {
      if(i != null){
        args.splice(i, 0, resolve);
      }else{
        args.push(resolve);
      }
      if(j != null){
        args.splice(j, 0, reject);
      }else{
        args.push(reject);
      }
      async.apply(self, args);
    });
  }
}

//红绿灯切换：绿 5s -&gt; 黄 2s -&gt; 红 5s 循环

var greenPromise = promiseDef(setTimeout, 0).bind(null, 5000);  
var yelloPromise = promiseDef(setTimeout, 0).bind(null, 2000);  
var redPromise = promiseDef(setTimeout, 0).bind(null, 5000);  
var traffic = document.getElementById('traffic');

(function restart(){'use strict'
  greenPromise()
    .then(function(){
      traffic.className = 'yellow';
      return yelloPromise();
    })
    .then(function(){
      traffic.className = 'red';
      return redPromise();
    })
    .then(function(){
      traffic.className = 'green';
      restart();
    });
})();
</code></pre>

<p>来说明（<a href="http://weibo.com/1558150085/CcB8uj6E2">在这里</a>）：  </p>

<blockquote>
  <p>过程抽象之promise化——用过程抽象的思路将一个普通的异步函数“变换”成promise形式~  </p>
</blockquote>

<p>而winter就写了下面这段代码来约战（winter的代码#31，<a href="http://code.w3ctech.com/detail/31" title="代码在这里">在这里</a>）：  </p>

<pre><code class="language-javascript">function turnGreen(){  
    return new Promise(function(resolve, reject) {
        traffic.className = 'green';
        resolve();
    })
}
function turnRed(){  
    return new Promise(function(resolve, reject) {
        traffic.className = 'red';
        resolve();
    })
}
function turnYellow(){  
    return new Promise(function(resolve, reject) {
        traffic.className = 'yellow';
        resolve();
    })
}
function wait5000(){  
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,5000);
    })
}
function wait2000(){  
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,2000);
    })
}

//执行！
void function (){  
    turnGreen()
    .then(wait5000)
    .then(turnYellow)
    .then(wait2000)
    .then(turnRed)
    .then(wait5000)
    .then(arguments.callee)
}();
</code></pre>

<p>我呢，我的第一反应是：winter这个也不是Promise的调调呀。我当时还并不知道@十年踪迹 的原始代码的样子，也不知道这场大战的原委。我只是觉得：  </p>

<h2 id="promise">Promise写出来怎么会是这个样子？</h2>

<p>好吧！这真的是一个问题，“Promise写出来的样子”是什么样子？我没有细思考这个问题，我就手写了一个，表示“可以是这样”（<a href="http://code.w3ctech.com/detail/41">aimingoo的代码#41, 在这里</a>）：  </p>

<pre><code class="language-javascript">function turn(color) {  
  traffic.className = color;
  return new Promise(function(resolve) {
    setTimeout(function() { resolve(this.next) }.bind(this), this.wait)
  }.bind(this))
}

turn.and = turn.bind; // 仅为了可读性  
void function (){  
  Promise.resolve('green')
    .then(turn.and({wait: 5000, next: 'yellow'}))
    .then(turn.and({wait: 2000, next: 'red'}))
    .then(turn.and({wait: 5000}))
    .then(arguments.callee)
}();
</code></pre>

<p>有人要跳出来了吧！有人要大喊NB了吧？！浅薄啊。我可不是为了显摆这个才在这里话痨的。如果仅是为了一些代码行数或者可读性上的差异，就要在这里吧啦吧啦一堆，那得是hax十年前的调性。  </p>

<p>这三段代码的好坏，我们晚点在说。反正当时裕波同学是笑出了眼泪的，然后这个case就在前端圈子里面传开了，然后就出现了很多很多种“不同的样子”：  </p>

<hr>

<p>@winter寒冬 强调turn/wait要分离提出的#46：<a href="http://code.w3ctech.com/detail/46">在这里</a>，与<a href="http://code.w3ctech.com/detail/39">#39</a>有相似之处。  </p>

<p>@米粽粽 在#41上的改进型#51：<a href="http://code.w3ctech.com/detail/51">在这里</a>，这是我后来认为“完美”的版本。  </p>

<p>@winter寒冬 根本停不下来，张牙舞爪ES6版！#52：<a href="http://code.w3ctech.com/detail/52">在这里</a>，这是使用yield的版本。  </p>

<p>@青空残红 的#45和#48版本，<a href="http://code.w3ctech.com/detail/45">在这里</a>和<a href="http://code.w3ctech.com/detail/48">这里</a>，前者尝试对Promise的“.then只能传递一个值”作修补；后者则采用深度递归来处理数组中的每个颜色和时间值。  </p>

<p>@随机 的全栈解决方案 #69，<a href="http://code.w3ctech.com/detail/69">在这里</a>，这个方案无关promise，而是引入服务端来做计时器，用ajax/jsonp来处理回调的  </p>

<p>@十年踪迹 引入Task概念，将红绿灯模拟(或声明、描述)成任务的方案 #57，<a href="http://code.w3ctech.com/detail/57">在这里</a>  </p>

<p>@-Lucifier- 的玩坏promise版 #49，<a href="http://code.w3ctech.com/detail/49">在这里</a>，这个方案也无关promise，是直接定义红绿灯状态/转换过程，然后用setTimeout回调来处理循环/链的。Lucifier强调：将过程碎片化的promise不是好promise，数据被打散从而无法组织。  </p>

<p>@-Lucifier- 过程与数据分离的promise版 #59，<a href="http://code.w3ctech.com/detail/59">在这里</a>，这个版本是#49的改进，加入了promise。  </p>

<p>@教主 逗比版（作者自己说的）#42，<a href="http://code.w3ctech.com/detail/42">在这里</a>，这个也是否定promise的版本，作者可能只是想表达一下情绪。^^.  </p>

<p>@ECMA #40，<a href="http://code.w3ctech.com/detail/40">在这里</a>，分别处理了color/timer定义。  </p>

<p>（注#40、#42、#49、#59等在讨论另一个 session：如果定义的红绿灯规则频繁变化，例如要加个紫灯怎么办。<a href="http://weibo.com/1221479170/CcD1G9WCi?type=repost">在这里</a>）  </p>

<p>还有一些我找不到出处的版本，比如#183 <a href="http://code.w3ctech.com/detail/183">在这里</a>，事实上这个写得我也看不懂了。  </p>

<hr>

<h2 id="">欢迎回到火星</h2>

<p>是的，我们刚才的地球探险结束了，火星文明在地球毁灭之后成了银河系中唯一有生命居住的地方。尽管单细胞生命过于原始，但总之好过于地球上的一片荒芜。  </p>

<p>不要再问我“地球文明毁灭于什么”这样的问题了。  </p>

<h2 id="">感谢“米粽粽”同学提到我的一篇旧文</h2>

<p>事实上，让我换了一个角度思考这个问题的，正是我自己的那篇旧文，感谢“米粽粽”同学提到这篇文章：  </p>

<blockquote>
  <p>《前端要给力之：代码可以有多烂？》 <a href="http://blog.csdn.net/aimingoo/article/details/6036574">在这里</a>  </p>
</blockquote>

<p>那是另外的一段历史，那段历史揭示了这样一个真理：  </p>

<blockquote>
  <p>写一段牛B的代码，不如写一段有用的代码。  </p>
</blockquote>

<p>然而此时，我所关注的并不是这个。我在读那篇文章时看到自己曾经的一个思考：  </p>

<blockquote>
  <p>第一步的抽象通常是最关键的。  </p>
</blockquote>

<p>让我们回到火星吧，那里的单细胞生物也比复杂的地球人类好得很多。我们也许不解决任何问题，但我们知道什么是正确的。  </p>

<p>我相信hax的那个判断：如果它能证明正确，那就是正确的。并不因为人多的就是文明，而一个细胞就不能为自己发出声音。  </p>

<h1 id="">第一步的抽象</h1>

<p>我们所有上面的例子，都做错了第一步。  </p>

<p>我们所有的例子，从@十年踪迹 的第一个例子开始，都定义错了问题。大家不约而同地把问题想像成了：  </p>

<ul>
<li>先画一个红灯  </li>
<li>再等5000ms  </li>
<li>再画一个黄灯  </li>
<li>…  </li>
<li>循环到第一步  </li>
</ul>

<p>有一部分人将这个问题理解成另一种行为模式：  </p>

<ul>
<li>画一个红灯，等5000ms；然后  </li>
<li>画一个黄灯，等…；然后  </li>
<li>…  </li>
<li>循环到第一步  </li>
</ul>

<p>注意这个“循环到第一步”。在所有人的抽象里面，“循环到第一步”都是一个大问题。一方面，它总一个独立而又不同的步骤，所以它会打乱了所有的节奏，使得在画灯(turn)和等待(timeout)之外出现了一个“特殊的动作”；另一方面，它无论采用函数递归还是数组遍历来实现，都完全是基于一种旧的、非Promise化的思维模式。而正是这种思绪模式害了我们，使我们一步步地远离了真相，也远离了整个问题的本质。  </p>

<p>这种思维模式是：命令式编程。  </p>

<h2 id="">一点说明/前提</h2>

<p>在所有后续的讨论之间，我需要先说明一点。整个问题的最初提出，是@十年踪迹 的一段关于Promise如何使用的代码，十年踪迹先定义(def)了一些Promise，然后用.then()把它们连续起来，在最后一个.then()中它递归调用restart()来实现循环。整个过程如@十年踪迹 所说的，是Promise应用的一个示例。而Winter与它PK的，以及裕波m给我和hax需要去评判的，也是“如何写好Promise”的一个问题。  </p>

<p>所以我们不讨论非Promise实现，也不讨论Promise在特定问题上是否“更好/更不好”的问题，而是讨论“怎样才算是正确的Promise实现”。  </p>

<h2 id="">重新定义问题</h2>

<p>我们说“循环到第一步”是一个大问题，是指它难于处理，而不是说它是“问题的本身”。在前面的例子中，没有人想到这样的一件事，既然是：  </p>

<ul>
<li>画一个红灯，等5000ms；然后  </li>
<li>…  </li>
</ul>

<p>那么，在红灯之前在做什么？  </p>

<p>而答案可以是这样：在红灯之前，请先等待0ms。如此一来，整个的操作就变成了这样：  </p>

<ul>
<li>等0ms，画一个红灯  </li>
<li>等5000ms，画一个黄灯  </li>
<li>等2000ms，画一个绿灯  </li>
<li>等5000ms，回到第一步  </li>
</ul>

<p>然而这样定义问题的好处是什么呢？这样一来，我们可以把每一组操作理解这样两个数据：  </p>

<blockquote>
  <p>time, color  </p>
</blockquote>

<p>以及加在这对数据上的一个行为（WaitAndDo）或一个行为序列(Wait time, and Do turn color)。至于最后一个“操作”，它的模式跟上面没有区别，只是第二个行为是Do call，而不是Do turn color。  </p>

<p>然而，为什么要这么来定义问题呢？  </p>

<p>原因就是我们前面就一再提到过的，Promise编程的核心思想其实是：  </p>

<blockquote>
  <p>如果数据就绪(promised)，那么(then)做点什么。  </p>
</blockquote>

<p>这决定了在Promise架构下的“正确的思绪方式”。  </p>

<p>看到了吗？我们正确的，要处理的东西是这样：  </p>

<pre><code class="language-javascript">var promisedData = [  
        [0,     trun.bind('green')],
        [5000,  trun.bind('yellow')],
        [2000,  trun.bind('red')],
        [5000,  arguments.callee]
];
</code></pre>

<p>注意，在每对数据(step)中，元素step[0]是timeout的ms值，而step[1]是一个行为——行为也是数据，它是另一个被称为“调用”的行为的处理对象。  </p>

<h1 id="promise">Promise的编程基础之逻辑过程</h1>

<p>有了上面的数据抽象之后，我们该怎么处理逻辑过程呢？这总结起来只有如下的三步。  </p>

<h2 id="">如何确认一个数据“就绪”</h2>

<p>无论就绪是指“成功”还是“失败”，一旦这个数据可供处理我们就称为就绪。就我们现在的理解中，一个数据要么在声明出来就已经就绪，要么是过一段时间，由一个异步过程来“使之”就绪。  </p>

<p>对于前者，Promise提供三种方法简单地得到这个数据的Promise实例：  </p>

<blockquote>
  <p>Promise.reslove()     </p>
  
  <p>Promise.reject()     </p>
  
  <p>Promise.all()  </p>
</blockquote>

<p>很多人在处理Promise时会绕圈子，比如以为Promise总是异步的。在winter最早写的#31中就会这样：  </p>

<pre><code class="language-javascript">function turnGreen(){  
    return new Promise(function(resolve, reject) {
        traffic.className = 'green';
        resolve();
    })
}
</code></pre>

<p>这样的Promise是不需要用new来实现的。它表明的意思，在Promise架构下应该是这样来实现：  </p>

<pre><code class="language-javascript">var turn = function(color) {  
    traffic.className = color;
}

Promise.resolve('green')  // 数据就绪  
    .then(turn)           // 做点什么
</code></pre>

<p>所以上面的代码在实现逻辑上写成：  </p>

<pre><code class="language-javascript">// turn()略
var print = function(msg) {  
    console.log(msg)
}

var promised = Promise.resolve('green');  
promised.then(turn);  
promised.then(print);  
</code></pre>

<p>也是合理的。这里的代码看起来过程式、面向对象，但实际上也是Promise化的。这与Promise的基本思想一点儿也不矛盾。  </p>

<p>而使用new关键字的：  </p>

<blockquote>
  <p>new Promise(func)  </p>
</blockquote>

<p>这种方法，通常是用于func是一个异步过程的情况。——如果func是一个普通的（同步的）过程，那么它调用时就会直接返回，那简单地：  </p>

<blockquote>
  <p>promised = Promise.resolve(func());  </p>
</blockquote>

<p>就好了 。而new Promise(func)中，要求这个func接收两个参数的目的也就在这里：  </p>

<pre><code class="language-javascript">promised = new Promise(function func(resolve, reject) {  
   ...
});
</code></pre>

<p>对于func来说，它的函数返回值对new Promise()过程，以及其结果promised来说都是无关紧要的。它只需要在合适的时候调用resolve/reject即可。  </p>

<p>但我们必须强调：Promise的编程理念中，“是不是异步系统”一点儿也不关键。甚至可以说，“在异步系统中使用”只是这种理念中的一个处理技巧。  </p>

<h2 id="then">然后(then)只能处理一个数据</h2>

<p>在.then(fulfilled)中的函数fulfilled不但只能处理一个数据，而且只能处理“刚才”就绪的那个数据。这个所谓刚才，只是指在语法上的顺序。例如：  </p>

<pre><code class="language-javascript">// ...
promisedA.then(func1);  
promisedB.then(func2);  
func3();  
</code></pre>

<p>这表明func1处理A在刚才promised的数据，而func2处理B在刚才promised的数据。由于promised可以是来自用  </p>

<blockquote>
  <p>new Promise()  </p>
</blockquote>

<p>异步得到的一个数据，因此所谓“刚才”仅是指在执行func1之前，而与语法上的.then()——的出现顺序——无关。所以，正确的说法是：  </p>

<ul>
<li>promisedA.then(）  </li>
<li>promisedB.then(）  </li>
<li>func3()  </li>
</ul>

<p>总是立即地、顺序地执行，而func1()和func2()的调用时间取决于promisedA/B就绪的时间。  </p>

<p>而如上面所说，.then(）中的函数只能处理一个数据，这个数据就是就绪的那个数据（有些文档称“将数据从promised中解包”）。这个“只处理一个”是Promise思想本质上决定的，任何试图去改变这一点的企图都将导致灾难。我后来称@米粽粽 的版本最好，是因为它在这一点上是绕过去了，而不是去“fix掉它”：  </p>

<pre><code class="language-javascript">function turn(color, duration) {  
  return new Promise(function(resolve, reject) {
    traffic.className = color
    setTimeout(resolve, duration)
  })
}

//执行！
void function run() {  
    turn('green', 1000)
    .then(turn.bind(null, 'yellow', 400))
    .then(turn.bind(null, 'red', 1000))
    .then(run)
}()
</code></pre>

<p>请注意这个turn.bind利用了bind的特性在函数闭包中传参，而在turn()处理的代码中，resolve实际上不返回也不“就绪“任何数据。所以.then()链中并没有数据流，而只有逻辑顺序。  </p>

<p>与之对照的，@青空残红 的#45代码就试图使then()链中传递多个数据（<a href="http://code.w3ctech.com/detail/45">在这里</a>）：  </p>

<pre><code class="language-javascript">typeof time == 'number' ? setTimeout(function(){resolve.apply(null, Array.prototype.slice(arg))},time) : resolve.apply(null, Array.prototype.slice(arg));  
</code></pre>

<h2 id="thenpromise">最后，任何情况下.then()总是立即返回一个promise</h2>

<p>.then()总是“！！立即！！”返回一个promise，而这是很少有人理解的部分。大多数人会提出“这个返回什么时候发生”这样的问题。而事实上，这总是立即发生的。——如前所说，Promise的这一切都与“异步/同步”无关。你必须非常明确：  </p>

<blockquote>
  <p>Promise.prototype.then()在执行过程中是立即返回，并总是返回一个新的promise2。  </p>
</blockquote>

<p>不明确的只是：这个promise（内的数据）是否就绪，或什么时候就绪。  </p>

<p>只有在就绪的时候，.then()中的函数才会被调用。这也是.then方法被声明为：  </p>

<blockquote>
  <p>Promise.prototype.then(onFulfilled, onRejected);  </p>
</blockquote>

<p>的原因：一是所有的promise原型中就有的方法，二是它的两个参数都是事件句柄（直到“数据就绪”事件触发时/触发后才执行）。  </p>

<p>在一定程度上，类似这样的说法：  </p>

<blockquote>
  <p>promised.then()的返回值总是下一个.then()的入口值  </p>
</blockquote>

<p>只是一种假象。它更准确的说法是：  </p>

<ul>
<li>promised.then()返回的是一个新的promise2；而  </li>
<li>promise2的就绪，是由promise.then(onFulfilled, onRejected)中onFulfilled/onRejected的返回值所决定的。  </li>
</ul>

<p>下面的示例说明这一点：  </p>

<pre><code class="language-javascript">// case 1: 返回任意值（包括undefind/Error实例)
//   - 将被以Promise.resolve(value)的方式返回到promise2
promise2 = promise.then(function() {  
    return 'true'
})

// case 2: 返回一个新的promise，这个promise可以是就绪（resolved/rejected）的数据
//  - 也可以是未就绪的（异步调用处理）的数据
promise2 = promise.then(function() {  
    return Promise.reject('ERROR')
})


// case 3: 任何时候，代码执行错或throw，都将使promise2得到一个rejected的数据
promise2 = promise.then(function() {  
    throw new Error('ERROR')
})

// case 4: 在onRejected()的处理中，也可以返回resolved的数据
var _ = undefined;  
promise2 = promise.then(_, function() {  
    return Promise.resolve('OK')
})
</code></pre>

<h1 id="">解决问题的方法</h1>

<p>我们已经得到了那个原始问题的、基于Promise思想的数据定义：  </p>

<pre><code class="language-javascript">var promisedData = [  
        [0,     trun.bind('green')],
        [5000,  trun.bind('yellow')],
        [2000,  trun.bind('red')],
        [5000,  arguments.callee]
];
</code></pre>

<p>那么，接下来呢？  </p>

<h2 id="">得到一些基础件</h2>

<p>我们先想像一下，我们能“就绪”的，和接下来要处理的是什么。在这个问题中，我们留意到，我们事实上要处理上述4个项中的“每一个”；具体到每一个，都是一个简单的“等待，然后调用（WaitAndDo）”。那么，对“每一个”来说，我们需要一个迭代器来列举之。这个好办，在chrome中array.entries()就可以得到它了；而对每一次的“等待+调用（WaitAndDo）”，我们用一个runner来处理每step的数据。  </p>

<p>这样一来，我们可以先得到一些与基本的数据和处理。这些与具体的逻辑是无关的：  </p>

<pre><code class="language-javascript">function turn() {  
    traffic.className = this;
}

function runner(step){  
    return new Promise(function(resolve) {
        setTimeout(resolve, step[0]);
    }).then(step[1])
}

var promisedData = [  
    [0,     turn.bind('green')],  // step1
    [5000,  turn.bind('yellow')], // step2
    [2000,  turn.bind('red')],    // ...
    [5000,  main]
];

function main() {  
    var iteratorPromise = Promise.resolve(promisedData.entries());
    ...
}
</code></pre>

<p>注意这里的iteratorPromise，它是entries()的返回结果，是一个iterator。如果在别的js引擎里，你可能需要其它方式得到它。当然，要手写一个也不难，不会用到.yield。此外，promisedData 可以放在main外面，只是因为它利用了main函数名在当前闭包中可用（而与声明的顺序无关），如果不这样，你可能真得把它放在main函数内部并用argument.callee来得到它。  </p>

<h2 id="promise">如何在Promise中处理迭代</h2>

<p>在Promise中处理迭代是一件比较麻烦的事，原因是Promise本身并不考虑“流程/逻辑”的问题——再再一次强调Promise关注的是“数据就绪”，是面向数据思考的。  </p>

<p>处理这样的迭代的通常思路是使用一个循环，比如用递归函数来实现。考虑到Promise的特性，所以递归函数应该返回一个新的Promise实例，并且总是用Promise链的最后一个.then()来进入下一次递归。这样的一来，main()函数的逻辑就很明显了：  </p>

<pre><code class="language-javascript">// ...

// 获得迭代器中的iterator.next()的成员，并使之resolved
//  - 通过picker.bind()将iterator绑定到this
function picker(item) {  
    return (item = this.next()).done ? Promise.reject(item) : Promise.resolve(item.value[1]);
}

function main() {  
    var iteratorPromise = Promise.resolve(promisedData.entries());
    iteratorPromise.then(function(iterator) {
        var getPromisedItem = picker.bind(iterator);
        return function loop() {
            return getPromisedItem().then(runner).then(loop);
        }()
    })
}
</code></pre>

<p>完整的代码#73（<a href="http://code.w3ctech.com/detail/73">在这里</a>）。我通常会用一些技巧来把代码写得更像函数式一点，但那些仅仅是技巧而已，例如另一份类似的代码是#60（<a href="http://code.w3ctech.com/detail/60">在这里</a>），只是在loop的处理上有些不同，但整个框架是一致的。  </p>

<p>我更喜欢在#73中对picker的使用，这个picker通用性很好，没有负担，而且也不影响在后面的代码组织，看起来很清洁的样子。但picker和#60中的loop的关系，就跟Array.prototype.forEach与for (var i=0, …)两种循环类似，不影响使用Promise来解题的思路了。  </p>

<h2 id="">迭代中的一些其它问题</h2>

<p>正如一些语言禁止访问for循环的中间变量（或其“返回”）一样，将“迭代”用于“完成一批处理/得到一个数据”是两种不同的抽象，因此也有不同的迭代设计。但总的来说，这是循环结构的一种。  </p>

<p>“结构程序设计”中不是讨论了三种吗？顺序结构是显而易见的，而分支结构在Promise中通过.then(yes, no)这样的语义来表达。当然，在程序内部，你也可以用这样的语言来控制（后续的）流程。这是上面picker()设计中采用的一处技巧：  </p>

<pre><code class="language-javascript">function picker(item) {  
    return (item = this.next()).done ? Promise.reject(item) : Promise.resolve(item.value[1]);
}
</code></pre>

<p>当iterator.next()到done时，picker将返回Promise.reject(item)。这里是否使用item并不重要，关键在于它reject了一个值。因此，这时在main()的loop()函数中：  </p>

<pre><code class="language-javascript">function loop() {  
    return getPromisedItem().then(runner).then(loop);
}
</code></pre>

<p>then()链只响应了onFulfilled而没有处理onRejected，于是得以退出循环。并且最终整个loop()向外面的main()返回的，也将是一个reject()的item，它是iterator的迭代结果值：{ done: true, value: undefined }。  </p>

<p>这可能不是你想要的。一方面，在整个过程中要考虑是否响应onRejected，另一方面，整个迭代如果真的需要返回值（例如汇总）呢？  </p>

<p>如果“迭代”是一个过程，那么如何做到这个过程对函数外无副作用？这的确需要一些设计，但不是没有现成的解决方法，要不你认为array.forEach()中传入thisObject是来做什么的？至于onRejected，反倒是最容易理解的：该迭代没有设计有效的返回。  </p>

<h1 id="">一点点好处</h1>

<p>这样解决问题究竟有什么价值呢？  </p>

<p>我们把原始问题抽象成了“数据就绪，则处理之”的简单模型，所以你会留意到对于更复杂的情况，只要是可以用：  </p>

<blockquote>
  <p>[wait, andRun]  </p>
</blockquote>

<p>数据模型表示的序列，都可以由交由上面的框架去run，整个的main()逻辑上并不需要修改。如果是不需要循环，也只是需要将  </p>

<blockquote>
  <p>[5000, main]  </p>
</blockquote>

<p>这个item从promisedData[]中抽掉即可。可见，main()带来了一个清晰、稳定和可靠的执行器环境 。  </p>

<p>接下来，让我们再一次回到原始的问题。看起来我们的“第一步的抽象”还算不错，但实际上仍有那么些粗糙的。比如我们其实可以将2000ms理解为“一个2000的值，和一个称为timeout的行为”这样的一对数据。在这个基础上，我们可以得到更精确/精美的promisedData 和相关的runner。如下（<a href="http://code.w3ctech.com/detail/184">#184</a>）：  </p>

<pre><code class="language-javascript">function timeout(ms) {  
    return new Promise(function(next) { setTimeout(next, ms) })
}
function turn(color) {  
    return Promise.resolve(traffic.className = color);
}
function runner(data){  
    // 请试想这里为什么不直接用data[1](data[0]) ?
    return Promise.resolve(data[0]).then(data[1]);
}
var promisedData = [  
    [0,        timeout],  // step1
    ['green',  turn],     // step2
    [5000,     timeout],  // ...
    ['yellow', turn],
    [2000,     timeout],
    ['red',    turn],
    [5000,     timeout],
    [undefined, main]
];

// （其它同于代码#73）
// ...
</code></pre>

<p>考虑到更通用的情况，为什么我们不能将“所有的东西”都理解为一个数据呢？又或者将andRun元素理解为数据的模型该如何做呢？  </p>

<p>当我们将上述step1也理解为“一个行为的一组数据对”的时候，我们就可以“自然而然地”想到，如果“0”不是一个时间，而是一个用表明“远端服务的状态是否就绪”呢？那么，上面这个程序可以非常非常简单地扩展到全栈：  </p>

<pre><code class="language-javascript">var waiting = new Promise(function(resolve, reject) {  
    // ajaxLoad and exec resolve() in callback, or reject anything
});
var promisedData = [  
    [waiting,     timeout],  // step1
    ...
];

// （没什么要改的了）
// ...
</code></pre>

<h1 id="">其它</h1>

<p>1. 我写的Promise in Lua项目在这里：<a href="http://github.com/aimingoo/Promise">http://github.com/aimingoo/Promise</a> <br>
2. 所有代码在code.w3ctech上可以找到，我的在这里：<a href="http://code.w3ctech.com/4204">http://code.w3ctech.com/4204</a> <br>
3. “前端要给力”这个系列是很久以前就写的了：  </p>

<blockquote>
  <ol>
  <li><a href="http://blog.csdn.net/aimingoo/article/details/6036574">前端要给力之：代码可以有多烂？</a></li>
  <li><a href="http://blog.csdn.net/aimingoo/article/details/6097378">前端要给力之：原子，与原子联结的友类、友函数</a></li>
  <li><a href="http://blog.csdn.net/aimingoo/article/details/6105048">前端要给力之：分解对象构造过程new()</a></li>
  <li><a href="http://blog.csdn.net/aimingoo/article/details/6081964">前端要给力之：URL应该有多长？</a></li>
  </ol>
</blockquote>

<p>4. 本文最后一个示例是说明在“全栈”的背景下，正确使用Promise可以得到很好的系统弹性。 <br>
5. 在.then()界面上处理多个参数的方法，是使用Promise.all()来就绪一组数据并作为参数。我建议使用工具函数unpack来处理调用界面部分，例如（<a href="http://code.w3ctech.com/detail/185">#185</a>）：  </p>

<pre><code class="language-javascript">function unpack(promised) {  
    return this.apply(null, promised)
}

Promise.all([1,2,3])  
    .then(unpack.bind(function(a, b, c) {
        console.log('result:', a +b +c);
    });
</code></pre>]]></content:encoded></item><item><title><![CDATA[架构师真正要学会的事情]]></title><description><![CDATA[<h2 id="">一、要学会去看，然后忘掉</h2>

<p>有一本书叫《观止》，写的是微软研发Windows NT的一段故事。“观止”在这里的意思是说“看到这些，就无需再看了”，因为世上之物亦无过于此。20多年过去，如今微软在操作系统上面临着的种种挑战与困境，其实与《观止》所叙的研发方法、理念与目标有着天生而来的血缘关系。</p>

<p>另一个与“看”相关的词汇是“所见即可得(WYSIWYG)”。这个词以及与此相关的WIMP（Windows, Icon, Menu and Pointer）曾经主导了整个人机交互的设计理念。也是在20多年前，Borland为Windows桌面系统成功地设计了跨语言的VCL，由此“所见即所得”成为Borland对“如何更便捷地构建UI”的基本假想，以至于这家伟大的公司在互联网时代来临时决定“用VCL描述界面的方式来解决‘网站设计’的问题（RadPHP）”。</p>

<p>然而，互联网上的网页是没有WIMP的；移动设备上的操作系统也不再采用与Windows NT类似的方式开发。</p>

<p>Borland在几年之前将整个开发工具产品线都卖掉了。当时盛大的一个Delphi圈子发起了一次“缅怀活动”，组织者说：</p>]]></description><link>http://aimingoo.github.io/1-263.html/</link><guid isPermaLink="false">d2c00eb8-340b-4be7-a77c-ef93630bd997</guid><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Thu, 06 Nov 2014 22:07:31 GMT</pubDate><content:encoded><![CDATA[<h2 id="">一、要学会去看，然后忘掉</h2>

<p>有一本书叫《观止》，写的是微软研发Windows NT的一段故事。“观止”在这里的意思是说“看到这些，就无需再看了”，因为世上之物亦无过于此。20多年过去，如今微软在操作系统上面临着的种种挑战与困境，其实与《观止》所叙的研发方法、理念与目标有着天生而来的血缘关系。</p>

<p>另一个与“看”相关的词汇是“所见即可得(WYSIWYG)”。这个词以及与此相关的WIMP（Windows, Icon, Menu and Pointer）曾经主导了整个人机交互的设计理念。也是在20多年前，Borland为Windows桌面系统成功地设计了跨语言的VCL，由此“所见即所得”成为Borland对“如何更便捷地构建UI”的基本假想，以至于这家伟大的公司在互联网时代来临时决定“用VCL描述界面的方式来解决‘网站设计’的问题（RadPHP）”。</p>

<p>然而，互联网上的网页是没有WIMP的；移动设备上的操作系统也不再采用与Windows NT类似的方式开发。</p>

<p>Borland在几年之前将整个开发工具产品线都卖掉了。当时盛大的一个Delphi圈子发起了一次“缅怀活动”，组织者说：爱民，你应该会为那个时代写点什么吧？</p>

<p>我在那个缅怀网页上写下了五个字：所见即所碍。  </p>

<h2 id="">二、要学会去听，然后忘掉</h2>

<p>我通常说架构是一种能力，架构角色则是要求你在具体事务中行使某些行为，而架构师则是用来标识这些能力与行为的一个职务。</p>

<p>当一些人将个人成长定义为“职业发展”时，就表现为“怎样成为架构师”这样的问题。对此有三种解决方案，第一种是印一张写着这样头衔的名片，而“是与不是”架构师并不重要；第二种是直接否定这个职务的意义，比如声称敏捷天生就是反架构的，于是“架构师”变成了要打倒的对象，所以成不成为这个将被打倒的对象也就不重要了；第三种则干脆声称“人人都是架构师”，既然人人都是了，那么“如何成为”也自然就不重要了。</p>

<p>我们大多数人都具有架构的能力，并且也或多或少地行使某些架构角色的行为，唯一缺乏的只是一个叫做“架构师”的头衔而已。问题出在：我们总是期望别人通过这样的头衔来认可自己。于是我们为自己贴上这样或那样的标签，然后跟别人持有的同种标签去比对，期求出现一致或找出某种差别。于是我们听到种种声音：某某某真的是/不是、像/不像架构师；如果是架构师，那么就要这样、那样，以及怎样怎样；其实这个架构，或这样的架构，或某种架构应该怎么怎么做；以及架构是什么什么，架构师是什么什么，等等等等。回顾“三种解决方案”，仍是困在这样的认可求同之中，与之在做着种种斗争罢了。</p>

<p>其实不单是你的所见阻碍了你自己，你还被别人的所见阻碍着。</p>

<h2 id="">三、要学会去做，然后忘掉</h2>

<p>朋友给我聊他家的两岁小孩：我刚把桌子收拾好，一转眼杯子碗筷什么的都全摔地上了。我问：怎么了？他说：小孩子什么也不懂啊，她看着桌布喜欢，就一把抓过去……</p>

<p>小孩子没能看到桌子上还有杯子，但正因为他们的视线里没有杯子，他们的行动才简单直接，才直达需求，才迅速。而我们的眼睛里有杯子、桌子、桌布等等一切，我们经年累月地维护着其中的次序与关系直到这些东西混成一体，然后我们便日日坐守在它们的面前，而又无觉他们的存在。</p>

<p>正是我们自己不知不觉地设定了这些事物之间的界线，并把这些界限、层次与逻辑井然的东西称为“系统”。当我们从那些无序的事物中识别出了这样的“系统”并用一些概念、名词去定义了它们之后，我们对此的一切知识也就固化了；当这种秩序被建立起来之后，我们也就得到了对有序和无序（没有你所设定的“这种秩序”）价值的识别与肯否；当我们设定了种种价值、观念、观察与系统的模型概念之后，我们也就完成了这个系统的架构。</p>

<p>但这一过程，包括完成这一架构——它可以命名为“世界观”——的方法以及结果，在本质上不过是让你从一个格子跳到了另一个格子而已。我们处在种种界限之中，再也无法回到两岁小孩的、一切无碍的视角——在那个视角下，根本就没有所谓的界线。你之所以时时在寻求跨界，其实是源自你假设了“存在界线”，这就如同全栈的含义其实是“没有栈”，而当有人信心满满地要“成为全栈工程师”时，他的眼里便又有个“这个栈”的存在。</p>

<p>所谓跨界不是指你能力与方法上的变化，你的作为取决于你的格局，你的格局取决于你的所见。</p>

<h2 id="">四、要学会超越</h2>

<p>架构师需要超越自己与别人的所见，因为你观察与架构的对象称为“系统”，你看到系统多少的真相，决定了你用怎样的影像去表现它，并进而推进与实现这种影像——亦即是架构。我们所既已知道的、理解的、明白的，形成了我们的知识与行为的一切，却也正是阻碍着我们前进的东西。这些障碍正是你以为你最珍视的、最不可放弃的、最鲜血淅沥体验过的那些经验与成就。在这些所得与所碍中挣扎与决策，就是架构师的全部职责。因此作为架构师，你需要能够超越自已对系统的既有认识，看到你在光明中——显而易见之处——所未见的，这是你驱动系统架构进化的主要动力。</p>

<p>所以架构中最难超越的并不是某个大师或前辈，而是你以及你为自己所作的设定。当你设定了“架构师”这个目标，便设定了这个目标所表达的某种影像（角色），你最终可能变得跟这个影像完全一致——成为所谓“真正的架构师”，但你仍不过是困囿于对这个“角色”的一个假设/设定而已。唯一破局的方法是：超越别人对某个角色的定义，将自己做成这个角色。</p>

<p>至此，你是否还在这个角色之中，就是你的觉悟了。  </p>

<h2 id="">其它</h2>

<ol>
<li>本文是为《程序员必读之软件架构》一书所写的序  </li>
<li>《程序员必读之软件架构》一书的译者是邓钢先生( @米粽粽 <br>
据说已关注洗碗30年+）</li>
<li>该书由图灵出版，原作者是Simon Brown，据说是个布道师（这年头站台上就说自己是甘道夫的人真的是多了去了）  </li>
<li>该书在图灵社区的信息在这里：<a href="http://www.ituring.com.cn/book/1444">http://www.ituring.com.cn/book/1444</a>  </li>
<li>该书220多页，有4篇序（是多了点，我也是肇祸者之一，对不住大家了）。点这里直到把屏幕戳碰可见译/作者的原序：<a href="http://www.ituring.com.cn/article/125176"><strong>译者序</strong></a>，<a href="http://www.ituring.com.cn/tupubarticle/1234"><strong>原序</strong></a>，以及<a href="http://www.ituring.com.cn/tupubarticle/3630"><strong>杜欢同学的序</strong></a>  </li>
<li>杜欢同学没请我饭已经很久了，此碎碎念300+1次。</li>
</ol>]]></content:encoded></item><item><title><![CDATA[MPD大会上使用的PPT分享 - 2014]]></title><description><![CDATA[<p>MPD（软件工作坊）中我的内容是“详解架构之核心指导原则“。我详细讲述了我所认识的架构，以及有关它的五项核心的指导原则。所谓核心，是指这些原则讨论的问题相当基础，面向架构本身的、本质的问题，例如架构的必要性与正确性。所谓指导原则，是在我看来，这些原则可以为其它有关架构的认识与思想提供依据，是其他有效的、可供讨论的认识与思想不可违逆的基本前设。</p>

<p>下面是此次分享中的完整PPT，下载在这里：</p>

<ol>
<li>PPT：<a href="http://aimingoo.github.io/content/images/attachments/Principles_Of_Arch.2014.zip">详解架构之核心指导原则</a>  </li>
<li>视频（无）。</li>
</ol>]]></description><link>http://aimingoo.github.io/1-194.html/</link><guid isPermaLink="false">881d7ba7-e824-4f3f-8b0b-d06c805a5855</guid><category><![CDATA[架构]]></category><dc:creator><![CDATA[aimingoo]]></dc:creator><pubDate>Mon, 22 Sep 2014 12:54:00 GMT</pubDate><content:encoded><![CDATA[<p>MPD（软件工作坊）中我的内容是“详解架构之核心指导原则“。我详细讲述了我所认识的架构，以及有关它的五项核心的指导原则。所谓核心，是指这些原则讨论的问题相当基础，面向架构本身的、本质的问题，例如架构的必要性与正确性。所谓指导原则，是在我看来，这些原则可以为其它有关架构的认识与思想提供依据，是其他有效的、可供讨论的认识与思想不可违逆的基本前设。</p>

<p>下面是此次分享中的完整PPT，下载在这里：</p>

<ol>
<li>PPT：<a href="http://aimingoo.github.io/content/images/attachments/Principles_Of_Arch.2014.zip">详解架构之核心指导原则</a>  </li>
<li>视频（无）。</li>
</ol>]]></content:encoded></item></channel></rss>
